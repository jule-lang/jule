// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use env

use path for std::fs::path
use std::jule::build::{PATH_STDLIB}
use std::jule::constant::{Const}
use std::jule::sema::{
    Data,
    Scope,
    St,
    FnCallExprModel,
    Conditional,
    If,
    Case,
    Match,
}

// Scope optimizer that applies target-independent optimizations.
struct ScopeOptimizer {
    i:     int
    scope: &Scope
}

impl ScopeOptimizer {
    pub static fn new(mut scope: &Scope): &ScopeOptimizer {
        ret &ScopeOptimizer{
            scope: scope,
        }
    }

    fn optimize_data(mut self, mut d: &Data) {
        match type d.model {
        | &FnCallExprModel:
            let mut m = (&FnCallExprModel)(d.model)
            if env::PRODUCTION {
                if !m.func.is_builtin() &&
                    is_std_package(m.func.decl.token.file.path(), "debug") {
                    self.scope.stmts[self.i] = nil
                }
            }
        }
    }

    fn optimize_conditional(mut self, mut c: &Conditional) {
        if !env::OPT_COND {
            ret
        }

        // Remove unnecessary trailing cases that comes after constant true case.
        for (i, mut case) in c.elifs {
            if !is_constant_valid_conditional_case(case) {
                continue
            }
            if i == 0 { // First case.
                // Set current stmt to scope of case.
                self.scope.stmts[self.i] = case.scope
                ret
            }
            c.elifs = c.elifs[:i+1]
            case.expr = nil // Remove expression to remove eval overhead.
            c.default = nil // Remove default case, unreachable.
            break
        }

        // Remove unreachable cases.
        let mut i = &c.elifs[0]
        let end = &c.elifs[c.elifs.len-1]
        for i <= end; i++ {
            unsafe {
                if !is_unreachable_conditional_case(*i) {
                    i++
                    continue
                }
                *i = nil
            }
        }
    }

    fn optimize_match(mut self, mut m: &Match) {
        if !env::OPT_COND {
            ret
        }

        // Remove unnecessary trailing cases that comes after constant true case.
        for (i, mut case) in m.cases {
            if !is_constant_valid_match_case(case) {
                continue
            }
            if i == 0 { // First case.
                // Set current stmt to scope of case.
                self.scope.stmts[self.i] = case.scope
                ret
            }
            m.cases = m.cases[:i+1]
            case.exprs = nil // Remove expressions to remove eval overhead.
            m.default = nil  // Remove default case, unreachable.
            break
        }

        // Remove unreachable cases.
        let mut i = &m.cases[0]
        let end = &m.cases[m.cases.len-1]
        for i <= end; i++ {
            unsafe {
                if !is_unreachable_match_case(*i) {
                    i++
                    continue
                }
                *i = nil
            }
        }
    }

    fn optimize_stmt(mut self, mut stmt: St) {
        match type stmt {
        | &Scope:       self.optimize_child((&Scope)(stmt))
        | &Data:        self.optimize_data((&Data)(stmt))
        | &Conditional: self.optimize_conditional((&Conditional)(stmt))
        | &Match:       self.optimize_match((&Match)(stmt))
        }
    }

    fn optimize_child(mut self, mut child: &Scope) {
        let mut so = ScopeOptimizer.new(child)
        so.optimize()
    }

    // Optimizes scope by enabled optimizations.
    pub fn optimize(mut self) {
        self.i = 0
        for self.i < self.scope.stmts.len; self.i++ {
            self.optimize_stmt(self.scope.stmts[self.i])
        }
    }
}

fn is_std_package(f: str, p: str): bool {
    ret f.has_prefix(path::join(PATH_STDLIB, p))
}

fn is_constant_valid_conditional_case(&i: &If): bool {
    match type i.expr {
    | &Const:
        let c = (&Const)(i.expr)
        ret c.is_bool() && c.read_bool()
    }

    ret false
}

fn is_constant_valid_match_case(&case: &Case): bool {
    for _, expr in case.exprs {
        if expr.is_const() && expr.constant.is_bool() && expr.constant.read_bool() {
            ret true
        }
    }

    ret false
}

fn is_unreachable_conditional_case(&i: &If): bool {
    match type i.expr {
    | &Const:
        let c = (&Const)(i.expr)
        ret c.is_bool() && !c.read_bool()
    }

    ret false
}

fn is_unreachable_match_case(&case: &Case): bool {
    for _, expr in case.exprs {
        if expr.is_const() && expr.constant.is_bool() && !expr.constant.read_bool() {
            ret true
        }
    }

    ret false
}
