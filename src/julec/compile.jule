// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use deadcode
use env::{self, Opt, OptLevel, push_opt_level}
use importer
use obj::{IR}
use cxx for obj::cxx

use std::env
use std::flag::{FlagSet}
use std::fs::{FsError, OFlag, File, Directory, Status}
use std::fs::path::{join, dir}
use integrated for std::jule::integrated
use std::jule::lex::{is_decimal, is_ident_rune, is_letter, is_space}
use std::jule::sema::{
    ImportInfo,
    Package,
    SemaFlag,
    analyze_package,
}
use std::jule::build::{
    self,
    LogMsg,
    Log,
    PATH_WD,
    PATH_STDLIB,
    DISTOS,
    DISTARCH,
    ENTRY_POINT,
    INIT_FN,
    logf,
    is_valid_cpp_ext,
}

cpp unsafe fn system(cmd: *integrated::Char): int

// Sets by COMPILER or command-line inputs.
static mut COMPILER: str = ""
static mut COMPILER_PATH: str = ""

static mut OUT_DIR: str = "dist"
static mut OUT_NAME: str = "ir.cpp"
static mut OUT: str = ""
static mut CPP_STD: str = "c++17" // Default C++ standard

static mut SHADOWING: bool = false
static mut TRANSPILATION: bool = false

fn system(cmd: str): int {
    ret unsafe { cpp.system((*integrated::Char)(&cmd[0])) }
}

fn write_output(path: str, content: str) {
    let dir = dir(path)

    let (_, mut err) = Status.of(dir)
    if err != FsError.Ok {
        err = Directory.create(dir)
        if err != FsError.Ok {
            exit_err("a problem occurs when code generation")
        }
    }

    err = File.write(path, ([]byte)(content), 0660)
    if err != FsError.Ok {
        exit_err("a problem occurs when code generation")
    }
}

// Remove generated objects for compilation.
fn clear_objects() {
    if File.remove(get_compile_path()) != FsError.Ok {
        outln("a problem occurs when object cleaning")
        ret
    }

    // All created objects are cleaned.
    // So, deletes directory if empty after cleaned all objects,
    // if not, leaves the directory.
    _ = Directory.remove(OUT_DIR)
}

// Compie generated IR.
fn compile_ir(compiler: str, compiler_cmd: str) {
    let status = system(compiler + " " + compiler_cmd)
    if status != 0 {
        out("external compiler failed with status code: ");
        outln(status)
        exit_err("")
    }

    clear_objects()
}

// Compile.
fn do_spell(obj: str, compiler: str, compiler_cmd: str) {
    let path = get_compile_path()
    write_output(path, obj)
    if !TRANSPILATION {
        compile_ir(compiler, compiler_cmd)
    }
}

fn is_cpp_source_file(path: str): bool {
    let offset = path.rfind(".")
    if offset == -1 {
        ret false
    }
    ret is_valid_cpp_ext(path[offset:])
}

// Generate compile command for backend-compiler.
fn gen_compile_cmd(source_path: str, &ir: &IR): (str, str) {
    let &compiler = COMPILER_PATH

    const ZERO_LEVEL_OPTIMIZATION = "-O0"
    const DISABLE_ALL_WARNINGS_CLANG = "-Wno-everything"
    const DISABLE_ALL_WARNINGS_GCC = "-w"
    let SET_STD = "--std=" + CPP_STD

    let mut cmd = ZERO_LEVEL_OPTIMIZATION
    cmd += " "

    match COMPILER {
    | "gcc":
        cmd += DISABLE_ALL_WARNINGS_GCC
        cmd += " "

    | "clang":
        cmd += DISABLE_ALL_WARNINGS_CLANG
        cmd += " "
    }
    cmd += SET_STD
    cmd += " "

    // Push passes.
    for _, pass in ir.passes {
        cmd += pass
        cmd += " "
    }

    // Push linked source files.
    for _, u in ir.used {
        if u.cpp_linked && is_cpp_source_file(u.path) {
            cmd += u.path
            cmd += " "
        }
    }

    if OUT != "" {
        cmd += "-o "
        cmd += OUT
        cmd += " "
    }
    cmd += source_path

    ret compiler, cmd
}

fn get_compile_path(): str {
    // let mut path = join(PATH_WD, OUT_DIR)
    // path = join(path, OUT_NAME)
    // ret path

    // Return command-line argument form
    // instead of absolute path.
    ret join(OUT_DIR, OUT_NAME)
}

fn apply_target_independent_optimizations(mut &ir: &IR) {
    if env::OPT_DEADCODE {
        deadcode::eliminate(ir)
    }
}

fn check_compiler_flag() {
    match COMPILER {
    | "":
        exit_err("missing option value: --compiler")

    | "clang":
        COMPILER_PATH = "clang++"

    | "gcc":
        COMPILER_PATH = "g++"

    |:
        exit_err("invalid option value for --compiler: " + COMPILER)
    }
}

fn check_target_arch(arch: str) {
    for _, distarch in DISTARCH {
        if arch == str(distarch) {
            ret
        }
    }

    exit_err("--target: unsupported/undefined architecture: " + arch)
}

fn check_target_os(os: str) {
    for _, distos in DISTOS {
        if os == str(distos) {
            ret
        }
    }

    exit_err("--target: unsupported/undefined operating system: " + os)
}

fn check_target_flag(&target: str) {
    if target == "" {
        exit_err("missing option value: --target")
    }

    let parts = target.split("-", -1)
    if parts.len != 2 {
        exit_err("--target: undefined platform target format: " + target)
    }

    let (os, arch) = parts[0], parts[1]

    if os != "native" {
        check_target_os(os)
        env::OS = os
    }

    if arch != "native" {
        check_target_arch(arch)
        env::ARCH = arch
    }
}

fn check_opt_flag(&opt: str) {
    if opt == "" {
        exit_err("missing option value: --opt")
    }

    match opt {
    | "L0": // Nothing.
    | "L1": push_opt_level(OptLevel.L1)
    |:      exit_err("--opt: invalid optimization level: " + opt)
    }
}

fn check_flags(&args: []str): []str {
    let mut opt: str = "L0"
    let mut target: str = "native-native"

    let mut fs = FlagSet.new()

    fs.add_var[bool](unsafe { (&bool)(&SHADOWING) }, "shadowing", 0, "Let shadowing")
    fs.add_var[bool](unsafe { (&bool)(&TRANSPILATION) }, "transpile", 't', "Transpile code")
    fs.add_var[str](unsafe { (&str)(&COMPILER) }, "compiler", 0, "Backend compiler")
    fs.add_var[str](unsafe { (&str)(&opt) }, "opt", 0, "Optimization level")
    fs.add_var[str](unsafe { (&str)(&target) }, "target", 0, "Target system")
    fs.add_var[str](unsafe { (&str)(&OUT) }, "out", 'o', "Output identifier")
    fs.add_var[bool](unsafe { (&bool)(&env::OPT_COPY) }, "opt-copy", 0, "Copy optimization")
    fs.add_var[bool](unsafe { (&bool)(&env::OPT_DEADCODE) }, "opt-deadcode", 0, "Deadcode optimization")
    fs.add_var[bool](unsafe { (&bool)(&env::OPT_APPEND) }, "opt-append", 0, "Append optimization")
    fs.add_var[bool](unsafe { (&bool)(&env::OPT_MATH) }, "opt-math", 0, "Math optimization")
    fs.add_var[bool](unsafe { (&bool)(&env::OPT_ACCESS) }, "opt-access", 0, "Access optimization")
    fs.add_var[bool](unsafe { (&bool)(&env::OPT_INLINE) }, "opt-inline", 0, "Inline optimization")
    fs.add_var[bool](unsafe { (&bool)(&env::OPT_PTR) }, "opt-ptr", 0, "Pointer optimizations")

    let (mut content, error) = fs.parse(args[1:])
    if error != "" {
        exit_err(error)
    }

    check_compiler_flag()
    check_target_flag(target)
    check_opt_flag(opt)

    ret content
}

fn setup_sema_flags(mut &flags: SemaFlag) {
    if SHADOWING {
        flags |= SemaFlag.Shadowing
    }
}

fn build_ir(&args: []str): &IR {
    let content = check_flags(args)

    let mut sema_flags = SemaFlag.Default
    setup_sema_flags(sema_flags)

    if content.len == 0 {
        exit_err(logf(LogMsg.MissingCompilePath))
    } else if content.len > 1 {
        exit_err("undefined content: " + content[1])
    }
    let path = content[0]

    // Check standard library.
    let (inf, err) = Status.of(PATH_STDLIB)
    if err != FsError.Ok || !inf.is_dir() {
        exit_err(logf(LogMsg.StdlibNotExist))
    }

    // Initialize flags for directive eval.
    importer::init_flags()

    let (mut ir, logs) = IR.build(path, sema_flags)

    if ir == nil && logs == nil {
        exit_err(logf(LogMsg.NoFileInEntryPackage, path))
    }

    if logs != nil {
        Logger.print_logs(logs)
        exit_err("")
    }

    ret ir
}

// Process compile command by "ARGS" global.
fn compile_command(&args: []str) {
    let mut ir = build_ir(args)

    const CPP_LINKED = false
    let mut f = ir.main.find_fn(ENTRY_POINT, CPP_LINKED)
    if f == nil {
        exit_err(logf(LogMsg.NoEntryPoint))
    }
    f.statically = true // Used

    f = ir.main.find_fn(INIT_FN, CPP_LINKED)
    if f != nil {
        f.statically = true // Used
    }

    apply_target_independent_optimizations(ir)

    // See compiler reference (1)
    ir.order()

    let (compiler, compiler_cmd) = gen_compile_cmd(get_compile_path(), ir)

    let mut obj = cxx::gen(ir)
    cxx::append_standard(obj, compiler, compiler_cmd)

    do_spell(obj, compiler, compiler_cmd)
}
