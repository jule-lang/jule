// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use comptime for std::comptime
use path for std::fs::path
use lex for std::jule::lex
use build for std::jule::build
use sema for std::jule::sema::{
	ImportInfo,
	Scope,
	Fn,
	Var,
	FnIns,
	StructIns,
	StructSubIdentExprModel,
	Data,
	AnonFnExprModel,
	TypeKind,
	BuiltinErrorCallExprModel,
}
use types for std::jule::types
use strings for std::strings

// Reports whether exceptional scope s forwards exceptional.
fn IsForwarded(&s: &Scope): bool {
	if len(s.Stmts) == 0 {
		ret false
	}
	last := s.Stmts[len(s.Stmts)-1]
	match type last {
	| &Data:
		match type (&Data)(last).Model {
		| &BuiltinErrorCallExprModel:
			ret true
		|:
			ret false
		}
	|:
		ret true
	}
}

// Reports whether expression comes from binded define.
fn IsExprComesFromBind(&d: &Data): bool {
	match type d.Model {
	| &Var:
		ret (&Var)(d.Model).Binded
	| &StructSubIdentExprModel:
		ret (&StructSubIdentExprModel)(d.Model).Owner.Decl.Binded
	|:
		ret false
	}
}

// Reports whether type is handled as <any> type.
fn IsAny(mut &t: &TypeKind): bool {
	if t.TypeEnum() != nil {
		ret true
	}
	prim := t.Prim()
	ret prim != nil && prim.IsAny()
}

// Reports whether anonymous function is closure.
fn IsClosure(&m: &AnonFnExprModel): bool { ret len(m.Captured) > 0 }

// Reports whether the m is operator overloading method.
fn IsOpMethod(&m: &Fn): bool {
	if len(m.Generics) > 0 || len(m.Instances) == 0 {
		ret false
	}
	mi := m.Instances[0]
	const tableT = comptime::TypeOf(mi.Owner.Operators).Decl()
	const tableV = comptime::ValueOf(mi.Owner.Operators)
	const for _, field in tableT.Fields() {
		if mi == tableV.Field(field.Name()).Unwrap() {
			ret true
		}
	}
	ret false
}

// Reports the f function of owner is implements a trait's method.
fn IsTraitMethod(mut &owner: &StructIns, &f: &FnIns): bool {
	for (_, mut t) in owner.Decl.Implements {
		if t.FindMethod(f.Decl.Ident) != nil {
			ret true
		}
	}
	ret false
}

// Reports whether f is standard library package p.
// Example use:
//  - IsStdPackage(f, "") for determine the whether f is standard library package
//  - IsStdPackage(f, "math") for std::math
//  - IsStdPackage(f, "math/big") for std::math::big
fn IsStdPackage(f: str, p: str): bool {
	// Do not handle '/' separators of p, because it
	// valid path separator for all supported platforms.
	ret strings::HasPrefix(f, path::Join(build::PathStdlib, p))
}

// Reports whether imp is implicitly imported.
// See developer reference (9).
fn IsImplicitImport(imp: &ImportInfo): bool {
	ret imp.Token == nil
}

// Returns element kind of t.
// Returns nil if type have not element type.
fn GetElemKind(mut &t: &sema::TypeKind): &sema::TypeKind {
	mut ptr := t.Ptr()
	if ptr != nil {
		if ptr.IsUnsafe() {
			ret nil
		}
		ret ptr.Elem
	}
	mut sptr := t.Sptr()
	if sptr != nil {
		ret sptr.Elem
	}
	mut arr := t.Arr()
	if arr != nil {
		ret arr.Elem
	}
	mut slice := t.Slc()
	if slice != nil {
		ret slice.Elem
	}
	mut prim := t.Prim()
	if prim != nil {
		if prim.IsStr() {
			ret &sema::TypeKind{
				Kind: &sema::Prim{
					Kind: types::TypeKind.U8,
				},
			}
		}
	}
	ret nil
}

// Similary to IsLvalueModel, but designed to determine whether expression is
// based on lvalue expression.
fn IsLvalueBasedModel(mut m: any): bool {
	match type m {
	| &sema::UnaryExprModel:
		mut uem := (&sema::UnaryExprModel)(m)
		if uem.Op.Id == lex::TokenId.Star {
			ret IsLvalueBasedModel(uem.Expr.Model)
		}
		ret false
	}
	ret IsLvalueModel(m) != nil
}

// Reports whether expression model is lvalue expression model.
// Designed to determine copy semantics required expression models.
// Returns expression type of expression model if valid, nil otherwise.
fn IsLvalueModel(mut m: any): &TypeKind {
	match type m {
	| &sema::Var:
		mut v := (&sema::Var)(m)
		if !v.Constant {
			ret v.Kind.Kind
		}
		ret nil
	| &sema::StructSubIdentExprModel:
		mut model := (&sema::StructSubIdentExprModel)(m)
		if model.Field != nil {
			ret model.Field.Kind
		}
		ret nil
	| &sema::UnaryExprModel:
		mut unary := (&sema::UnaryExprModel)(m)
		if unary.Op.Id == lex::TokenId.Star {
			ret GetElemKind(unary.Expr.Kind)
		}
		ret nil
	| &sema::IndexingExprModel:
		mut iem := (&sema::IndexingExprModel)(m)
		match {
		| iem.Expr.Kind.Ptr() != nil:
			ret iem.Expr.Kind.Ptr().Elem
		| iem.Expr.Kind.Arr() != nil:
			ret iem.Expr.Kind.Arr().Elem
		| iem.Expr.Kind.Slc() != nil:
			ret iem.Expr.Kind.Slc().Elem
		| iem.Expr.Kind.Map() != nil:
			ret iem.Expr.Kind.Map().Val
		| iem.Expr.Kind.Prim() != nil:
			prim := iem.Expr.Kind.Prim()
			match {
			| prim.IsStr():
				ret &sema::TypeKind{
					Kind: &sema::Prim{
						Kind: types::TypeKind.U8,
					},
				}
			}
			ret nil
		|:
			ret nil
		}
	|:
		ret nil
	}
}