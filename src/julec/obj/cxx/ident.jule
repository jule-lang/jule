// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use env
use std::unsafe
use conv for std::conv
use std::jule::build::{EntryPoint, Directive}
use std::jule::lex::{TokenKind, IsAnonIdent, IsIgnoreIdent}
use std::jule::sema::{
    Fn,
    FnIns,
    Trait,
    Struct,
    StructIns,
    Field,
    Var,
    Param,
}
use utf8 for std::unicode::utf8
use std::strings::{StrBuilder}

// Identifier of initialize function caller function.
const initCallerIdent = "__jule_call_initializers"

struct identCoder {}

impl identCoder {
    const Self = "_self_"

    // Write identifiers to buf. If identifier contains unicode runes,
    // handle as ASCII characters. Some backend compilers are not supports
    // unicode identifiers and causes compile errors.
    static fn writeIdentTo(mut &buf: StrBuilder, &ident: str) {
        for _, b in ident {
            if b >= utf8::RuneSelf {
                // ident contains unicode runes.
                goto unicode
            }
        }
        // ident is ASCII, append directly.
        buf.WriteStr(ident)
        ret
    unicode:
        for _, r in []rune(ident) {
            if r < utf8::RuneSelf { // ASCII
                // Cast to byte to enable compiler optimization.
                // Append directy to buf.
                buf.WriteByte(byte(r))
                continue
            }
            // Unicode, handle as ASCII.
            buf.WriteStr(conv::FmtInt(i64(r), 0xF))
        }
    }

    // Same as [toOut], but takes external buffer.
    static fn toOutBuf(mut &buf: StrBuilder, ident: str, addr: uintptr) {
        buf.WriteByte('_')
        if addr != 0 {
            buf.WriteStr(conv::FmtUint(u64(addr), 0xF))
            buf.WriteByte('_')
        }
        identCoder.writeIdentTo(buf, ident)
    }

    // Returns cpp output identifier form of given identifier.
    //
    // Parameters:
    //   - ident: Identifier.
    //   - addr:  Pointer address of package file handler.
    static fn toOut(ident: str, addr: uintptr): []byte {
        if addr != 0 {
            mut obj := StrBuilder.New(40)
            identCoder.toOutBuf(obj, ident, addr)
            ret unsafe { obj.Buf() }
        }
        mut obj := StrBuilder.New(len(ident) + 1)
        identCoder.toOutBuf(obj, ident, 0)
        ret unsafe { obj.Buf() }
    }

    // Returns cpp output local identifier form of fiven identifier.
    //
    // Parameters:
    //   - row:   Row of definition.
    //   - col:   Column of definition.
    //   - ident: Identifier of definition.
    static fn toLocal(row: int, col: int, &ident: str): []byte {
        mut obj := StrBuilder.New(40)
        obj.WriteByte('_')
        obj.WriteStr(conv::Itoa(row))
        obj.WriteStr(conv::Itoa(col))
        obj.WriteByte('_')
        identCoder.writeIdentTo(obj, ident)
        ret unsafe { obj.Buf() }
    }

    // Returns output identifier of function.
    static fn func(&f: &Fn): []byte {
        match {
        | f.Binded:
            ret unsafe::BytesFromStr(f.Ident)
        | f.Ident == EntryPoint:
            ret unsafe::BytesFromStr("entry_point")
        | f.IsMethod():
            if !f.Statically {
                ret identCoder.toOut(f.Ident, uintptr(f))
            }
            mut obj := StrBuilder.New(40 + len("static_"))
            obj.WriteStr("static_")
            identCoder.toOutBuf(obj, f.Ident, uintptr(f))
            ret unsafe { obj.Buf() }
        |:
            ret identCoder.toOut(f.Ident, uintptr(f))
        }
    }

    // Returns output identifier of function instance.
    static fn funcIns(&f: &FnIns): []byte {
        if f.IsBuiltin() {
            // Do not use [identCoder.writeIdentTo] for this.
            // Built-in functions are always ASCII.
            ret unsafe::BytesFromStr("jule::" + f.Decl.Ident)
        }
        if f.Decl.Binded || len(f.Generics) == 0 {
            ret identCoder.func(f.Decl)
        }
        ret identCoder.toOut(f.Decl.Ident, uintptr(f))
    }

    // Returns output identifier of trait.
    static fn traitDecl(t: &Trait): []byte {
        ret identCoder.toOut(t.Ident, uintptr(t))
    }

    // Returns output identifier of parameter.
    static fn param(&p: &Param): []byte {
        if IsAnonIdent(p.Ident) || IsIgnoreIdent(p.Ident) {
            ret nil
        }
        if p.IsSelf() {
            ret unsafe::BytesFromStr(identCoder.Self)
        }
        if p.Token == nil {
            ret identCoder.toLocal(0, 0, p.Ident)
        }
        ret identCoder.toLocal(p.Token.Row, p.Token.Column, p.Ident)
    }

    // Returns output identifier of structure.
    static fn structure(&s: &Struct): []byte {
        if s.Binded {
            if hasDirective(s.Directives, Directive.Typedef) {
                ret unsafe::BytesFromStr(s.Ident)
            }
            ret unsafe::BytesFromStr("struct " + s.Ident)
        }
        ret identCoder.toOut(s.Ident, uintptr(s))
    }

    // Returns output identifier of structure instance.
    static fn structureIns(&s: &StructIns): []byte {
        if s.Decl.Binded || len(s.Generics) == 0 {
            ret identCoder.structure(s.Decl)
        }
        ret identCoder.toOut(s.Decl.Ident, uintptr(s))
    }

    // Returns output identifier of field.
    static fn field(&f: &Field): []byte {
        if f.Owner.Binded {
            ret unsafe::BytesFromStr(f.Ident)
        }
        mut obj := StrBuilder.New(7 + len(f.Ident))
        obj.WriteStr("_field_")
        identCoder.writeIdentTo(obj, f.Ident)
        ret unsafe { obj.Buf() }
    }

    // Returns output identifier of variable.
    static fn var(mut v: &Var): []byte {
        match {
        | v.Binded:
            ret unsafe::BytesFromStr(v.Ident)
        | v.Ident == TokenKind.Error:
            ret unsafe::BytesFromStr("except.error")
        | v.Ident == TokenKind.Self:
            ret unsafe::BytesFromStr(identCoder.Self)
        | v.RetOrder == -1:
            // The single return variable is just this one.
            // Return directly [resultName] because of generated with this identifier.
            ret unsafe::BytesFromStr(resultName)
        | v.RetOrder >= 0:
            ret unsafe::BytesFromStr(resultName + "." + resultArgName + conv::Itoa(v.RetOrder))
        | v.Scope != nil:
            ret identCoder.toLocal(v.Token.Row, v.Token.Column, v.Ident)
        |:
            ret identCoder.toOut(v.Ident, uintptr(v))
        }
    }

    // Returns begin label identifier of iteration.
    static fn iterBegin(it: uintptr): []byte {
        mut obj := StrBuilder.New(30)
        obj.WriteStr("_iter_begin_")
        obj.WriteStr(conv::FmtUint(u64(it), 0xF))
        ret unsafe { obj.Buf() }
    }

    // Returns end label identifier of iteration.
    static fn iterEnd(it: uintptr): []byte {
        mut obj := StrBuilder.New(30)
        obj.WriteStr("_iter_end_")
        obj.WriteStr(conv::FmtUint(u64(it), 0xF))
        ret unsafe { obj.Buf() }
    }

    // Returns next label identifier of iteration.
    static fn iterNext(it: uintptr): []byte {
        mut obj := StrBuilder.New(30)
        obj.WriteStr("_iter_next_")
        obj.WriteStr(conv::FmtUint(u64(it), 0xF))
        ret unsafe { obj.Buf() }
    }

    // Returns label identifier.
    static fn label(u: uintptr): []byte {
        mut obj := StrBuilder.New(30)
        obj.WriteStr("_julec_label_")
        obj.WriteStr(conv::FmtUint(u64(u), 0xF))
        ret unsafe { obj.Buf() }
    }

    // Returns end label identifier of match-case.
    static fn matchEnd(m: uintptr): []byte {
        mut obj := StrBuilder.New(30)
        obj.WriteStr("_match_end_")
        obj.WriteStr(conv::FmtUint(u64(m), 0xF))
        ret unsafe { obj.Buf() }
    }

    // Returns begin label identifier of case.
    static fn caseBegin(c: uintptr): []byte {
        mut obj := StrBuilder.New(30)
        obj.WriteStr("_case_begin_")
        obj.WriteStr(conv::FmtUint(u64(c), 0xF))
        ret unsafe { obj.Buf() }
    }
}