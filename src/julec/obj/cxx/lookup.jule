// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use obj::{IR}
use std::jule::sema::{Package, SymbolTable, Trait, Fn, StructIns, TypeKind}

fn iterPackages(mut &ir: &IR, f: fn(mut &pkg: &Package)) {
    for (_, mut used) in ir.Used {
        if !used.Binded {
            f(used.Package)
        }
    }
    f(ir.Main)
}

fn iterFiles(mut &pkg: &Package, f: fn(mut &f: &SymbolTable)) {
    for (_, mut file) in pkg.Files {
        f(file)
    }
}

// Reports whether trait have method in this identifier.
fn containsTraitMethod(mut &t: &Trait, &ident: str): bool {
    for _, m in t.Methods {
        if m.Ident == ident {
            ret true
        }
    }
    ret false
}

fn iterTraitInheritMethods(mut &base: &Trait, mut &t: &Trait, f: fn(mut &t: &Trait, mut &m: &Fn)) {
    iterTraitInheritMethods1(base, t, f)
    for (_, mut m) in t.Methods {
        if !containsTraitMethod(base, m.Ident) { // Do not iterate iterated method.
            f(base, m)
        }
    }
}

fn iterTraitInheritMethods1(mut &base: &Trait, mut &t: &Trait, f: fn(mut &t: &Trait, mut &m: &Fn)) {
    for (_, mut inh) in t.Inherits {
        mut t2 := inh.Kind.Trait()
        iterTraitInheritMethods(base, t2, f)
    }
}

// Iterates methods of trait, including inherited methods.
fn iterTraitMethods(mut &t: &Trait, f: fn(mut &t: &Trait, mut &m: &Fn)) {
    for (_, mut m) in t.Methods {
        f(t, m)
    }
    iterTraitInheritMethods1(t, t, f)
}

// Reports whether trait implements at least one method.
fn isTraitHaveMethods(mut &t: &Trait): bool {
    if len(t.Methods) > 0 {
        ret true
    }
    for (_, mut inh) in t.Inherits {
        mut t2 := inh.Kind.Trait()
        if isTraitHaveMethods(t2) {
            ret true
        }
    }
    ret false
}

// Returns index of structu ins by trait implements.
fn findTraitTypeOffsetS(t: &Trait, mut s: &StructIns): int {
    if len(t.Implemented) == 0 {
        ret emptyTraitOffset
    }
    mut i := 0
    for _, si in t.Implemented {
        if s.Decl == si {
            for _, ins in si.Instances {
                if ins == s {
                    ret i
                }
                i++
            }
            break
        } else {
            i += len(si.Instances)
        }
    }
    ret -1
}

// Same as [findTraitTypeOffsetS] but designed for TypeKind based lookup.
// It checks structure instances even used with smart pointer.
fn findTraitTypeOffset(t: &Trait, mut k: &TypeKind): int {
    if len(t.Implemented) == 0 {
        ret emptyTraitOffset
    }
    let mut s: &StructIns = nil
    if k.Sptr() != nil {
        k = k.Sptr().Elem
    }
    s = k.Struct()
    if s == nil {
        ret -1
    }
    ret findTraitTypeOffsetS(t, s)
}