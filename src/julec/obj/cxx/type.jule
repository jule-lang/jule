// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use ast for std::jule::ast
use conv for std::conv
use std::jule::build::{Directive}
use std::jule::sema::{
    Prim,
    Tuple,
    Sptr,
    Ptr,
    Slc,
    Enum,
    TypeEnum,
    TypeKind,
    Map,
    Trait,
    Struct,
    StructIns,
    FnIns,
    Arr,
    ParamIns,
    Fn,
    Param,
    Kind,
}
use types for std::jule::types

struct customType {
    kind: str
}

impl Kind for customType {
    fn Str(self): str {
        ret self.kind
    }

    fn Equals(&self, k: &TypeKind): bool {
        ret false
    }
}

struct typeCoder {}

impl typeCoder {
    const Any = "jule::Any"
    const Str = "jule::Str"
    const Map = "jule::Map"
    const Ptr = "jule::Ptr"
    const Sptr = "jule::Sptr"
    const Slice = "jule::Slice"
    const Trait = "jule::Trait"
    const Array = "jule::Array"
    const Fn = "jule::Fn"
    const Bool = "jule::Bool"
    const Uintptr = "jule::Uintptr"

    // Returns given identifier as Jule type identifier.
    static fn toType(mut id: str): str {
        if id != types::TypeKind.Uintptr {
            id = types::RealKindOf(id)
        }
        if 97 <= id[0] && id[0] <= 122 {
            id[0] -= 32 // To upper first byte.
        }
        ret "jule::" + id
    }

    // Generates C++ code of Prim TypeKind.
    static fn prim(p: &Prim): str {
        ret typeCoder.toType(p.Str())
    }

    // Generates C++ code of Tupe TypeKind.
    static fn tuple(mut t: &Tuple): str {
        let mut obj = "std::tuple<"
        for (_, mut tk) in t.Types {
            obj += typeCoder.kind(tk)
            obj += ","
        }
        obj = obj[:len(obj)-1] // Remove comma
        obj += ">"
        ret obj
    }

    // Returns C++ code of smart pointer type with element type.
    static fn asSptr(elem: str): str {
        let mut obj = typeCoder.Ptr + "<"
        obj += elem
        obj += ">"
        ret obj
    }

    // Returns C++ code of pointer type with element type.
    static fn asPtr(elem: str): str {
        ret elem + "*"
    }

    // Generates C++ code of smart pointer TypeKind.
    static fn sptr(mut sptr: &Sptr): str {
        ret typeCoder.asSptr(typeCoder.kind(sptr.Elem))
    }

    // Generates C++ code of Ptr TypeKind.
    static fn ptr(mut p: &Ptr): str {
        const CppPointerMask = "*"
        if p.IsUnsafe() {
            ret "void" + CppPointerMask
        }
        let mut elem = typeCoder.kind(p.Elem)
        elem += CppPointerMask
        ret elem
    }

    // Generates C++ code of Enum TypeKind.
    static fn enumDecl(mut e: &Enum): str {
        ret typeCoder.kind(e.Kind.Kind)
    }

    // Generates C++ code of TypeEnum TypeKind.
    static fn typeEnumDecl(mut e: &TypeEnum): str {
        ret typeCoder.Any
    }

    static fn asSlice(mut elem: &TypeKind): str {
        let mut obj = typeCoder.Slice + "<"
        obj += typeCoder.kind(elem)
        obj += ">"
        ret obj
    }

    // Generates C++ code of Slc TypeKind.
    static fn slice(mut s: &Slc): str {
        ret typeCoder.asSlice(s.Elem)
    }

    // Generates C++ code of Map TypeKind.
    static fn mapType(mut m: &Map): str {
        let mut obj = typeCoder.Map + "<"
        obj += typeCoder.kind(m.Key)
        obj += ","
        obj += typeCoder.kind(m.Val)
        obj += ">"
        ret obj
    }

    static fn traitIdent(ident: str): str {
        let mut obj = typeCoder.Trait + "<"
        obj += ident
        obj += ">"
        ret obj
    }

    // Generates C++ code of Trait TypeKind.
    static fn traitDecl(t: &Trait): str {
        ret typeCoder.traitIdent(identCoder.traitDecl(t))
    }

    // Generates C++ code of Struct TypeKind.
    static fn structure(s: &Struct): str {
        let mut rep = ""
        if s.CppLinked && !hasDirective(s.Directives, Directive.Typedef) {
            rep += "struct "
        }
        rep += identCoder.structure(s)
        ret rep
    }

    // Generates C++ code of Struct instance TypeKind.
    static fn structureIns(mut s: &StructIns): str {
        if s.Decl.CppLinked {
            let mut ident = identCoder.structureIns(s)
            if len(s.Generics) > 0 {
                ident += "<"
                for (_, mut g) in s.Generics {
                    ident += typeCoder.kind(g.Kind)
                    ident += ","
                }
                ident = ident[:len(ident)-1] // Remove last comma.
                ident += ">"
            }
            let d = findDirective(s.Decl.Directives, Directive.Namespace)
            if d != nil {
                ident = concatAllParts(d.Args...) + "::" + ident
            }
            ret ident
        }
        ret identCoder.structureIns(s)
    }

    // Generates C++ code of Arr TypeKind.
    static fn array(mut a: &Arr): str {
        let mut obj = typeCoder.Array + "<"
        obj += typeCoder.kind(a.Elem)
        obj += ","
        obj += conv::Itoa(a.N)
        obj += ">"
        ret obj
    }

    // Generates C++ prototype code of parameter.
    static fn param(mut &p: &Param): str {
        let mut obj = ""
        if p.Variadic {
            obj += typeCoder.Slice + "<"
            obj += typeCoder.kind(p.Kind.Kind)
            obj += ">"
        } else {
            obj += typeCoder.kind(p.Kind.Kind)
        }
        if p.Reference {
            obj += "&"
        }
        ret obj
    }

    // Generates C++ prototype code of parameter instance.
    static fn paramIns(mut &p: &ParamIns): str {
        let mut obj = ""
        if p.Decl.Variadic {
            obj += typeCoder.Slice + "<"
            obj += typeCoder.kind(p.Kind)
            obj += ">"
        } else {
            obj += typeCoder.kind(p.Kind)
        }
        if p.Decl.Reference {
            obj += "&"
        }
        ret obj
    }

    // Generates C++ code of function's result type.
    static fn funcResult(mut &f: &Fn): str {
        if f.IsVoid() {
            if f.Exceptional {
                ret "jule::VoidExceptional"
            }
            ret "void"
        }
        if f.Exceptional {
            ret "jule::Exceptional<" + typeCoder.kind(f.Result.Kind.Kind) + ">"
        }
        ret typeCoder.kind(f.Result.Kind.Kind)
    }

    // Generates C++ code of function instance's result type.
    static fn funcInsResult(mut &f: &FnIns): str {
        if f.Decl.IsVoid() {
            if f.Decl.Exceptional {
                ret "jule::VoidExceptional"
            }
            ret "void"
        }
        if f.Decl.Exceptional {
            ret "jule::Exceptional<" + typeCoder.kind(f.Result) + ">"
        }
        ret typeCoder.kind(f.Result)
    }

    static fn anonFunc(mut f: &FnIns): str {
        let mut decl = typeCoder.funcInsResult(f)
        decl += "("
        if len(f.Params) > 0 {
            for (_, mut param) in f.Params {
                if param.Decl.IsSelf() {
                    continue
                }
                decl += typeCoder.paramIns(param)
                decl += ","
            }
            decl = decl[:len(decl)-1] // Remove last comma.
        } else {
            decl += "void"
        }
        decl += ")"
        ret decl
    }

    // Generates C++ code of Fn TypeKind.
    static fn func(mut f: &FnIns): str {
        let mut obj = typeCoder.Fn + "<"
        obj += typeCoder.anonFunc(f)
        obj += ">"
        ret obj
    }

    // Generates C++ code of TypeKind.
    static fn kind(mut k: &TypeKind): str {
        match {
        | k.CppLinked():
            ret k.CppIdent
        | k.Prim() != nil:
            ret typeCoder.prim(k.Prim())
        | k.Tup() != nil:
            ret typeCoder.tuple(k.Tup())
        | k.Sptr() != nil:
            ret typeCoder.sptr(k.Sptr())
        | k.Ptr() != nil:
            ret typeCoder.ptr(k.Ptr())
        | k.Enum() != nil:
            ret typeCoder.enumDecl(k.Enum())
        | k.TypeEnum() != nil:
            ret typeCoder.typeEnumDecl(k.TypeEnum())
        | k.Slc() != nil:
            ret typeCoder.slice(k.Slc())
        | k.Map() != nil:
            ret typeCoder.mapType(k.Map())
        | k.Trait() != nil:
            ret typeCoder.traitDecl(k.Trait())
        | k.Struct() != nil:
            ret typeCoder.structureIns(k.Struct())
        | k.Arr() != nil:
            ret typeCoder.array(k.Arr())
        | k.Fn() != nil:
            ret typeCoder.func(k.Fn())
        }
        match type k.Kind {
        | &customType:
            ret (&customType)(k.Kind).kind
        |:
            ret "[<unimplemented_type_kind>]"
        }
    }
}

// Returns directive if exist.
fn findDirective(mut &directives: []&ast::Directive, tag: str): &ast::Directive {
    for (_, mut dr) in directives {
        if dr.Tag.Kind == tag {
            ret dr
        }
    }
    ret nil
}

// Reports whether directive is exist.
fn hasDirective(&directives: []&ast::Directive, tag: str): bool {
    ret findDirective(unsafe { *(&directives) }, tag) != nil
}

// Reports whether type should initialized.
// If the type API implemented structure of something like that, initialization is redundant.
// Let the constructor do it's job.
fn shouldInitialized(mut &t: &TypeKind): bool {
    let prim = t.Prim()
    if prim != nil {
        ret !prim.IsAny() && !prim.IsStr()
    }
    match {
    | t.Sptr() != nil:
        ret false
    | t.Map() != nil:
        ret false
    | t.Slc() != nil:
        ret false
    | t.Trait() != nil:
        ret false
    | t.Fn() != nil:
        ret false
    | t.Arr() != nil:
        let mut arr = t.Arr()
        ret shouldInitialized(arr.Elem)
    | t.Struct() != nil:
        ret false
    |:
        ret true
    }
}