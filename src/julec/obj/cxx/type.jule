// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use ast for std::jule::ast
use conv for std::conv
use std::jule::build::{Directive}
use std::jule::sema::{
    Prim,
    Tuple,
    Sptr,
    Ptr,
    Slc,
    Enum,
    TypeEnum,
    TypeKind,
    Map,
    Trait,
    Struct,
    StructIns,
    FnIns,
    Arr,
    ParamIns,
    Fn,
    Param,
    Kind,
}
use types for std::jule::types
use std::strings::{StrBuilder}

struct customType {
    kind: str
}

impl Kind for customType {
    fn Str(self): str {
        ret self.kind
    }

    fn Equal(&self, k: &TypeKind): bool {
        ret false
    }
}

struct typeCoder {
    oc: &ObjectCoder
    rc: &resultCoder
}

impl typeCoder {
    const Any = "jule::Any"
    const Str = "jule::Str"
    const Map = "jule::Map"
    const Ptr = "jule::Ptr"
    const Sptr = "jule::Sptr"
    const Slice = "jule::Slice"
    const Trait = "jule::Trait"
    const Array = "jule::Array"
    const Fn = "jule::Fn"
    const Bool = "jule::Bool"
    const Int = "jule::Int"
    const Uintptr = "jule::Uintptr"

    static fn new(mut &oc: &ObjectCoder): &typeCoder {
        let mut tc = &typeCoder{oc: oc}
        tc.rc = resultCoder.new(tc)
        ret tc
    }

    // Returns given identifier as Jule type identifier.
    fn toType(mut self, mut id: str): str {
        if id != types::TypeKind.Uintptr {
            id = types::RealKindOf(id)
        }
        let mut obj = StrBuilder.New(1 << 5)
        obj.WriteStr("jule::")
        if 97 <= id[0] && id[0] <= 122 {
            obj.WriteByte(id[0] - 32) // To upper first byte.
        } else {
            obj.WriteByte(id[0])
        }
        obj.WriteStr(id[1:])
        ret obj.Str()
    }

    // Generates C++ code of Prim TypeKind.
    fn prim(mut self, p: &Prim): str {
        ret self.toType(p.Str())
    }

    // Generates C++ code of Tupe TypeKind.
    fn tuple(mut self, mut t: &Tuple): str {
        let mut obj = StrBuilder.New(1 << 5)
        obj.WriteStr("std::tuple<")
        for (i, mut tk) in t.Types {
            obj.WriteStr(self.kind(tk))
            if len(t.Types)-i > 1 {
                obj.WriteByte(',')
            }
        }
        obj.WriteByte('>')
        ret obj.Str()
    }

    // Returns C++ code of smart pointer type with element type.
    fn asSptr(mut self, elem: str): str {
        let mut obj = StrBuilder.New(len(typeCoder.Ptr + "<>") + len(elem))
        obj.WriteStr(typeCoder.Ptr + "<")
        obj.WriteStr(elem)
        obj.WriteByte('>')
        ret obj.Str()
    }

    // Generates C++ code of smart pointer TypeKind.
    fn sptr(mut self, mut sptr: &Sptr): str {
        ret self.asSptr(self.kind(sptr.Elem))
    }

    // Generates C++ code of Ptr TypeKind.
    fn ptr(mut self, mut p: &Ptr): str {
        const CppPointerMask = "*"
        if p.IsUnsafe() {
            ret "void" + CppPointerMask
        }
        ret self.kind(p.Elem) + CppPointerMask
    }

    // Generates C++ code of Enum TypeKind.
    fn enumDecl(mut self, mut e: &Enum): str {
        ret self.kind(e.Kind.Kind)
    }

    // Generates C++ code of TypeEnum TypeKind.
    fn typeEnumDecl(mut self, mut e: &TypeEnum): str {
        ret typeCoder.Any
    }

    fn asSlice(mut self, mut elem: &TypeKind): str {
        let mut obj = StrBuilder.New(len(typeCoder.Slice + "<>") + (1 << 5))
        obj.WriteStr(typeCoder.Slice + "<")
        obj.WriteStr(self.kind(elem))
        obj.WriteByte('>')
        ret obj.Str()
    }

    // Generates C++ code of Slc TypeKind.
    fn slice(mut self, mut s: &Slc): str {
        ret self.asSlice(s.Elem)
    }

    // Generates C++ code of Map TypeKind.
    fn mapType(mut self, mut m: &Map): str {
        let mut obj = StrBuilder.New(len(typeCoder.Map + "<>") + (1 << 5))
        obj.WriteStr(typeCoder.Map + "<")
        obj.WriteStr(self.kind(m.Key))
        obj.WriteByte(',')
        obj.WriteStr(self.kind(m.Val))
        obj.WriteByte('>')
        ret obj.Str()
    }

    fn traitIdent(mut self, ident: str): str {
        let mut obj = StrBuilder.New(len(typeCoder.Trait + "<>") + len(ident))
        obj.WriteStr(typeCoder.Trait + "<")
        obj.WriteStr(ident)
        obj.WriteByte('>')
        ret obj.Str()
    }

    // Generates C++ code of Trait TypeKind.
    fn traitDecl(mut self, t: &Trait): str {
        ret self.traitIdent(identCoder.traitDecl(t))
    }

    // Generates C++ code of Struct TypeKind.
    fn structure(mut self, s: &Struct): str {
        let mut rep = StrBuilder.New(1 << 5)
        if s.Binded && !hasDirective(s.Directives, Directive.Typedef) {
            rep.WriteStr("struct ")
        }
        rep.WriteStr(identCoder.structure(s))
        ret rep.Str()
    }

    // Generates C++ code of Struct instance TypeKind.
    fn structureIns(mut self, mut s: &StructIns): str {
        if s.Decl.Binded {
            let mut ident = StrBuilder.New(1 << 5)
            ident.WriteStr(identCoder.structureIns(s))
            if len(s.Generics) > 0 {
                ident.WriteByte('<')
                for (i, mut g) in s.Generics {
                    ident.WriteStr(self.kind(g.Kind))
                    if len(s.Generics)-i > 1 {
                        ident.WriteByte(',')
                    }
                }
                ident.WriteByte('>')
            }
            let d = findDirective(s.Decl.Directives, Directive.Namespace)
            if d != nil {
                let mut buf = ident.Str()
                ident.Clear()
                ident.WriteStr(concatAllParts(d.Args...))
                ident.WriteStr("::")
                ident.WriteStr(buf)
            }
            ret ident.Str()
        }
        ret identCoder.structureIns(s)
    }

    // Generates C++ code of Arr TypeKind.
    fn array(mut self, mut a: &Arr): str {
        let mut obj = StrBuilder.New(len(typeCoder.Array + "<>") + (1 << 5))
        obj.WriteStr(typeCoder.Array + "<")
        obj.WriteStr(self.kind(a.Elem))
        obj.WriteByte(',')
        obj.WriteStr(conv::Itoa(a.N))
        obj.WriteByte('>')
        ret obj.Str()
    }

    // Generates C++ prototype code of parameter.
    fn param(mut self, mut &p: &Param): str {
        let mut obj = StrBuilder.New(1 << 5)
        if p.Variadic {
            obj.WriteStr(typeCoder.Slice + "<")
            obj.WriteStr(self.kind(p.Kind.Kind))
            obj.WriteByte('>')
        } else {
            obj.WriteStr(self.kind(p.Kind.Kind))
        }
        if p.Reference {
            obj.WriteByte('*')
        }
        ret obj.Str()
    }

    // Generates C++ prototype code of parameter instance.
    fn paramIns(mut self, mut &p: &ParamIns): str {
        let mut obj = StrBuilder.New(1 << 5)
        if p.Decl.Variadic {
            obj.WriteStr(typeCoder.Slice + "<")
            obj.WriteStr(self.kind(p.Kind))
            obj.WriteByte('>')
        } else {
            obj.WriteStr(self.kind(p.Kind))
        }
        if p.Decl.Reference {
            obj.WriteByte('*')
        }
        ret obj.Str()
    }

    // Generates C++ code of function's result type.
    fn funcResult(mut self, mut &f: &Fn): str {
        if f.IsVoid() {
            if f.Exceptional {
                ret "jule::VoidExceptional"
            }
            ret "void"
        }
        if f.Exceptional {
            ret "jule::Exceptional<" + self.kind(f.Result.Kind.Kind) + ">"
        }
        ret self.kind(f.Result.Kind.Kind)
    }

    // Generates C++ code of function instance's result type.
    fn funcInsResult(mut self, mut &s: []byte, mut &f: &FnIns) {
        if f.Decl.IsVoid() {
            if f.Decl.Exceptional {
                s = append(s, []byte("jule::VoidExceptional")...)
            } else {
                s = append(s, []byte("void")...)
            }
            ret
        }
        if f.Decl.Exceptional {
            s = append(s, []byte("jule::Exceptional<")...)
            self.rc.codeMut1(s, f.Result)
            s = append(s, '>')
            ret
        }
        self.rc.codeMut1(s, f.Result)
    }

    fn anonFunc(mut self, mut f: &FnIns): str {
        if f.Result != nil && f.Result.Tup() != nil {
            self.oc.pushResultIns(f)
        }
        let mut decl = make([]byte, 0, 20)
        self.funcInsResult(decl, f)
        decl = append(decl, '(')
        if len(f.Params) > 0 {
            for (_, mut param) in f.Params {
                if param.Decl.IsSelf() {
                    continue
                }
                decl = append(decl, []byte(self.paramIns(param))...)
                decl = append(decl, ',')
            }
            decl = decl[:len(decl)-1] // Remove last comma.
        } else {
            decl = append(decl, []byte("void")...)
        }
        decl = append(decl, ')')
        ret str(decl)
    }

    // Generates C++ code of Fn TypeKind.
    fn func(mut self, mut f: &FnIns): str {
        let mut obj = StrBuilder.New(len(typeCoder.Fn + "<>") + (1 << 5))
        obj.WriteStr(typeCoder.Fn + "<")
        obj.WriteStr(self.anonFunc(f))
        obj.WriteByte('>')
        ret obj.Str()
    }

    // Generates C++ code of TypeKind.
    fn kind(mut self, mut k: &TypeKind): str {
        match {
        | k.Struct() != nil:
            ret self.structureIns(k.Struct())
        | k.Binded():
            // As we can see here, bind defines use pure identifiers directly.
            // So, if you hesitate about a type that causes wrong code generation,
            // write relevant algorithms above this case.
            ret k.BindIdent
        | k.Prim() != nil:
            ret self.prim(k.Prim())
        | k.Tup() != nil:
            ret self.tuple(k.Tup())
        | k.Sptr() != nil:
            ret self.sptr(k.Sptr())
        | k.Ptr() != nil:
            ret self.ptr(k.Ptr())
        | k.Enum() != nil:
            ret self.enumDecl(k.Enum())
        | k.TypeEnum() != nil:
            ret self.typeEnumDecl(k.TypeEnum())
        | k.Slc() != nil:
            ret self.slice(k.Slc())
        | k.Map() != nil:
            ret self.mapType(k.Map())
        | k.Trait() != nil:
            ret self.traitDecl(k.Trait())
        | k.Arr() != nil:
            ret self.array(k.Arr())
        | k.Fn() != nil:
            ret self.func(k.Fn())
        }
        match type k.Kind {
        | &customType:
            ret (&customType)(k.Kind).kind
        |:
            ret "[<unimplemented_type_kind>]"
        }
    }
}

struct resultCoder {
    tc: &typeCoder
}

impl resultCoder {
    const Map = "m"
    const Slice = "s"
    const Ptr = "p"
    const Sptr = "x"
    const Array = "a"
    const Reference = "r"
    const Fn = "f"

    static fn new(mut &tc: &typeCoder): &resultCoder {
        ret &resultCoder{tc: tc}
    }

    fn ptr(mut self, mut &s: []byte, mut p: &Ptr) {
        s = append(s, []byte(resultCoder.Ptr)...)
        self.codeMut(s, p.Elem)
    }

    fn sptr(mut self, mut &s: []byte, mut p: &Sptr) {
        s = append(s, []byte(resultCoder.Sptr)...)
        self.codeMut(s, p.Elem)
    }

    fn mapType(mut self, mut &s: []byte, mut p: &Map) {
        s = append(s, []byte(resultCoder.Map)...)
        self.codeMut(s, p.Key)
        self.codeMut(s, p.Val)
    }

    fn slice(mut self, mut &s: []byte, mut slc: &Slc) {
        s = append(s, []byte(resultCoder.Slice)...)
        self.codeMut(s, slc.Elem)
    }

    fn arr(mut self, mut &s: []byte, mut arr: &Arr) {
        s = append(s, []byte(resultCoder.Array)...)
        s = append(s, []byte(conv::FmtInt(i64(arr.N), 16))...)
        self.codeMut(s, arr.Elem)
    }

    fn func(mut self, mut &s: []byte, mut f: &FnIns) {
        s = append(s, []byte(resultCoder.Fn)...)
        for (_, mut p) in f.Params {
            if p.Decl.Reference {
                s = append(s, []byte(resultCoder.Reference)...)
            }
            self.codeMut(s, p.Kind)
        }
        if f.Result != nil {
            self.codeMut(s, f.Result)
        }
    }

    fn tup(mut self, mut &s: []byte, mut tup: &Tuple) {
        for (_, mut t) in tup.Types {
            s = append(s, []byte("__jule_tuple_")...)
            self.codeMut(s, t)
        }
    }

    fn codeMut(mut self, mut &s: []byte, mut &t: &TypeKind) {
        match type t.Kind {
        | &Ptr:
            self.ptr(s, (&Ptr)(t.Kind))
        | &Sptr:
            self.sptr(s, (&Sptr)(t.Kind))
        | &Map:
            self.mapType(s, (&Map)(t.Kind))
        | &Slc:
            self.slice(s, (&Slc)(t.Kind))
        | &Arr:
            self.arr(s, (&Arr)(t.Kind))
        | &FnIns:
            self.func(s, (&FnIns)(t.Kind))
        | &Enum:
            let te = (&Enum)(t.Kind)
            s = append(s, []byte(identCoder.toOut(te.Ident, uintptr(te)))...)
        | &TypeEnum:
            let te = (&TypeEnum)(t.Kind)
            s = append(s, []byte(identCoder.toOut(te.Ident, uintptr(te)))...)
        | &StructIns:
            let mut si = (&StructIns)(t.Kind)
            s = append(s, []byte(identCoder.structureIns(si))...)
        | &Trait:
            let mut trt = (&Trait)(t.Kind)
            s = append(s, []byte(identCoder.traitDecl(trt))...)
        | &Prim:
            s = append(s, []byte((&Prim)(t.Kind).Kind)...)
        | &Tuple:
            self.tup(s, (&Tuple)(t.Kind))
        |:
            panic("this panic call should be unreachable")
        }
    }

    fn codeMut1(mut self, mut &s: []byte, mut &t: &TypeKind) {
        let mut tup = t.Tup()
        if tup != nil {
            self.tup(s, tup)
        } else {
            s = append(s, []byte(self.tc.kind(t))...)
        }
    }

    fn code(mut self, mut &t: &TypeKind): str {
        let mut s = make([]byte, 0, 20)
        self.codeMut(s, t)
        ret str(s)
    }
}

// Returns directive if exist.
fn findDirective(mut &directives: []&ast::Directive, tag: str): &ast::Directive {
    for (_, mut dr) in directives {
        if dr.Tag.Kind == tag {
            ret dr
        }
    }
    ret nil
}

// Reports whether directive is exist.
fn hasDirective(&directives: []&ast::Directive, tag: str): bool {
    ret findDirective(unsafe { *(&directives) }, tag) != nil
}

// Reports whether type should initialized.
// If the type API implemented structure of something like that, initialization is redundant.
// Let the constructor do it's job.
fn shouldInitialized(mut &t: &TypeKind): bool {
    let prim = t.Prim()
    if prim != nil {
        ret !prim.IsAny() && !prim.IsStr()
    }
    match {
    | t.Sptr() != nil:
        ret false
    | t.Map() != nil:
        ret false
    | t.Slc() != nil:
        ret false
    | t.Trait() != nil:
        ret false
    | t.Fn() != nil:
        ret false
    | t.Arr() != nil:
        let mut arr = t.Arr()
        ret shouldInitialized(arr.Elem)
    | t.Struct() != nil:
        ret false
    |:
        ret true
    }
}