// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::unsafe
use ast for std::jule::ast
use conv for std::conv
use std::jule::build::{Directive}
use std::jule::sema::{
    Prim,
    Tuple,
    Sptr,
    Ptr,
    Slc,
    Enum,
    TypeEnum,
    TypeKind,
    Map,
    Trait,
    Struct,
    StructIns,
    FnIns,
    Arr,
    ParamIns,
    Fn,
    Param,
    Kind,
}
use types for std::jule::types
use std::strings::{StrBuilder}

struct customType {
    kind: str
}

impl Kind for customType {
    fn Str(self): str {
        ret self.kind
    }

    fn Equal(&self, k: &TypeKind): bool {
        ret false
    }
}

struct typeCoder {
    oc: &ObjectCoder
    rc: &resultCoder
}

impl typeCoder {
    const Any = "jule::Any"
    const Str = "jule::Str"
    const Map = "jule::Map"
    const Ptr = "jule::Ptr"
    const Sptr = "jule::Sptr"
    const Slice = "jule::Slice"
    const Trait = "jule::Trait"
    const Array = "jule::Array"
    const Fn = "jule::Fn"
    const Bool = "jule::Bool"
    const Int = "jule::Int"
    const Uintptr = "jule::Uintptr"

    static fn new(mut &oc: &ObjectCoder): &typeCoder {
        mut tc := &typeCoder{oc: oc}
        tc.rc = resultCoder.new(tc)
        ret tc
    }

    // Returns given identifier as Jule type identifier.
    fn toType(mut self, mut id: str): []byte {
        if id != types::TypeKind.Uintptr {
            id = types::RealKindOf(id)
        }
        mut obj := StrBuilder.New(1 << 5)
        obj.WriteStr("jule::")
        if 97 <= id[0] && id[0] <= 122 {
            obj.WriteByte(id[0] - 32) // To upper first byte.
        } else {
            obj.WriteByte(id[0])
        }
        obj.WriteStr(id[1:])
        ret unsafe { obj.Buf() }
    }

    // Generates C++ code of Prim TypeKind.
    fn prim(mut self, p: &Prim): []byte {
        ret self.toType(p.Kind)
    }

    // Generates C++ code of Tupe TypeKind.
    fn tuple(mut self, mut t: &Tuple): []byte {
        mut obj := StrBuilder.New(1 << 5)
        obj.WriteStr("std::tuple<")
        for (i, mut tk) in t.Types {
            obj.Write(self.kind(tk))
            if len(t.Types)-i > 1 {
                obj.WriteByte(',')
            }
        }
        obj.WriteByte('>')
        ret unsafe { obj.Buf() }
    }

    // Returns C++ code of smart pointer type with element type.
    fn asSptr(mut self, elem: []byte): []byte {
        mut obj := StrBuilder.New(len(typeCoder.Ptr + "<>") + len(elem))
        obj.WriteStr(typeCoder.Ptr + "<")
        obj.Write(elem)
        obj.WriteByte('>')
        ret unsafe { obj.Buf() }
    }

    // Generates C++ code of smart pointer TypeKind.
    fn sptr(mut self, mut sptr: &Sptr): []byte {
        ret self.asSptr(self.kind(sptr.Elem))
    }

    // Generates C++ code of Ptr TypeKind.
    fn ptr(mut self, mut p: &Ptr): []byte {
        const CppPointerMask = "*"
        if p.IsUnsafe() {
            ret unsafe::StrBytes("void" + CppPointerMask)
        }
        ret append(self.kind(p.Elem), '*')
    }

    // Generates C++ code of Enum TypeKind.
    fn enumDecl(mut self, mut e: &Enum): []byte {
        ret self.kind(e.Kind.Kind)
    }

    // Generates C++ code of TypeEnum TypeKind.
    fn typeEnumDecl(mut self, mut e: &TypeEnum): []byte {
        ret unsafe::StrBytes(typeCoder.Any)
    }

    fn asSlice(mut self, mut elem: &TypeKind): []byte {
        mut obj := StrBuilder.New(len(typeCoder.Slice + "<>") + (1 << 5))
        obj.WriteStr(typeCoder.Slice + "<")
        obj.Write(self.kind(elem))
        obj.WriteByte('>')
        ret unsafe { obj.Buf() }
    }

    // Generates C++ code of Slc TypeKind.
    fn slice(mut self, mut s: &Slc): []byte {
        ret self.asSlice(s.Elem)
    }

    // Generates C++ code of Map TypeKind.
    fn mapType(mut self, mut m: &Map): []byte {
        mut obj := StrBuilder.New(len(typeCoder.Map + "<>") + (1 << 5))
        obj.WriteStr(typeCoder.Map + "<")
        obj.Write(self.kind(m.Key))
        obj.WriteByte(',')
        obj.Write(self.kind(m.Val))
        obj.WriteByte('>')
        ret unsafe { obj.Buf() }
    }

    fn traitIdent(mut self, ident: []byte): []byte {
        mut obj := StrBuilder.New(len(typeCoder.Trait + "<>") + len(ident))
        obj.WriteStr(typeCoder.Trait + "<")
        obj.Write(ident)
        obj.WriteByte('>')
        ret unsafe { obj.Buf() }
    }

    // Generates C++ code of Trait TypeKind.
    fn traitDecl(mut self, t: &Trait): []byte {
        ret self.traitIdent(identCoder.traitDecl(t))
    }

    // Generates C++ code of Struct TypeKind.
    fn structure(mut self, s: &Struct): []byte {
        mut rep := StrBuilder.New(1 << 5)
        if s.Binded && !hasDirective(s.Directives, Directive.Typedef) {
            rep.WriteStr("struct ")
        }
        rep.Write(identCoder.structure(s))
        ret unsafe { rep.Buf() }
    }

    // Generates C++ code of Struct instance TypeKind.
    fn structureIns(mut self, mut s: &StructIns): []byte {
        if s.Decl.Binded {
            mut ident := StrBuilder.New(1 << 5)
            ident.Write(identCoder.structureIns(s))
            if len(s.Generics) > 0 {
                ident.WriteByte('<')
                for (i, mut g) in s.Generics {
                    ident.Write(self.kind(g.Kind))
                    if len(s.Generics)-i > 1 {
                        ident.WriteByte(',')
                    }
                }
                ident.WriteByte('>')
            }
            d := findDirective(s.Decl.Directives, Directive.Namespace)
            if d != nil {
                mut buf := ident.Str()
                ident.Clear()
                ident.Write(concatAllParts(d.Args...))
                ident.WriteStr("::")
                ident.WriteStr(buf)
            }
            ret unsafe { ident.Buf() }
        }
        ret identCoder.structureIns(s)
    }

    // Generates C++ code of Arr TypeKind.
    fn array(mut self, mut a: &Arr): []byte {
        mut obj := StrBuilder.New(len(typeCoder.Array + "<>") + (1 << 5))
        obj.WriteStr(typeCoder.Array + "<")
        obj.Write(self.kind(a.Elem))
        obj.WriteByte(',')
        obj.WriteStr(conv::Itoa(a.N))
        obj.WriteByte('>')
        ret unsafe { obj.Buf() }
    }

    // Generates C++ prototype code of parameter.
    fn param(mut self, mut &p: &Param): []byte {
        mut obj := StrBuilder.New(1 << 5)
        if p.Variadic {
            obj.WriteStr(typeCoder.Slice + "<")
            obj.Write(self.kind(p.Kind.Kind))
            obj.WriteByte('>')
        } else {
            obj.Write(self.kind(p.Kind.Kind))
        }
        if p.Reference {
            obj.WriteByte('*')
        }
        ret unsafe { obj.Buf() }
    }

    // Generates C++ prototype code of parameter instance.
    fn paramIns(mut self, mut &p: &ParamIns): []byte {
        mut obj := StrBuilder.New(1 << 5)
        if p.Decl.Variadic {
            obj.WriteStr(typeCoder.Slice + "<")
            obj.Write(self.kind(p.Kind))
            obj.WriteByte('>')
        } else {
            obj.Write(self.kind(p.Kind))
        }
        if p.Decl.Reference {
            obj.WriteByte('*')
        }
        ret unsafe { obj.Buf() }
    }

    // Generates C++ code of function's result type.
    fn funcResult(mut self, mut &f: &Fn): []byte {
        if f.IsVoid() {
            if f.Exceptional {
                ret unsafe::StrBytes("jule::VoidExceptional")
            }
            ret unsafe::StrBytes("void")
        }
        if f.Exceptional {
            ret unsafe::BytesFromStr("jule::Exceptional<" + str(self.kind(f.Result.Kind.Kind)) + ">")
        }
        ret self.kind(f.Result.Kind.Kind)
    }

    // Generates C++ code of function instance's result type.
    fn funcInsResult(mut self, mut &s: StrBuilder, mut &f: &FnIns) {
        if f.Decl.IsVoid() {
            if f.Decl.Exceptional {
                s.WriteStr("jule::VoidExceptional")
            } else {
                s.WriteStr("void")
            }
            ret
        }
        if f.Decl.Exceptional {
            s.WriteStr("jule::Exceptional<")
            self.rc.codeMut1(s, f.Result)
            s.WriteByte('>')
            ret
        }
        self.rc.codeMut1(s, f.Result)
    }

    fn anonFunc(mut self, mut f: &FnIns): []byte {
        if f.Result != nil && f.Result.Tup() != nil {
            self.oc.pushResultIns(f)
        }
        mut decl := StrBuilder.New(20)
        self.funcInsResult(decl, f)
        decl.WriteByte('(')
        if len(f.Params) > 0 {
            for (i, mut param) in f.Params {
                if param.Decl.IsSelf() {
                    continue
                }
                decl.Write(self.paramIns(param))
                if len(f.Params)-i > 1 {
                    decl.WriteByte(',')
                }
            }
        } else {
            decl.WriteStr("void")
        }
        decl.WriteByte(')')
        ret unsafe { decl.Buf() }
    }

    // Generates C++ code of Fn TypeKind.
    fn func(mut self, mut f: &FnIns): []byte {
        mut obj := StrBuilder.New(len(typeCoder.Fn + "<>") + (1 << 5))
        obj.WriteStr(typeCoder.Fn + "<")
        obj.Write(self.anonFunc(f))
        obj.WriteByte('>')
        ret unsafe { obj.Buf() }
    }

    // Generates C++ code of TypeKind.
    fn kind(mut self, mut k: &TypeKind): []byte {
        match {
        | k.Struct() != nil:
            ret self.structureIns(k.Struct())
        | k.Binded():
            // As we can see here, bind defines use pure identifiers directly.
            // So, if you hesitate about a type that causes wrong code generation,
            // write relevant algorithms above this case.
            ret unsafe::BytesFromStr(k.BindIdent)
        | k.Prim() != nil:
            ret self.prim(k.Prim())
        | k.Tup() != nil:
            ret self.tuple(k.Tup())
        | k.Sptr() != nil:
            ret self.sptr(k.Sptr())
        | k.Ptr() != nil:
            ret self.ptr(k.Ptr())
        | k.Enum() != nil:
            ret self.enumDecl(k.Enum())
        | k.TypeEnum() != nil:
            ret self.typeEnumDecl(k.TypeEnum())
        | k.Slc() != nil:
            ret self.slice(k.Slc())
        | k.Map() != nil:
            ret self.mapType(k.Map())
        | k.Trait() != nil:
            ret self.traitDecl(k.Trait())
        | k.Arr() != nil:
            ret self.array(k.Arr())
        | k.Fn() != nil:
            ret self.func(k.Fn())
        }
        match type k.Kind {
        | &customType:
            ret unsafe::StrBytes((&customType)(k.Kind).kind)
        |:
            ret unsafe::StrBytes("[<unimplemented_type_kind>]")
        }
    }
}

struct resultCoder {
    tc: &typeCoder
}

impl resultCoder {
    const Map = "m"
    const Slice = "s"
    const Ptr = "p"
    const Sptr = "x"
    const Array = "a"
    const Reference = "r"
    const Fn = "f"

    static fn new(mut &tc: &typeCoder): &resultCoder {
        ret &resultCoder{tc: tc}
    }

    fn ptr(mut self, mut &s: StrBuilder, mut p: &Ptr) {
        s.WriteStr(resultCoder.Ptr)
        self.codeMut(s, p.Elem)
    }

    fn sptr(mut self, mut &s: StrBuilder, mut p: &Sptr) {
        s.WriteStr(resultCoder.Sptr)
        self.codeMut(s, p.Elem)
    }

    fn mapType(mut self, mut &s: StrBuilder, mut p: &Map) {
        s.WriteStr(resultCoder.Map)
        self.codeMut(s, p.Key)
        self.codeMut(s, p.Val)
    }

    fn slice(mut self, mut &s: StrBuilder, mut slc: &Slc) {
        s.WriteStr(resultCoder.Slice)
        self.codeMut(s, slc.Elem)
    }

    fn arr(mut self, mut &s: StrBuilder, mut arr: &Arr) {
        s.WriteStr(resultCoder.Array)
        s.WriteStr(conv::FmtInt(i64(arr.N), 16))
        self.codeMut(s, arr.Elem)
    }

    fn func(mut self, mut &s: StrBuilder, mut f: &FnIns) {
        s.WriteStr(resultCoder.Fn)
        for (_, mut p) in f.Params {
            if p.Decl.Reference {
                s.WriteStr(resultCoder.Reference)
            }
            self.codeMut(s, p.Kind)
        }
        if f.Result != nil {
            self.codeMut(s, f.Result)
        }
    }

    fn tup(mut self, mut &s: StrBuilder, mut tup: &Tuple) {
        for (_, mut t) in tup.Types {
            s.WriteStr("__jule_tuple_")
            self.codeMut(s, t)
        }
    }

    fn codeMut(mut self, mut &s: StrBuilder, mut &t: &TypeKind) {
        match type t.Kind {
        | &Ptr:
            self.ptr(s, (&Ptr)(t.Kind))
        | &Sptr:
            self.sptr(s, (&Sptr)(t.Kind))
        | &Map:
            self.mapType(s, (&Map)(t.Kind))
        | &Slc:
            self.slice(s, (&Slc)(t.Kind))
        | &Arr:
            self.arr(s, (&Arr)(t.Kind))
        | &FnIns:
            self.func(s, (&FnIns)(t.Kind))
        | &Enum:
            te := (&Enum)(t.Kind)
            s.Write(identCoder.toOut(te.Ident, uintptr(te)))
        | &TypeEnum:
            te := (&TypeEnum)(t.Kind)
            s.Write(identCoder.toOut(te.Ident, uintptr(te)))
        | &StructIns:
            mut si := (&StructIns)(t.Kind)
            s.Write(identCoder.structureIns(si))
        | &Trait:
            mut trt := (&Trait)(t.Kind)
            s.Write(identCoder.traitDecl(trt))
        | &Prim:
            s.WriteStr((&Prim)(t.Kind).Kind)
        | &Tuple:
            self.tup(s, (&Tuple)(t.Kind))
        |:
            panic("this panic call should be unreachable")
        }
    }

    fn codeMut1(mut self, mut &s: StrBuilder, mut &t: &TypeKind) {
        mut tup := t.Tup()
        if tup != nil {
            self.tup(s, tup)
        } else {
            s.Write(self.tc.kind(t))
        }
    }

    fn code(mut self, mut &t: &TypeKind): []byte {
        mut s := StrBuilder.New(20)
        self.codeMut(s, t)
        ret unsafe { s.Buf() }
    }
}

// Returns directive if exist.
fn findDirective(mut &directives: []&ast::Directive, tag: str): &ast::Directive {
    for (_, mut dr) in directives {
        if dr.Tag.Kind == tag {
            ret dr
        }
    }
    ret nil
}

// Reports whether directive is exist.
fn hasDirective(&directives: []&ast::Directive, tag: str): bool {
    ret findDirective(unsafe { *(&directives) }, tag) != nil
}

// Reports whether type should initialized.
// If the type API implemented structure of something like that, initialization is redundant.
// Let the constructor do it's job.
fn shouldInitialized(mut &t: &TypeKind): bool {
    prim := t.Prim()
    if prim != nil {
        ret !prim.IsAny() && !prim.IsStr()
    }
    match {
    | t.Sptr() != nil:
        ret false
    | t.Map() != nil:
        ret false
    | t.Slc() != nil:
        ret false
    | t.Trait() != nil:
        ret false
    | t.Fn() != nil:
        ret false
    | t.Arr() != nil:
        mut arr := t.Arr()
        ret shouldInitialized(arr.Elem)
    | t.Struct() != nil:
        ret false
    |:
        ret true
    }
}