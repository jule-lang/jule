// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use env
use opt
use obj::{IR}
use conv for std::conv
use jule for std::jule
use build for std::jule::build::{
    Directive,
    Derive,
}
use std::jule::lex::{
    Token,
    TokenId,
    IsIgnoreIdent,
    IsAnonIdent,
}
use std::jule::sema::{
    FuncPattern,
    Package,
    SymbolTable,
    Param,
    ParamIns,
    Trait,
    Struct,
    FieldIns,
    Var,
    StructIns,
    Fn,
    FnIns,
    TypeKind,
    Prim,
    Sptr,
    TypeSymbol,
}
use path for std::fs::path
use strings for std::strings
use std::time::{Time}

// Data offset of empty trait.
const emptyTraitOffset = 0x0

struct SerializationInfo {
    Compiler:        str
    CompilerCommand: str
}

struct traitHash {
    t: &Trait
    s: &StructIns
    i: int
}

struct ObjectCoder {
    // Internal buffer which is commonly used.
    Obj: str

    ir:   &IR
    info: SerializationInfo
    tmap: []&traitHash

    // Current indentation.
    indentBuffer: str

    ec: &exprCoder
    sc: &scopeCoder
}

impl ObjectCoder {
    static fn New(mut &ir: &IR, info: SerializationInfo): &ObjectCoder {
        let mut oc = &ObjectCoder{
            ir: ir,
            info: info,
        }
        oc.ec = exprCoder.new(oc)
        oc.sc = scopeCoder.new(oc)
        ret oc
    }

    fn write(mut &self, s: str) {
        self.Obj += s
    }

    // Increase indentation.
    fn addIndent(mut &self) {
        const IndentKind = "\t"
        self.indentBuffer += IndentKind
    }

    // Decrase indentation.
    fn doneIndent(mut &self) {
        self.indentBuffer = self.indentBuffer[:len(self.indentBuffer)-1]
    }

    // Writes indention string by indentBuffer.
    fn indent(mut &self) {
        self.Obj += self.indentBuffer
    }

    fn findTypeOffset(self, t: &Trait, mut k: &TypeKind): int {
        if len(t.Implemented) == 0 {
            ret emptyTraitOffset
        }
        let mut s: &StructIns = nil
        if k.Sptr() != nil {
            k = k.Sptr().Elem
        }
        if k.Struct() == nil {
            ret -1
        }
        s = k.Struct()
        for _, hash in self.tmap {
            if hash.t == t && hash.s == s {
                ret hash.i
            }
        }
        ret -1
    }

    // Writes location information of token as cstr bytes.
    fn locInfo(mut &self, &t: &Token) {
        let &loc = t.File.Path

        // Normalize path if production compilation enabled.
        if env::Production {
            match {
            | strings::HasPrefix(loc, build::PathStdlib):
                // Remove absolute path prefix of standard library.
                // Just keeps "std/" prefix.
                self.write(cstrBytes([]byte(loc[len(path::Dir(build::PathStdlib))+1:])))
            | strings::HasPrefix(loc, self.ir.Root):
                // Remove absolute path prefix of root package.
                // Just keeps "[package_dir]/" prefix.
                self.write(cstrBytes([]byte(loc[len(path::Dir(self.ir.Root))+1:])))
            |:
                self.write(cstrBytes([]byte(loc)))
            }
        } else {
            self.write(cstrBytes([]byte(loc)))
        }
        self.write(":")
        self.write(conv::Itoa(t.Row))
        self.write(":")
        self.write(conv::Itoa(t.Column))
    }

    fn head(mut &self) {
        let time = Time.Now()
        let abs = time.Abs()
        self.write("// Auto generated by JuleC.\n")
        self.write("// JuleC version: ")
        self.write(jule::Version)
        self.write("\n")
        self.write("// Date: ")
        self.write(conv::FmtUint(abs.Day, 10))
        self.write("/")
        self.write(conv::FmtUint(abs.Month, 10))
        self.write("/")
        self.write(conv::FmtUint(abs.Year, 10))
        self.write(" (DD/MM/YYYY) UTC\n//\n// Recomended Compile Command;\n// ")
        self.write(self.info.Compiler)
        self.write(" ")
        self.write(self.info.CompilerCommand)
        self.write("\n\n")

        if env::Production {
            self.write("#define __JULE_ENABLE__PRODUCTION\n")
        }
        if !env::RC {
            self.write("#define __JULE_DISABLE__REFERENCE_COUNTING\n")
        }
        if !env::Safety {
            self.write("#define __JULE_DISABLE__SAFETY\n")
        }

        // Include linked libraries here, before the API header.
        // See developer reference (4).
        self.links()

        self.write("\n\n#include \"")
        self.write(build::PathApi)
        self.write("\"\n\n")
    }

    fn links(mut &self) {
        for _, used in self.ir.Used {
            match {
            | !used.CppLinked:
                continue
            | build::IsStdHeaderPath(used.Path):
                self.write("#include ")
                self.write(used.Path)
                self.write("\n")
            |:
                self.write("#include \"")
                self.write(used.Path)
                self.write("\"\n")
            }
        }
    }

    fn prepareStructures(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                prepareStructure(s)
            }
        }
    }

    fn iterPackages(mut &self, f: fn(mut &pkg: &Package)) {
        for (_, mut used) in self.ir.Used {
            if !used.CppLinked {
                f(used.Package)
            }
        }
        f(self.ir.Main)
    }

    fn buildTraitMap(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.Traits {
                    if t.Token == nil {
                        ret
                    }
                    if len(t.Implemented) == 0 {
                        self.tmap = append(self.tmap, &traitHash{
                            t: t,
                            s: nil,
                            i: emptyTraitOffset,
                        })
                        continue
                    }
                    let mut i = 0
                    for (_, mut s) in t.Implemented {
                        for (_, mut ins) in s.Instances {
                            self.tmap = append(self.tmap, &traitHash{
                                t: t,
                                s: ins,
                                i: i,
                            })
                            i++
                        }
                    }
                }
            })
        })
    }

    fn traitDecls(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.Traits {
                    if t.Token == nil {
                        ret
                    }
                    self.indent()
                    self.write("struct ")
                    self.write(identCoder.traitDecl(t))
                    self.write("{};\n")
                }
            })
        })
    }

    fn structurePlainDecl(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.Instances {
            self.write("struct ")
            self.write(identCoder.structureIns(ins))
            self.write(";\n")
        }
    }

    fn structurePlainDecls(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                self.structurePlainDecl(s)
            }
        }
    }

    fn fieldDecl(mut &self, mut &f: &FieldIns) {
        self.write(typeCoder.kind(f.Kind))
        self.write(" ")
        self.write(identCoder.field(f.Decl))
        if f.Default == nil {
            if shouldInitialized(f.Kind) {
                self.write(" = ")
                // No default expression.
                // Use default expression of data-type.
                self.ec.initExpr(f.Kind)
            }
        } else {
            self.write(" = ")
            self.ec.expr(f.Default.Model)
        }
        self.write(";")
    }

    fn structureDestructor(mut &self, mut &s: &StructIns) {
        // Dispose method must be non-static
        const Static = false
        let disposeMethod = s.FindMethod("Dispose", Static)
        let mut disposed = FuncPattern.Dispose(disposeMethod)
        // Call destructor if implemented.
        if !disposed {
            ret
        }
        self.write("~")
        self.write(identCoder.structureIns(s))
        self.write("(void) { ")
        self.write(identCoder.func(disposeMethod))
        self.write("(this); }")
    }

    fn structureDeriveDefsDecls(mut &self, &s: &StructIns) {
        if s.Decl.IsDerives(Derive.Clone) {
            self.indent()
            self.write(deriveCoder.cloneFuncDecl(s.Decl))
            self.write(";\n\n")
        }
    }

    fn structureOperatorEq(mut &self, &ident: str, mut &s: &StructIns) {
        // Operator overloading.
        if s.Operators.Eq != nil {
            self.structureOperator(ident, s.Operators.Eq, "==")
            ret
        }

        self.indent()
        if opt::Inline {
            self.write("inline ")
        }
        self.write("bool operator==(")
        self.write(ident)
        self.write(" _other) {")
        if len(s.Fields) > 0 {
            self.addIndent()
            self.write("\n")
            self.indent()
            self.write("return ")
            self.addIndent()
            let mut writed = false
            for (_, mut f) in s.Fields {
                // Skip C++-linked struct kinds.
                let strct = f.Kind.Struct()
                if strct != nil && strct.Decl != nil && strct.Decl.CppLinked {
                    continue
                }

                if writed {
                    self.write(" &&")
                }
                writed = true
                self.write("\n")
                self.indent()
                self.write("this->")
                let fIdent = identCoder.field(f.Decl)
                self.write(fIdent)
                self.write(" == _other.")
                self.write(fIdent)
            }
            self.doneIndent()
            if !writed {
                self.write("true")
            }
            self.write(";\n")
            self.doneIndent()
            self.indent()
            self.write("}")
        } else {
            self.write(" return true; }")
        }
        self.write("\n\n")
    }

    fn structureOperatorNotEq(mut &self, &ident: str, mut &s: &StructIns) {
        self.indent()
        if opt::Inline {
            self.write("inline ")
        }
        self.write("bool operator!=(")
        self.write(ident)
        self.write(" _other) { return !this->operator==(_other); }\n\n")
    }

    // Write operator overloading forwarding for reserved function.
    fn structureOperator(mut &self, &ident: str, mut &f: &FnIns, op: str) {
        if f == nil {
            ret
        }

        let unary = len(f.Params) == 1   // Just self parameter.
        let assignment = f.Decl.IsVoid()

        self.indent()
        if opt::Inline {
            self.write("inline ")
        }
        if assignment {
            self.write(ident)
            self.write("&")
        } else {
            if f.Result.Prim() == nil {
                // If result type is not primitive, always structure's itself.
                self.write(ident)
            } else {
                // Logical.
                self.write(typeCoder.Bool)
            }
        }
        self.write(" operator")
        self.write(op)
        self.write("(")
        if !unary {
            let mut p = f.Params[1]
            self.write(typeCoder.paramIns(p))
            self.write(" _other")
        }
        self.write(") { ")
        if !assignment {
            self.write("return ")
        }
        self.write(identCoder.funcIns(f))
        if !unary {
            self.write("(this, _other); ")
            if assignment {
                self.write("return *this; ")
            }
            self.write("}")
        } else {
            self.write("(this); }")
        }
        self.write("\n\n")
    }

    fn structureOperators(mut &self, mut &s: &StructIns) {
        let ident = identCoder.structureIns(s)

        // Binary.
        self.structureOperatorEq(ident, s)
        self.structureOperatorNotEq(ident, s)
        self.structureOperator(ident, s.Operators.Gt, ">")
        self.structureOperator(ident, s.Operators.GtEq, ">=")
        self.structureOperator(ident, s.Operators.Lt, "<")
        self.structureOperator(ident, s.Operators.LtEq, "<=")
        self.structureOperator(ident, s.Operators.Shl, "<<")
        self.structureOperator(ident, s.Operators.Shr, ">>")
        self.structureOperator(ident, s.Operators.Add, "+")
        self.structureOperator(ident, s.Operators.Sub, "-")
        self.structureOperator(ident, s.Operators.Div, "/")
        self.structureOperator(ident, s.Operators.Mul, "*")
        self.structureOperator(ident, s.Operators.Mod, "%")
        self.structureOperator(ident, s.Operators.BitAnd, "&")
        self.structureOperator(ident, s.Operators.BitOr, "|")
        self.structureOperator(ident, s.Operators.BitXor, "^")

        // Unary.
        self.structureOperator(ident, s.Operators.Neg, "-")
        self.structureOperator(ident, s.Operators.Pos, "+")
        self.structureOperator(ident, s.Operators.BitNot, "~")

        // Assignment.
        self.structureOperator(ident, s.Operators.AddAssign, "+=")
        self.structureOperator(ident, s.Operators.SubAssign, "-=")
        self.structureOperator(ident, s.Operators.DivAssign, "/=")
        self.structureOperator(ident, s.Operators.MulAssign, "*=")
        self.structureOperator(ident, s.Operators.ModAssign, "%=")
        self.structureOperator(ident, s.Operators.ShlAssign, "<<=")
        self.structureOperator(ident, s.Operators.ShrAssign, ">>=")
        self.structureOperator(ident, s.Operators.BitOrAssign, "|=")
        self.structureOperator(ident, s.Operators.BitAndAssign, "&=")
        self.structureOperator(ident, s.Operators.BitXorAssign, "^=")
    }

    fn structureInsDecl(mut &self, mut &s: &StructIns) {
        if len(s.Methods) > 0 {
            for (_, mut m) in s.Methods {
                self.funcDecl(m, false)
            }
        }

        self.write("struct ")
        let outIdent = identCoder.structureIns(s)

        self.write(outIdent)
        self.write(" {\n")

        self.addIndent()
        for (_, mut f) in s.Fields {
            self.indent()
            self.fieldDecl(f)
            self.write("\n")
        }

        self.indent()
        self.structureDestructor(s)
        self.write("\n\n")

        // Default constructor.
        self.indent()
        self.write(outIdent)
        self.write("(void) = default;\n\n")

        self.structureDeriveDefsDecls(s)

        self.structureOperators(s)
        self.write("\n")

        self.doneIndent()
        self.indent()
        self.write("};")
    }

    fn structureDecl(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.Instances {
            self.structureInsDecl(ins)
        }
    }

    fn structureDecls(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                self.structureDecl(s)
                self.write("\n")
            }
        }
    }

    fn paramsDecls(mut &self, mut &params: []&ParamIns) {
        if len(params) == 0 {
            self.write("(void)")
            ret
        }

        self.write("(")
        for (i, mut p) in params {
            self.write(typeCoder.paramIns(p))
            if len(params)-i > 1 {
                self.write(", ")
            }
        }

        self.write(")")
    }

    fn funcHead(mut &self, mut &f: &FnIns, ptr: bool) {
        if !ptr && opt::Inline && !f.Decl.IsEntryPoint() {
            self.write("inline ")
        }
        self.write(typeCoder.funcInsResult(f))
        if ptr {
            self.write("(*")
            self.write(identCoder.funcIns(f))
            self.write(")")
        } else {
            self.write(" ")
            self.write(identCoder.funcIns(f))
        }
    }

    fn funcDecl(mut &self, mut &f: &Fn, ptr: bool) {
        for (_, mut c) in f.Instances {
            self.indent()
            self.funcHead(c, ptr)
            self.paramsDecls(c.Params)
            self.write(";\n")
        }
    }

    fn funcDecls(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut f) in file.Funcs {
                    if !f.CppLinked && f.Token != nil {
                        self.funcDecl(f, false)
                    }
                }
            })
        })
    }

    fn traitDataTypes(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.Traits {
                    if t.Token == nil {
                        ret
                    }
                    self.write("struct ")
                    self.write(identCoder.traitDecl(t))
                    self.write("MptrData")
                    self.write(" {\n")
                    self.addIndent()
                    for (_, mut m) in t.Methods {
                        let mut ins = m.Instances[0]
                        let mut p = ins.Params[0]
                        p.Kind = &TypeKind{
                            Kind: t,
                        }
                        for (i, mut ip) in ins.Params[1:] {
                            if IsAnonIdent(ip.Decl.Ident) {
                                ip.Decl.Ident = "_" + conv::Itoa(i)
                            }
                        }
                        if !env::Production {
                            ins.Params = append(ins.Params, &ParamIns{
                                Decl: &Param{
                                    Ident: "__file",
                                },
                                Kind: &TypeKind{
                                    Kind: &customType{
                                        kind: "const char*",
                                    },
                                },
                            })
                        }
                        self.funcDecl(m, true)
                    }
                    self.doneIndent()
                    self.indent()
                    self.write("};\n\n")
                }
            })
        })
    }

    fn paramIns(mut &self, mut &p: &ParamIns) {
        self.write(typeCoder.paramIns(p))
        self.write(" ")
        self.write(identCoder.param(p.Decl))
    }

    fn paramsIns(mut &self, mut &params: []&ParamIns) {
        if len(params) == 0 {
            self.write("(void)")
            ret
        }
        self.write("(")
        for (i, mut p) in params {
            self.paramIns(p)
            if len(params)-i > 1 {
                self.write(", ")
            }
        }
        self.write(")")
    }

    fn varInitExpr(mut &self, mut &v: &Var, init: fn()) {
        if v.Statically {
            self.write("static ")
        }

        self.write(typeCoder.kind(v.Kind.Kind))
        self.write(" ")
        if v.Reference {
            self.write("&")
        }
        self.write(identCoder.var(v))
        if init != nil {
            self.write(" = ")
            init()
        }
        self.write(";")
    }

    fn var(mut &self, mut v: &Var) {
        if IsIgnoreIdent(v.Ident) {
            ret
        }
        if v.Value != nil && v.Value.Expr != nil {
            if v.Value.Data.Model != nil {
                self.varInitExpr(v, fn() { self.ec.val(v.Value) })
                ret
            }
            self.varInitExpr(v, nil)
            ret
        }
        if shouldInitialized(v.Kind.Kind) {
            self.varInitExpr(v, fn() { self.ec.initExpr(v.Kind.Kind) })
            ret
        }
        self.varInitExpr(v, nil)
    }

    fn func(mut &self, mut &f: &Fn) {
        for (_, mut ins) in f.Instances {
            self.funcHead(ins, false)
            self.paramsIns(ins.Params)
            self.write(" ")
            self.sc.funcScope(ins)
            if ins.Scope != nil {
                self.write("\n\n")
            }
        }
    }

    fn traitWrappers(mut &self) {
        for (_, mut hash) in self.tmap {
            for (_, mut m) in hash.t.Methods {
                let ident = m.Ident

                m.Instances[0].Scope = nil
                m.Ident = ident + "_" + conv::Itoa(hash.i)
                self.func(m)
                m.Ident = ident

                if hash.s == nil {
                    if env::Production {
                        self.write(" { jule::panic(__JULE_ERROR__INVALID_MEMORY); }\n")
                    } else {
                        self.write(" { jule::panic(" + typeCoder.Str + "(__JULE_ERROR__INVALID_MEMORY \"\\nlocation: \") + " + typeCoder.Str + "(_00___file)); }\n")
                    }
                    continue
                }

                let ptr = !m.Params[0].IsRef()

                let mut sm = hash.s.FindMethod(m.Ident, false)
                if sm == nil || len(sm.Instances) == 0 {
                    continue
                }

                self.addIndent()
                self.write("{\n")
                self.indent()
                if sm.Exceptional || !sm.IsVoid() {
                    self.write("return ")
                }
                self.write(identCoder.func(sm))
                self.write("(")
                if ptr {
                    self.write("_self_.safe_ptr<")
                    self.write(typeCoder.structureIns(hash.s))
                    self.write(">(")
                    if !env::Production {
                        self.write("_00___file")
                    }
                    self.write(")")
                } else {
                    self.write("_self_.data.as<")
                    self.write(typeCoder.structure(sm.Owner))
                    self.write(">()")
                }
                for _, mp in m.Params[1:] {
                    self.write(", ")
                    self.write(identCoder.param(mp))
                }
                self.write(");\n}\n")
                self.doneIndent()
            }
        }
    }

    fn traitDatas(mut &self) {
        let mut old: &Trait = nil
        for (_, mut hash) in self.tmap {
            let ident = identCoder.traitDecl(hash.t)
            if hash.t != old {
                if old != nil {
                    self.doneIndent()
                    self.indent()
                    self.write("};\n")
                }
                self.write("static ")
                self.write(ident)
                self.write("MptrData ")
                self.write(ident)
                self.write("_mptr_data[] = {\n")
                old = hash.t
                self.addIndent()
            }
            self.indent()
            self.write("{\n")
            self.addIndent()
            for (_, mut m) in hash.t.Methods {
                let mIdent = identCoder.func(m)
                self.indent()
                self.write(".")
                self.write(mIdent)
                self.write("=")
                self.write(mIdent)
                self.write("_")
                self.write(conv::Itoa(hash.i))
                self.write(",\n")
            }
            self.doneIndent()
            self.indent()
            self.write("},\n")
        }
        if old != nil {
            self.doneIndent()
            self.indent()
            self.write("};\n")
        }
    }

    fn globals(mut &self) {
        for (_, mut v) in self.ir.Ordered.Globals {
            self.write(typeCoder.kind(v.Kind.Kind))
            self.write(" ")
            if v.Reference {
                self.write("&")
            }
            self.write(identCoder.var(v))
            self.write(" = ")
            self.ec.val(v.Value)
            self.write(";\n")
        }
    }

    fn decls(mut &self) {
        self.traitDecls()
        self.structurePlainDecls()
        self.structureDecls()
        self.funcDecls()
        self.write("\n\n")
        self.traitDataTypes()
        self.write("\n\n")
        self.traitWrappers()
        self.write("\n\n")
        self.traitDatas()
        self.write("\n\n")
        self.globals()
    }

    fn structureMethods(mut &self, mut &s: &StructIns) {
        for (_, mut f) in s.Methods {
            self.func(f)
            self.write("\n\n")
        }
    }

    fn structureDeriveDefs(mut &self, mut &s: &StructIns) {
        if s.Decl.IsDerives(Derive.Clone) {
            self.write(deriveCoder.cloneFuncDef(s.Decl))
            self.write("{\n")
            self.addIndent()
            self.indent()
            self.write(typeCoder.structureIns(s))
            self.write(" clone;\n")
            for _, f in s.Fields {
                let ident = identCoder.field(f.Decl)
                self.indent()
                self.write("clone.")
                self.write(ident)
                self.write(" = jule::clone(this->")
                self.write(ident)
                self.write(");\n")
            }
            self.indent()
            self.write("return clone;\n")
            self.doneIndent()
            self.write("}")
        }
    }

    fn structureOstream(mut &self, mut &s: &StructIns) {
        self.indent()
        self.write("std::ostream &operator<<(std::ostream &_Stream, ")
        self.write(identCoder.structureIns(s))
        self.write(" _Src) {\n")
        self.addIndent()
        self.indent()

        let mut fts = s.FindMethod("Str", false)
        if FuncPattern.Str(fts) {
            self.write("_Stream << ")
            self.write(identCoder.func(fts))
            self.write("(&_Src);\n")
        } else {
            self.write(`_Stream << "`)
            self.write(s.Decl.Ident)
            self.write("{\";\n")

            for (i, mut f) in s.Fields {
                self.indent()
                self.write(`_Stream << "`)
                self.write(f.Decl.Ident)
                self.write(`:`)

                // Skip C++-linked struct kinds.
                let strct = f.Kind.Struct()
                if strct != nil && strct.Decl != nil && strct.Decl.CppLinked {
                    self.write(` cpp.`)
                    self.write(identCoder.field(f.Decl))
                    self.write(`"`)
                } else {
                    self.write(`" << _Src.`)
                    self.write(identCoder.field(f.Decl))
                }
                if i+1 < len(s.Fields) {
                    self.write(" << \", \"")
                }
                self.write(";\n")
            }

            self.indent()
            self.write("_Stream << \"}\";\n")
        }

        self.indent()
        self.write("return _Stream;\n")

        self.doneIndent()
        self.write("}")
    }

    fn structureIns(mut &self, mut &s: &StructIns) {
        self.structureMethods(s)
        self.write("\n\n")
        self.structureDeriveDefs(s)
        self.write("\n\n")
        self.structureOstream(s)
    }

    fn structure(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.Instances {
            self.structureIns(ins)
            self.write("\n\n")
        }
    }

    fn structures(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                self.structure(s)
                self.write("\n\n")
            }
        }
    }

    fn funcs(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut f) in file.Funcs {
                    if !env::Test && hasDirective(f.Directives, Directive.Test) {
                        continue
                    }
                    if !f.CppLinked && f.Token != nil {
                        self.func(f)
                        self.write("\n\n")
                    }
                }
            })
        })
    }

    fn pushInit(mut &self, mut &pkg: &Package) {
        iterFiles(pkg, fn(mut &file: &SymbolTable) {
            for _, f in file.Funcs {
                if f.Ident == build::InitFn {
                    self.indent()
                    self.write(identCoder.func(f))
                    self.write("();\n")
                }
            }
        })
    }

    fn initCaller(mut &self) {
        self.write("void " + initCallerIdent + "(void) {\n")
        self.addIndent()
        self.iterPackages(fn(mut &pkg: &Package) {
            self.pushInit(pkg)
        })
        self.doneIndent()
        self.write("\n}")
    }

    fn end(mut &self) {
        self.write(`int main(int argc, char *argv[], char *envp[]) {
    jule::setup_argv(argc, argv);
    jule::setup_envp(envp);

    __jule_call_initializers();
    `)

        if env::Test {
            self.write("test_point();")
        } else {
            self.write("entry_point();")
        }

        self.write(`

    return EXIT_SUCCESS;
}`)
    }

    fn serializeHead(mut &self) {
        self.prepareStructures()
        self.buildTraitMap()
        self.head()
        self.write("\n")
        self.decls()
        self.write("\n")
        self.structures()
        self.funcs()
        self.initCaller()
        self.write("\n\n")
    }

    fn Serialize(mut &self) {
        self.serializeHead()
        self.end()
    }
}

fn iterFiles(mut &pkg: &Package, f: fn(mut &f: &SymbolTable)) {
    for (_, mut file) in pkg.Files {
        f(file)
    }
}

fn prepareStructure(mut &s: &Struct) {
    for (_, mut ins) in s.Instances {
        for (_, mut m) in ins.Methods {
            if m.Statically {
                continue
            }
            for (_, mut mins) in m.Instances {
                let mut p = mins.Params[0]
                if !p.Decl.IsRef() {
                    p.Kind = &TypeKind{
                        Kind: &customType{
                            kind: typeCoder.asPtr(typeCoder.kind(p.Kind)),
                        },
                    }
                } else {
                    p.Kind = &TypeKind{
                        Kind: &customType{
                            kind: typeCoder.kind(p.Kind),
                        },
                    }
                }
            }
        }
    }
}

// Concatenate all strings into single string.
fn concatAllParts(parts: ...&Token): str {
    let mut n = 0
    for _, part in parts {
        n += len(part.Kind)
    }
    if n == 0 {
        ret ""
    }
    let mut s = make(str, 0, n)
    for _, p in parts {
        s += p.Kind
    }
    ret s
}