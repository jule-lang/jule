// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use env
use obj::{IR}
use conv for std::conv
use jule for std::jule
use build for std::jule::build::{
    Directive,
    Derive,
}
use std::jule::lex::{
    Token,
    TokenId,
    is_ignore_ident,
    is_anon_ident,
}
use std::jule::sema::{
    FuncPattern,
    Package,
    SymbolTable,
    Param,
    ParamIns,
    Trait,
    Struct,
    FieldIns,
    Var,
    StructIns,
    Fn,
    FnIns,
    TypeKind,
    Prim,
    Sptr,
    TypeSymbol,
}
use path for std::fs::path
use strings for std::strings
use std::time::{Time}

// Data offset of empty trait.
const EMPTY_TRAIT_OFFSET = 0x0

pub struct SerializationInfo {
    pub compiler:         str
    pub compiler_command: str
}

struct TraitHash {
    t: &Trait
    s: &StructIns
    i: int
}

pub struct ObjectCoder {
    // Internal buffer which is commonly used.
    pub obj: str

    ir:   &IR
    info: SerializationInfo
    tmap: []&TraitHash

    // Current indentation.
    indent_buffer: str

    ec: &ExprCoder
    sc: &ScopeCoder
}

impl ObjectCoder {
    pub static fn new(mut &ir: &IR, info: SerializationInfo): &ObjectCoder {
        let mut oc = &ObjectCoder{
            ir: ir,
            info: info,
        }
        oc.ec = ExprCoder.new(oc)
        oc.sc = ScopeCoder.new(oc)
        ret oc
    }

    fn write(mut &self, s: str) {
        self.obj += s
    }

    // Increase indentation.
    fn add_indent(mut &self) {
        const INDENT_KIND = "\t"
        self.indent_buffer += INDENT_KIND
    }

    // Decrase indentation.
    fn done_indent(mut &self) {
        self.indent_buffer = self.indent_buffer[:self.indent_buffer.len-1]
    }

    // Writes indention string by indent_buffer.
    fn indent(mut &self) {
        self.obj += self.indent_buffer
    }

    fn find_type_offset(self, t: &Trait, mut k: &TypeKind): int {
        if t.implemented.len == 0 {
            ret EMPTY_TRAIT_OFFSET
        }
        let mut s: &StructIns = nil
        if k.sptr() != nil {
            k = k.sptr().elem
        }
        if k.strct() == nil {
            ret -1
        }
        s = k.strct()
        for _, hash in self.tmap {
            if hash.t == t && hash.s == s {
                ret hash.i
            }
        }
        ret -1
    }

    // Writes location information of token as cstr bytes.
    fn loc_info(mut &self, &t: &Token): str {
        let mut loc = t.file.path

        // Normalize path if production compilation enabled.
        if env::PRODUCTION {
            match {
            | strings::has_prefix(loc, build::PATH_STDLIB):
                // Remove absolute path prefix of standard library.
                // Just keeps "std/" prefix.
                loc = loc[path::dir(build::PATH_STDLIB).len+1:]
            | strings::has_prefix(loc, self.ir.root):
                // Remove absolute path prefix of root package.
                // Just keeps "[package_dir]/" prefix.
                loc = loc[path::dir(self.ir.root).len+1:]
            }
        }
        loc += ":"
        loc += conv::itoa(t.row)
        loc += ":"
        loc += conv::itoa(t.column)
        ret cstr_bytes([]byte(loc))
    }

    fn head(mut &self) {
        let time = Time.now()
        let abs = time.abs()
        self.write("// Auto generated by JuleC.\n")
        self.write("// JuleC version: ")
        self.write(jule::VERSION)
        self.write("\n")
        self.write("// Date: ")
        self.write(conv::fmt_uint(abs.day, 10))
        self.write("/")
        self.write(conv::fmt_uint(abs.month, 10))
        self.write("/")
        self.write(conv::fmt_uint(abs.year, 10))
        self.write(" (DD/MM/YYYY) UTC\n//\n// Recomended Compile Command;\n// ")
        self.write(self.info.compiler)
        self.write(" ")
        self.write(self.info.compiler_command)
        self.write("\n\n")

        if env::PRODUCTION {
            self.write("#define __JULE_ENABLE__PRODUCTION\n")
        }
        if !env::RC {
            self.write("#define __JULE_DISABLE__REFERENCE_COUNTING\n")
        }
        if !env::SAFETY {
            self.write("#define __JULE_DISABLE__SAFETY\n")
        }
        self.write("\n\n#include \"")
        self.write(build::PATH_API)
        self.write("\"\n\n")
    }

    fn links(mut &self) {
        for _, used in self.ir.used {
            match {
            | !used.cpp_linked:
                continue
            | build::is_std_header_path(used.path):
                self.write("#include ")
                self.write(used.path)
                self.write("\n")
            |:
                self.write("#include \"")
                self.write(used.path)
                self.write("\"\n")
            }
        }
    }

    fn prepare_structures(mut &self) {
        for (_, mut s) in self.ir.ordered.structs {
            if !s.cpp_linked && s.token != nil {
                prepare_structure(s)
            }
        }
    }

    fn iter_packages(mut &self, f: fn(mut &pkg: &Package)) {
        for (_, mut used) in self.ir.used {
            if !used.cpp_linked {
                f(used.package)
            }
        }
        f(self.ir.main)
    }

    fn build_trait_map(mut &self) {
        self.iter_packages(fn(mut &pkg: &Package) {
            iter_files(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.traits {
                    if t.token == nil {
                        ret
                    }
                    if t.implemented.len == 0 {
                        self.tmap = append(self.tmap, &TraitHash{
                            t: t,
                            s: nil,
                            i: EMPTY_TRAIT_OFFSET,
                        })
                        continue
                    }
                    let mut i = 0
                    for (_, mut s) in t.implemented {
                        for (_, mut ins) in s.instances {
                            self.tmap = append(self.tmap, &TraitHash{
                                t: t,
                                s: ins,
                                i: i,
                            })
                            i++
                        }
                    }
                }
            })
        })
    }

    fn trait_decls(mut &self) {
        self.iter_packages(fn(mut &pkg: &Package) {
            iter_files(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.traits {
                    if t.token == nil {
                        ret
                    }
                    self.indent()
                    self.write("struct ")
                    self.write(IdentCoder.trait_decl(t))
                    self.write("{};\n")
                }
            })
        })
    }

    fn structure_plain_decl(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.instances {
            self.write("struct ")
            self.write(IdentCoder.structure_ins(ins))
            self.write(";\n")
        }
    }

    fn structure_plain_decls(mut &self) {
        for (_, mut s) in self.ir.ordered.structs {
            if !s.cpp_linked && s.token != nil {
                self.structure_plain_decl(s)
            }
        }
    }

    fn field_decl(mut &self, mut &f: &FieldIns) {
        self.write(TypeCoder.kind(f.kind))
        self.write(" ")
        self.write(IdentCoder.field(f.decl))
        self.write(" = ")
        if f.default == nil {
            // No default expression.
            // Use default expression of data-type.
            self.ec.init_expr(f.kind)
        } else {
            self.ec.expr(f.default.model)
        }
        self.write(";")
    }

    fn structure_constructor(mut &self, mut &s: &StructIns) {
        self.write(IdentCoder.structure_ins(s))
        self.write("(")
        if s.fields.len > 0 {
            for (i, mut f) in s.fields {
                self.write(TypeCoder.kind(f.kind))
                self.write(" __param_")
                self.write(f.decl.ident)
                if s.fields.len-i > 1 {
                    self.write(", ")
                }
            }
        } else {
            self.write("void")
        }

        self.write(")")
        if s.fields.len > 0 {
            self.write(": ")
            for i, f in s.fields {
                self.write(IdentCoder.field(f.decl))
                self.write("(")
                self.write("__param_")
                self.write(f.decl.ident)
                self.write(")")
                if s.fields.len-i > 1 {
                    self.write(", ")
                }
            }
        }
        self.write(" {}")
    }

    fn structure_destructor(mut &self, mut &s: &StructIns) {
        const STATIC = false                                   // Dispose method must be non-static
        let dispose_method = s.find_method("dispose", STATIC)
        let mut disposed = FuncPattern.dispose(dispose_method)
        // Call destructor if implemented.
        if !disposed {
            ret
        }
        self.write("~")
        self.write(IdentCoder.structure_ins(s))
        self.write("(void) { ")
        self.write(IdentCoder.func(dispose_method))
        self.write("(this); }")
    }

    fn structure_derive_defs_decls(mut &self, &s: &StructIns) {
        if s.decl.is_derives(Derive.Clone) {
            self.indent()
            self.write(DeriveCoder.clone_func_decl(s.decl))
            self.write(";\n\n")
        }
    }

    fn structure_operator_eq(mut &self, &ident: str, mut &s: &StructIns) {
        // Operator overloading.
        if s.operators.eq != nil {
            self.structure_operator(ident, s.operators.eq, "==")
            ret
        }

        self.indent()
        if env::OPT_INLINE {
            self.write("inline ")
        }
        self.write("bool operator==(")
        self.write(ident)
        self.write(" _other) {")
        if s.fields.len > 0 {
            self.add_indent()
            self.write("\n")
            self.indent()
            self.write("return ")
            self.add_indent()
            let mut writed = false
            for (_, mut f) in s.fields {
                // Skip C++-linked struct kinds.
                let strct = f.kind.strct()
                if strct != nil && strct.decl != nil && strct.decl.cpp_linked {
                    continue
                }

                if writed {
                    self.write(" &&")
                }
                writed = true
                self.write("\n")
                self.indent()
                self.write("this->")
                let f_ident = IdentCoder.field(f.decl)
                self.write(f_ident)
                self.write(" == _other.")
                self.write(f_ident)
            }
            self.done_indent()
            if !writed {
                self.write("true")
            }
            self.write(";\n")
            self.done_indent()
            self.indent()
            self.write("}")
        } else {
            self.write(" return true; }")
        }
        self.write("\n\n")
    }

    fn structure_operator_not_eq(mut &self, &ident: str, mut &s: &StructIns) {
        self.indent()
        if env::OPT_INLINE {
            self.write("inline ")
        }
        self.write("bool operator!=(")
        self.write(ident)
        self.write(" _other) { return !this->operator==(_other); }\n\n")
    }

    // Write operator overloading forwarding for reserved function.
    fn structure_operator(mut &self, &ident: str, mut &f: &FnIns, op: str) {
        if f == nil {
            ret
        }

        let unary = f.params.len == 1     // Just self parameter.
        let assignment = f.decl.is_void()

        self.indent()
        if env::OPT_INLINE {
            self.write("inline ")
        }
        if assignment {
            self.write(ident)
            self.write("&")
        } else {
            if f.result.prim() == nil {
                // If result type is not primitive, always structure's itself.
                self.write(ident)
            } else {
                // Logical.
                self.write(TypeCoder.Bool)
            }
        }
        self.write(" operator")
        self.write(op)
        self.write("(")
        if !unary {
            let mut p = f.params[1]
            self.write(TypeCoder.param_ins(p))
            self.write(" _other")
        }
        self.write(") { ")
        if !assignment {
            self.write("return ")
        }
        self.write(IdentCoder.func_ins(f))
        if !unary {
            self.write("(this, _other); ")
            if assignment {
                self.write("return *this; ")
            }
            self.write("}")
        } else {
            self.write("(this); }")
        }
        self.write("\n\n")
    }

    fn structure_operators(mut &self, mut &s: &StructIns) {
        let ident = IdentCoder.structure_ins(s)

        // Binary.
        self.structure_operator_eq(ident, s)
        self.structure_operator_not_eq(ident, s)
        self.structure_operator(ident, s.operators.gt, ">")
        self.structure_operator(ident, s.operators.gt_eq, ">=")
        self.structure_operator(ident, s.operators.lt, "<")
        self.structure_operator(ident, s.operators.lt_eq, "<=")
        self.structure_operator(ident, s.operators.shl, "<<")
        self.structure_operator(ident, s.operators.shr, ">>")
        self.structure_operator(ident, s.operators.add, "+")
        self.structure_operator(ident, s.operators.sub, "-")
        self.structure_operator(ident, s.operators.div, "/")
        self.structure_operator(ident, s.operators.mul, "*")
        self.structure_operator(ident, s.operators.mod, "%")
        self.structure_operator(ident, s.operators.bit_and, "&")
        self.structure_operator(ident, s.operators.bit_or, "|")
        self.structure_operator(ident, s.operators.bit_xor, "^")

        // Unary.
        self.structure_operator(ident, s.operators.neg, "-")
        self.structure_operator(ident, s.operators.pos, "+")
        self.structure_operator(ident, s.operators.bit_not, "~")

        // Assignment.
        self.structure_operator(ident, s.operators.add_assign, "+=")
        self.structure_operator(ident, s.operators.sub_assign, "-=")
        self.structure_operator(ident, s.operators.div_assign, "/=")
        self.structure_operator(ident, s.operators.mul_assign, "*=")
        self.structure_operator(ident, s.operators.mod_assign, "%=")
        self.structure_operator(ident, s.operators.shl_assign, "<<=")
        self.structure_operator(ident, s.operators.shr_assign, ">>=")
        self.structure_operator(ident, s.operators.bit_or_assign, "|=")
        self.structure_operator(ident, s.operators.bit_and_assign, "&=")
        self.structure_operator(ident, s.operators.bit_xor_assign, "^=")
    }

    fn structure_ins_decl(mut &self, mut &s: &StructIns) {
        if s.methods.len > 0 {
            for (_, mut m) in s.methods {
                self.func_decl(m, false)
            }
        }

        self.write("struct ")
        let out_ident = IdentCoder.structure_ins(s)

        self.write(out_ident)
        self.write(" {\n")

        self.add_indent()
        if s.fields.len > 0 {
            for (_, mut f) in s.fields {
                self.indent()
                self.field_decl(f)
                self.write("\n")
            }
            self.write("\n\n")
            self.indent()
            self.structure_constructor(s)
            self.write("\n\n")
        }

        self.indent()
        self.structure_destructor(s)
        self.write("\n\n")

        // Default constructor.
        self.indent()
        self.write(out_ident)
        self.write("(void) = default;\n\n")

        self.structure_derive_defs_decls(s)

        self.structure_operators(s)
        self.write("\n")

        self.done_indent()
        self.indent()
        self.write("};")
    }

    fn structure_decl(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.instances {
            self.structure_ins_decl(ins)
        }
    }

    fn structure_decls(mut &self) {
        for (_, mut s) in self.ir.ordered.structs {
            if !s.cpp_linked && s.token != nil {
                self.structure_decl(s)
                self.write("\n")
            }
        }
    }

    fn params_decls(mut &self, mut &params: []&ParamIns) {
        if params.len == 0 {
            self.write("(void)")
            ret
        }

        self.write("(")
        for (i, mut p) in params {
            self.write(TypeCoder.param_ins(p))
            if params.len-i > 1 {
                self.write(", ")
            }
        }

        self.write(")")
    }

    fn func_head(mut &self, mut &f: &FnIns, ptr: bool) {
        if !ptr && env::OPT_INLINE && !f.decl.is_entry_point() {
            self.write("inline ")
        }
        self.write(TypeCoder.func_ins_result(f))
        if ptr {
            self.write("(*")
            self.write(IdentCoder.func_ins(f))
            self.write(")")
        } else {
            self.write(" ")
            self.write(IdentCoder.func_ins(f))
        }
    }

    fn func_decl(mut &self, mut &f: &Fn, ptr: bool) {
        for (_, mut c) in f.instances {
            self.indent()
            self.func_head(c, ptr)
            self.params_decls(c.params)
            self.write(";\n")
        }
    }

    fn func_decls(mut &self) {
        self.iter_packages(fn(mut &pkg: &Package) {
            iter_files(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut f) in file.funcs {
                    if !f.cpp_linked && f.token != nil {
                        self.func_decl(f, false)
                    }
                }
            })
        })
    }

    fn trait_data_types(mut &self) {
        self.iter_packages(fn(mut &pkg: &Package) {
            iter_files(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.traits {
                    if t.token == nil {
                        ret
                    }
                    self.write("struct ")
                    self.write(IdentCoder.trait_decl(t))
                    self.write("MptrData")
                    self.write(" {\n")
                    self.add_indent()
                    for (_, mut m) in t.methods {
                        let mut ins = m.instances[0]
                        let mut p = ins.params[0]
                        p.kind = &TypeKind{
                            kind: t,
                        }
                        for (i, mut ip) in ins.params[1:] {
                            if is_anon_ident(ip.decl.ident) {
                                ip.decl.ident = "_" + conv::itoa(i)
                            }
                        }
                        if !env::PRODUCTION {
                            ins.params = append(ins.params, &ParamIns{
                                decl: &Param{
                                    ident: "__file",
                                },
                                kind: &TypeKind{
                                    kind: &CustomType{
                                        kind: "const char*",
                                    },
                                },
                            })
                        }
                        self.func_decl(m, true)
                    }
                    self.done_indent()
                    self.indent()
                    self.write("};\n\n")
                }
            })
        })
    }

    fn param_ins(mut &self, mut &p: &ParamIns) {
        self.write(TypeCoder.param_ins(p))
        self.write(" ")
        self.write(IdentCoder.param(p.decl))
    }

    fn params_ins(mut &self, mut &params: []&ParamIns) {
        if params.len == 0 {
            self.write("(void)")
            ret
        }
        self.write("(")
        for (i, mut p) in params {
            self.param_ins(p)
            if params.len-i > 1 {
                self.write(", ")
            }
        }
        self.write(")")
    }

    fn var_init_expr(mut &self, mut &v: &Var, init: fn()) {
        if v.statically {
            self.write("static ")
        }

        self.write(TypeCoder.kind(v.kind.kind))
        self.write(" ")
        if v.reference {
            self.write("&")
        }
        self.write(IdentCoder.var(v))
        if init != nil {
            self.write(" = ")
            init()
        }
        self.write(";")
    }

    fn var(mut &self, mut v: &Var) {
        if is_ignore_ident(v.ident) {
            ret
        }
        if v.value != nil && v.value.expr != nil {
            if v.value.data.model != nil {
                self.var_init_expr(v, fn() { self.ec.val(v.value) })
                ret
            }
            self.var_init_expr(v, nil)
            ret
        }
        self.var_init_expr(v, fn() { self.ec.init_expr(v.kind.kind) })
    }

    fn func(mut &self, mut &f: &Fn) {
        for (_, mut ins) in f.instances {
            self.func_head(ins, false)
            self.params_ins(ins.params)
            self.write(" ")
            self.sc.func_scope(ins)
            if ins.scope != nil {
                self.write("\n\n")
            }
        }
    }

    fn trait_wrappers(mut &self) {
        for (_, mut hash) in self.tmap {
            for (_, mut m) in hash.t.methods {
                let ident = m.ident

                m.instances[0].scope = nil
                m.ident = ident + "_" + conv::itoa(hash.i)
                self.func(m)
                m.ident = ident

                if hash.s == nil {
                    if env::PRODUCTION {
                        self.write(" { jule::panic(__JULE_ERROR__INVALID_MEMORY); }\n")
                    } else {
                        self.write(" { jule::panic(" + TypeCoder.Str + "(__JULE_ERROR__INVALID_MEMORY) + " + TypeCoder.Str + "(_00___file)); }\n")
                    }
                    continue
                }

                let ptr = !m.params[0].is_ref()

                let mut sm = hash.s.find_method(m.ident, false)
                if sm == nil || sm.instances.len == 0 {
                    continue
                }

                self.add_indent()
                self.write("{\n")
                self.indent()
                if !sm.is_void() {
                    self.write("return ")
                }
                self.write(IdentCoder.func(sm))
                self.write("(")
                if ptr {
                    self.write("_self_.safe_ptr<")
                    self.write(TypeCoder.structure_ins(hash.s))
                    self.write(">(")
                    if !env::PRODUCTION {
                        self.write("_00___file")
                    }
                    self.write(")")
                } else {
                    self.write("_self_.data.as<")
                    self.write(TypeCoder.structure(sm.owner))
                    self.write(">()")
                }
                for _, mp in m.params[1:] {
                    self.write(", ")
                    self.write(IdentCoder.param(mp))
                }
                self.write(");\n}\n")
                self.done_indent()
            }
        }
    }

    fn trait_datas(mut &self) {
        let mut old: &Trait = nil
        for (_, mut hash) in self.tmap {
            let ident = IdentCoder.trait_decl(hash.t)
            if hash.t != old {
                if old != nil {
                    self.done_indent()
                    self.indent()
                    self.write("};\n")
                }
                self.write("static ")
                self.write(ident)
                self.write("MptrData ")
                self.write(ident)
                self.write("_mptr_data[] = {\n")
                old = hash.t
                self.add_indent()
            }
            self.indent()
            self.write("{\n")
            self.add_indent()
            for (_, mut m) in hash.t.methods {
                let m_ident = IdentCoder.func(m)
                self.indent()
                self.write(".")
                self.write(m_ident)
                self.write("=")
                self.write(m_ident)
                self.write("_")
                self.write(conv::itoa(hash.i))
                self.write(",\n")
            }
            self.done_indent()
            self.indent()
            self.write("},\n")
        }
        if old != nil {
            self.done_indent()
            self.indent()
            self.write("};\n")
        }
    }

    fn globals(mut &self) {
        self.iter_packages(fn(mut &pkg: &Package) {
            iter_files(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut v) in file.vars {
                    if v.token == nil || v.cpp_linked || v.constant {
                        continue
                    }
                    self.write(TypeCoder.kind(v.kind.kind))
                    self.write(" ")
                    if v.reference {
                        self.write("&")
                    }
                    self.write(IdentCoder.var(v))
                    self.write(";\n")
                }
            })
        })
    }

    fn decls(mut &self) {
        self.trait_decls()
        self.structure_plain_decls()
        self.structure_decls()
        self.func_decls()
        self.write("\n\n")
        self.trait_data_types()
        self.write("\n\n")
        self.trait_wrappers()
        self.write("\n\n")
        self.trait_datas()
        self.write("\n\n")
        self.globals()
    }

    fn structure_methods(mut &self, mut &s: &StructIns) {
        for (_, mut f) in s.methods {
            self.func(f)
            self.write("\n\n")
        }
    }

    fn structure_derive_defs(mut &self, mut &s: &StructIns) {
        if s.decl.is_derives(Derive.Clone) {
            self.write(DeriveCoder.clone_func_def(s.decl))
            self.write("{\n")
            self.add_indent()
            self.indent()
            self.write(TypeCoder.structure_ins(s))
            self.write(" clone;\n")
            for _, f in s.fields {
                let ident = IdentCoder.field(f.decl)
                self.indent()
                self.write("clone.")
                self.write(ident)
                self.write(" = jule::clone(this->")
                self.write(ident)
                self.write(");\n")
            }
            self.indent()
            self.write("return clone;\n")
            self.done_indent()
            self.write("}")
        }
    }

    fn structure_ostream(mut &self, mut &s: &StructIns) {
        self.indent()
        self.write("std::ostream &operator<<(std::ostream &_Stream, ")
        self.write(IdentCoder.structure_ins(s))
        self.write(" _Src) {\n")
        self.add_indent()
        self.indent()

        let mut fts = s.find_method("to_str", false)
        if FuncPattern.to_str(fts) {
            self.write("_Stream << ")
            self.write(IdentCoder.func(fts))
            self.write("(&_Src);\n")
        } else {
            self.write(`_Stream << "`)
            self.write(s.decl.ident)
            self.write("{\";\n")

            for (i, mut f) in s.fields {
                self.indent()
                self.write(`_Stream << "`)
                self.write(f.decl.ident)
                self.write(`:`)

                // Skip C++-linked struct kinds.
                let strct = f.kind.strct()
                if strct != nil && strct.decl != nil && strct.decl.cpp_linked {
                    self.write(` cpp.`)
                    self.write(IdentCoder.field(f.decl))
                    self.write(`"`)
                } else {
                    self.write(`" << _Src.`)
                    self.write(IdentCoder.field(f.decl))
                }
                if i+1 < s.fields.len {
                    self.write(" << \", \"")
                }
                self.write(";\n")
            }

            self.indent()
            self.write("_Stream << \"}\";\n")
        }

        self.indent()
        self.write("return _Stream;\n")

        self.done_indent()
        self.write("}")
    }

    fn structure_ins(mut &self, mut &s: &StructIns) {
        self.structure_methods(s)
        self.write("\n\n")
        self.structure_derive_defs(s)
        self.write("\n\n")
        self.structure_ostream(s)
    }

    fn structure(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.instances {
            self.structure_ins(ins)
            self.write("\n\n")
        }
    }

    fn structures(mut &self) {
        for (_, mut s) in self.ir.ordered.structs {
            if !s.cpp_linked && s.token != nil {
                self.structure(s)
                self.write("\n\n")
            }
        }
    }

    fn funcs(mut &self) {
        self.iter_packages(fn(mut &pkg: &Package) {
            iter_files(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut f) in file.funcs {
                    if !env::TEST && has_directive(f.directives, Directive.Test) {
                        continue
                    }
                    if !f.cpp_linked && f.token != nil {
                        self.func(f)
                        self.write("\n\n")
                    }
                }
            })
        })
    }

    fn push_init(mut &self, mut &pkg: &Package) {
        iter_files(pkg, fn(mut &file: &SymbolTable) {
            for _, f in file.funcs {
                if f.ident == build::INIT_FN {
                    self.indent()
                    self.write(IdentCoder.func(f))
                    self.write("();\n")
                }
            }
        })
    }

    fn global_initializers(mut &self) {
        self.iter_packages(fn(mut &pkg: &Package) {
            iter_files(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut v) in file.vars {
                    if v.token == nil || v.cpp_linked || v.constant {
                        continue
                    }
                    self.indent()
                    self.write(IdentCoder.var(v))
                    if v.value != nil && v.value.expr != nil {
                        if v.value.data.model != nil {
                            self.write(" = ")
                            self.ec.val(v.value)
                        }
                    } else {
                        self.write(" = ")
                        self.ec.init_expr(v.kind.kind)
                    }
                    self.write(";\n")
                }
            })
        })
    }

    fn init_caller(mut &self) {
        self.write("void " + INIT_CALLER_IDENT + "(void) {\n")
        self.add_indent()
        self.global_initializers()
        self.iter_packages(fn(mut &pkg: &Package) {
            self.push_init(pkg)
        })
        self.done_indent()
        self.write("\n}")
    }

    fn end(mut &self) {
        self.write(`int main(int argc, char *argv[], char *envp[]) {
    jule::setup_argv(argc, argv);
    jule::setup_envp(envp);

    __jule_call_initializers();
    `)

        if env::TEST {
            self.write("test_point();")
        } else {
            self.write("entry_point();")
        }

        self.write(`

    return EXIT_SUCCESS;
}`)
    }

    fn serialize_head(mut &self) {
        self.prepare_structures()
        self.build_trait_map()
        self.head()
        self.links()
        self.write("\n")
        self.decls()
        self.write("\n")
        self.structures()
        self.funcs()
        self.init_caller()
        self.write("\n\n")
    }

    pub fn serialize(mut &self) {
        self.serialize_head()
        self.end()
    }
}

fn iter_files(mut &pkg: &Package, f: fn(mut &f: &SymbolTable)) {
    for (_, mut file) in pkg.files {
        f(file)
    }
}

fn prepare_structure(mut &s: &Struct) {
    for (_, mut ins) in s.instances {
        for (_, mut m) in ins.methods {
            if m.statically {
                continue
            }
            for (_, mut ins) in m.instances {
                let mut p = ins.params[0]
                if !p.decl.is_ref() {
                    p.kind = &TypeKind{
                        kind: &CustomType{
                            kind: TypeCoder.as_ptr(TypeCoder.kind(p.kind)),
                        },
                    }
                } else {
                    p.kind = &TypeKind{
                        kind: &CustomType{
                            kind: TypeCoder.kind(p.kind),
                        },
                    }
                }
            }
        }
    }
}

// Concatenate all strings into single string.
fn concat_all_parts(parts: ...&Token): str {
    let mut s = ""
    for _, p in parts {
        s += p.kind
    }
    ret s
}