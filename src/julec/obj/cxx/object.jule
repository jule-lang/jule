// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use env
use opt
use obj::{IR}
use std::unsafe
use conv for std::conv
use comptime for std::comptime
use jule for std::jule
use build for std::jule::build::{
    Directive,
}
use std::jule::lex::{
    Token,
    TokenId,
    IsIgnoreIdent,
    IsAnonIdent,
}
use std::jule::sema::{
    FuncPattern,
    Package,
    SymbolTable,
    Param,
    ParamIns,
    Trait,
    Struct,
    FieldIns,
    Var,
    StructIns,
    Fn,
    FnIns,
    TypeKind,
    Prim,
    Sptr,
    TypeSymbol,
    Operators,
    AnonFnExprModel,
}
use path for std::fs::path
use strings for std::strings::{StrBuilder}
use std::time::{Time}

// Data offset of empty trait.
const emptyTraitOffset = 0x0

const ctxParamIdent = "__f_ctx"
const anonFnCtxSuffix = "_ctx"                              // Anon fn identifier suffix for ctx struct identifier.
const anonFnCtxHandlerSuffix = anonFnCtxSuffix + "_handler" // Anon fn identifier suffix for ctx allocation handler.
const anyTypeIdent = "__jule_any_type"
const indentKind = '\t'

struct SerializationInfo {
    Compiler:        str
    CompilerCommand: str
}

struct traitHash {
    t:  &Trait
    ti: str // ASCII-safe identifier of trait.
    s:  &StructIns
    i:  int
}

struct traitCast {
    t1: &Trait
    t2: &Trait
}

struct anonHash {
    expr:  &AnonFnExprModel
    ident: str
}

struct ObjectCoder {
    // Internal buffer which is commonly used.
    Buf: StrBuilder

    resultDecls: StrBuilder // Struct wrappers for multi-ret function types.
    anyObj:      StrBuilder // Type handlers and others for the <any> type.
    anonObj:     StrBuilder // Anonymous functions.

    ir:   &IR
    info: SerializationInfo
    tmap: []&traitHash
    anons: []&anonHash

    // Current indentation.
    indentBuffer: []byte

    resultMap:    map[str]bool
    anyTypeMap:   []&TypeKind
    traitCastMap: []traitCast

    ec: &exprCoder
    sc: &scopeCoder
    tc: &typeCoder

    headPos: int
    declPos: int
}

impl ObjectCoder {
    static fn New(mut &ir: &IR, info: SerializationInfo): &ObjectCoder {
        mut oc := &ObjectCoder{
            ir: ir,
            info: info,
        }
        oc.ec = exprCoder.new(oc)
        oc.sc = scopeCoder.new(oc)
        oc.tc = typeCoder.new(oc)
        ret oc
    }

    fn write(mut &self, s: str) {
        self.Buf.WriteStr(s)
    }

    fn writeBytes(mut &self, b: []byte) {
        self.Buf.Write(b)
    }

    // Increase indentation.
    fn addIndent(mut &self) {
        self.indentBuffer = append(self.indentBuffer, indentKind)
    }

    // Decrase indentation.
    fn doneIndent(mut &self) {
        self.indentBuffer = self.indentBuffer[:len(self.indentBuffer)-1]
    }

    // Writes indention string by indentBuffer.
    fn indent(mut &self) {
        self.Buf.Write(self.indentBuffer)
    }

    fn findAnyType(mut &self, mut &t: &TypeKind): int {
        for (i, mut at) in self.anyTypeMap {
            if at.Equal(t) {
                ret i
            }
        }
        ret -1
    }

    fn pushAnonFn(mut &self, mut &m: &AnonFnExprModel): (ident: str) {
        closure := isClosure(m)
        if closure { // Closure?
            // Handle identifier and generate ctx.
            self.anonObj.WriteStr("struct ")
            l := self.anonObj.Len()
            self.anonObj.WriteStr("__jule_anon_")
            self.anonObj.WriteStr(conv::FmtUint(u64(uintptr(m.Func)), 0xF))
            ident = str(unsafe { self.anonObj.Buf()[l:] })
            self.anonObj.WriteStr(anonFnCtxSuffix + "{\n")
            for (_, mut v) in m.Captured {
                self.anonObj.WriteByte(indentKind) // 1x indent
                self.tc.kind(self.anonObj, v.Kind.Kind)
                self.anonObj.WriteByte(' ')
                if v.Reference {
                    self.anonObj.WriteByte('*')
                }
                identCoder.var(self.anonObj, v)
                self.anonObj.WriteStr(";\n")
            }
            self.anonObj.WriteStr("};\n")

            // Ctx handler function.
            self.anonObj.WriteStr("static void ")
            self.anonObj.WriteStr(ident)
            self.anonObj.WriteStr(anonFnCtxHandlerSuffix + "(jule::Ptr<" + typeCoder.Uintptr + "> &ptr) { ptr.__as<")
            self.anonObj.WriteStr(ident)
            self.anonObj.WriteStr(anonFnCtxSuffix + ">().dealloc(); }\n")
        } else {
            ident = "__jule_anon"
            ident += conv::FmtUint(u64(uintptr(m.Func)), 0xF)
        }

        // Anonymous function.
        self.anons = append(self.anons, &anonHash{expr: m, ident: ident})
        self.anonFuncInsDecl(m, ident)
        self.anonObj.WriteByte('\n')
        ret
    }

    fn pushAnyType(mut &self, mut t: &TypeKind): int {
        if t.Enum() != nil {
            t = t.Enum().Kind.Kind
        }
        mut i := self.findAnyType(t)
        if i != -1 {
            ret i
        }
        i = len(self.anyTypeMap)
        self.anyTypeMap = append(self.anyTypeMap, t)
        si := conv::Itoa(i)
        if t.Sptr() != nil {
            mut elemKind := StrBuilder.New(40)
            self.tc.kind(elemKind, t.Sptr().Elem)

            // dealloc function.
            self.anyObj.WriteStr("void " + anyTypeIdent)
            self.anyObj.WriteStr(si)
            self.anyObj.WriteStr("_dealloc(jule::Ptr<jule::Uintptr> &alloc) noexcept { alloc.__as<")
            self.anyObj.Write(unsafe { elemKind.Buf() })
            self.anyObj.WriteStr(">().dealloc(); }\n")

            // Type structure.
            self.anyObj.WriteStr("struct " + typeCoder.Any + "::Type ")
            self.anyObj.WriteStr(anyTypeIdent)
            self.anyObj.WriteStr(si)
            self.anyObj.WriteStr("{.dealloc=" + anyTypeIdent)
            self.anyObj.WriteStr(si)
            self.anyObj.WriteStr("_dealloc, .eq=jule::ptr_equal, .to_str=jule::ptr_to_str};\n")

            // comparison function.
            self.anyObj.WriteStr(typeCoder.Bool + " " + anyTypeIdent)
            self.anyObj.WriteStr(si)
            self.anyObj.WriteStr("_compare(const " + typeCoder.Any + " &any, const ")
            self.tc.asSptr(self.anyObj, unsafe { elemKind.Buf() })
            self.anyObj.WriteStr(" &other) { return any.type == &" + anyTypeIdent)
            self.anyObj.WriteStr(si)
            self.anyObj.WriteStr(" && jule::ptr_equal(any.data.alloc, other.alloc); }\n")
        } else {
            comparable := t.Comparable()
            mut kindB := StrBuilder.New(40)
            self.tc.kind(kindB, t)
            kind := unsafe { kindB.Buf() }
            if unsafe::BytesStr(kind) == "[<unimplemented_type_kind>]" {
                outln(t.Str())
            }

            // dealloc function.
            self.anyObj.WriteStr("void " + anyTypeIdent)
            self.anyObj.WriteStr(si)
            self.anyObj.WriteStr("_dealloc(jule::Ptr<jule::Uintptr> &alloc) noexcept { alloc.__as<")
            self.anyObj.Write(kind)
            self.anyObj.WriteStr(">().dealloc(); }\n")

            if comparable {
                // eq function.
                self.anyObj.WriteStr(typeCoder.Bool + " " + anyTypeIdent)
                self.anyObj.WriteStr(si)
                self.anyObj.WriteStr("_eq(void *alloc, void *other) noexcept { return *reinterpret_cast<")
                self.anyObj.Write(kind)
                self.anyObj.WriteStr("*>(alloc) == *reinterpret_cast<")
                self.anyObj.Write(kind)
                self.anyObj.WriteStr("*>(other); }\n")
            }

            // to_str function.
            self.anyObj.WriteStr(typeCoder.Str + " " + anyTypeIdent)
            self.anyObj.WriteStr(si)
            self.anyObj.WriteStr("_to_str(const void *alloc) noexcept { return jule::to_str(*reinterpret_cast<")
            if t.Ptr() == nil {
                self.anyObj.WriteStr("const ")
                self.anyObj.Write(kind)
            } else {
                self.anyObj.Write(kind)
                self.anyObj.WriteStr("* const")
            }
            self.anyObj.WriteStr("*>(alloc)); }\n")

            // Type structure.
            self.anyObj.WriteStr("struct " + typeCoder.Any + "::Type ")
            self.anyObj.WriteStr(anyTypeIdent)
            self.anyObj.WriteStr(si)
            self.anyObj.WriteStr("{.dealloc=" + anyTypeIdent)
            self.anyObj.WriteStr(si)
            self.anyObj.WriteStr("_dealloc, ")
            if comparable {
                self.anyObj.WriteStr(".eq=" + anyTypeIdent)
                self.anyObj.WriteStr(si)
                self.anyObj.WriteStr("_eq, ")
            }
            self.anyObj.WriteStr(".to_str=" + anyTypeIdent)
            self.anyObj.WriteStr(si)
            self.anyObj.WriteStr("_to_str};\n")

            if comparable {
                // compare function.
                self.anyObj.WriteStr(typeCoder.Bool + " " + anyTypeIdent)
                self.anyObj.WriteStr(si)
                self.anyObj.WriteStr("_compare(const " + typeCoder.Any + " &any, const ")
                self.anyObj.Write(kind)
                self.anyObj.WriteStr(" &other) { return any.type == &" + anyTypeIdent)
                self.anyObj.WriteStr(si)
                self.anyObj.WriteStr(" && " + anyTypeIdent)
                self.anyObj.WriteStr(si)
                self.anyObj.WriteStr("_eq(any.data.alloc, (void*)&other); }\n")
            }
        }
        ret i
    }

    fn pushResultIns(mut &self, mut &f: &FnIns) {
        s := str(self.tc.rc.code(f.Result))
        _, ok := self.resultMap[s]
        if ok {
            ret
        }
        self.resultMap[s] = false
        self.resultDecls.WriteStr("struct ")
        self.resultDecls.WriteStr(s)
        self.resultDecls.WriteStr(" {\n")
        for (i, mut t) in f.Result.Tup().Types {
            self.resultDecls.WriteByte(indentKind)
            self.tc.kind(self.resultDecls, t)
            self.resultDecls.WriteByte(' ')
            self.resultDecls.WriteStr(resultArgName)
            self.resultDecls.WriteStr(conv::Itoa(i))
            self.resultDecls.WriteStr(";\n")
        }
        self.resultDecls.WriteStr("};\n")
    }

    fn pushResult(mut &self, mut &f: &Fn) {
        if f.IsVoid() || len(f.Result.Idents) <= 1 {
            ret
        }
        mut n := len(f.Instances)
        if len(f.Generics) == 0 {
            n = 1
        }
        for (_, mut ins) in f.Instances[:n] {
            self.pushResultIns(ins)
        }
    }

    fn findTypeOffsetS(self, t: &Trait, mut s: &StructIns): int {
        if len(t.Implemented) == 0 {
            ret emptyTraitOffset
        }
        for _, hash in self.tmap {
            if hash.t == t && hash.s == s {
                ret hash.i
            }
        }
        ret -1
    }

    fn findTypeOffset(self, t: &Trait, mut k: &TypeKind): int {
        if len(t.Implemented) == 0 {
            ret emptyTraitOffset
        }
        let mut s: &StructIns = nil
        if k.Sptr() != nil {
            k = k.Sptr().Elem
        }
        s = k.Struct()
        if s == nil {
            ret -1
        }
        ret self.findTypeOffsetS(t, s)
    }

    fn pushAndWriteMaskMapper(mut &self, mut t1: &Trait, mut t2: &Trait) {
        mut ident := StrBuilder.New(1 << 5)
        ident.WriteStr("__jule_trait_offset_mapper_")
        ident.WriteStr(conv::FmtUint(u64(uintptr(t2)), 0xF))
        ident.WriteStr("_to_")
        ident.WriteStr(conv::FmtUint(u64(uintptr(t1)), 0xF))
        self.Buf.Write(unsafe { ident.Buf() })

        // Lookup and push if this match is not exist.
        for _, m in self.traitCastMap {
            if m.t1 == t1 && m.t2 == t2 {
                ret
            }
        }

        self.traitCastMap = append(self.traitCastMap, traitCast{t1: t1, t2: t2})

        // Not exist, push.
        //
        // TODO:
        //  As partially confirmed by the experiments, the same mapping conditions
        //  apply for two traits that casting into each other. It was decided that
        //  additional investigation was needed to conclusively confirm this.
        const offset = "offset"
        self.anyObj.WriteStr(typeCoder.Int)
        self.anyObj.WriteByte(' ')
        self.anyObj.Write(unsafe { ident.Buf() })
        self.anyObj.WriteStr("(const " + typeCoder.Int + " " + offset + ") noexcept { ")
        for (_, mut s1) in t1.Implemented {
            for _, s2 in t2.Implemented {
                if s1 == s2 {
                    for (_, mut s1i) in s1.Instances {
                        i1 := self.findTypeOffsetS(t1, s1i)
                        i2 := self.findTypeOffsetS(t2, s1i)
                        self.anyObj.WriteStr("if (offset == ")
                        self.anyObj.WriteStr(conv::Itoa(i2))
                        self.anyObj.WriteStr(") return ")
                        self.anyObj.WriteStr(conv::Itoa(i1))
                        self.anyObj.WriteStr("; ")
                    }
                }
            }
        }
        self.anyObj.WriteStr(" return ")
        self.anyObj.WriteStr(conv::Itoa(emptyTraitOffset))
        self.anyObj.WriteStr("; }\n")
    }

    // Writes location information of token as cstr bytes.
    fn locInfo(mut &self, &t: &Token) {
        &loc := t.File.Path

        // Normalize path if production compilation enabled.
        if env::Production {
            match {
            | strings::HasPrefix(loc, build::PathStdlib):
                // Remove absolute path prefix of standard library.
                // Just keeps "std/" prefix.
                cstrBytes(self.Buf, loc[len(path::Dir(build::PathStdlib))+1:])
            | strings::HasPrefix(loc, self.ir.Root):
                // Remove absolute path prefix of root package.
                // Just keeps "[package_dir]/" prefix.
                cstrBytes(self.Buf, loc[len(path::Dir(self.ir.Root))+1:])
            |:
                cstrBytes(self.Buf, loc)
            }
        } else {
            cstrBytes(self.Buf, loc)
        }
        self.write(":")
        self.write(conv::Itoa(t.Row))
        self.write(":")
        self.write(conv::Itoa(t.Column))
    }

    fn head(mut &self) {
        time := Time.Now()
        abs := time.Abs()
        self.write("// Auto generated by JuleC.\n")
        self.write("// JuleC version: ")
        self.write(jule::Version)
        self.write("\n")
        self.write("// Date: ")
        self.write(conv::FmtUint(abs.Day, 10))
        self.write("/")
        self.write(conv::FmtUint(abs.Month, 10))
        self.write("/")
        self.write(conv::FmtUint(abs.Year, 10))
        self.write(" (DD/MM/YYYY) UTC\n//\n// Recomended Compile Command;\n// ")
        self.write(self.info.Compiler)
        self.write(" ")
        self.write(self.info.CompilerCommand)
        self.write("\n\n")

        if env::Production {
            self.write("#define __JULE_ENABLE__PRODUCTION\n")
        }
        if !env::RC {
            self.write("#define __JULE_DISABLE__REFERENCE_COUNTING\n")
        }
        if !env::Safety {
            self.write("#define __JULE_DISABLE__SAFETY\n")
        }

        // Include binded libraries here, before the API header.
        // See developer reference (4).
        self.links()

        self.write("\n\n#include \"")
        self.write(build::PathApi)
        self.write("\"\n\n")
    }

    fn links(mut &self) {
        for _, used in self.ir.Used {
            match {
            | !used.Binded:
                continue
            | build::IsStdHeaderPath(used.Path):
                self.write("#include ")
                self.write(used.Path)
                self.write("\n")
            | build::IsValidHeaderExt(path::Ext(used.Path)):
                self.write("#include \"")
                self.write(used.Path)
                self.write("\"\n")
            }
        }
    }

    fn prepareStructure(mut self, mut &s: &Struct) {
        for (_, mut ins) in s.Instances {
            for (_, mut m) in ins.Methods {
                if m.Statically {
                    continue
                }
                for (_, mut mins) in m.Instances {
                    mut p := mins.Params[0]
                    mut kind := StrBuilder.New(40)
                    self.tc.kind(kind, p.Kind)
                    if !p.Decl.IsRef() {
                        kind.WriteStr("*")
                    }
                    p.Kind = &TypeKind{
                        Kind: &customType{
                            kind: kind.Str(),
                        },
                    }
                }
            }
        }
    }

    fn prepareStructures(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                self.prepareStructure(s)
            }
        }
    }

    fn iterPackages(mut &self, f: fn(mut &pkg: &Package)) {
        for (_, mut used) in self.ir.Used {
            if !used.Binded {
                f(used.Package)
            }
        }
        f(self.ir.Main)
    }

    fn buildTraitMap(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.Traits {
                    if t.Token == nil {
                        ret
                    }
                    if len(t.Implemented) == 0 {
                        mut hash := &traitHash{
                            t: t,
                            s: nil,
                            i: emptyTraitOffset,
                        }
                        mut b := StrBuilder.New(len(t.Ident))
                        identCoder.writeIdentTo(b, t.Ident)
                        hash.ti = b.Str()
                        self.tmap = append(self.tmap, hash)
                        continue
                    }
                    mut i := 0
                    for (_, mut s) in t.Implemented {
                        for (_, mut ins) in s.Instances {
                            mut hash := &traitHash{
                                t: t,
                                s: ins,
                                i: i,
                            }
                            mut b := StrBuilder.New(len(t.Ident))
                            identCoder.writeIdentTo(b, t.Ident)
                            hash.ti = b.Str()
                            self.tmap = append(self.tmap, hash)
                            i++
                        }
                    }
                    // Push all methods to t from t's inheritances.
                    // Because they will be used for trait data generation.
                    pushMethodsFromInherits(t, t)
                }
            })
        })
    }

    fn traitDecls(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.Traits {
                    if t.Token == nil {
                        ret
                    }
                    self.indent()
                    self.write("struct ")
                    identCoder.traitDecl(self.Buf, t)
                    self.write("{};\n")
                }
            })
        })
    }

    fn structurePlainDecl(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.Instances {
            self.write("struct ")
            identCoder.structureIns(self.Buf, ins)
            self.write(";\n")
        }
    }

    fn structurePlainDecls(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                self.structurePlainDecl(s)
            }
        }
    }

    fn fieldDecl(mut &self, mut &f: &FieldIns) {
        self.tc.kind(self.Buf, f.Kind)
        self.write(" ")
        identCoder.field(self.Buf, f.Decl)
        if f.Default == nil {
            if shouldInitialized(f.Kind) {
                self.write(" = ")
                // No default expression.
                // Use default expression of data-type.
                self.ec.initExpr(f.Kind)
            }
        } else {
            self.write(" = ")
            self.ec.possibleRefExpr(f.Default.Model)
        }
        self.write(";")
    }

    fn structureDestructor(mut &self, mut &s: &StructIns) {
        // Dispose method must be non-static
        const Static = false
        disposeMethod := s.FindMethod("Dispose", Static)
        mut disposed := FuncPattern.Dispose(disposeMethod)
        // Call destructor if implemented.
        if !disposed {
            ret
        }
        self.write("~")
        identCoder.structureIns(self.Buf, s)
        self.write("(void) { ")
        identCoder.func(self.Buf, disposeMethod)
        self.write("(this); }")
    }

    fn structureOperatorEq(mut &self, ident: []byte, mut &s: &StructIns) {
        if !s.Comparable {
            ret
        }
        // Operator overloading.
        if s.Operators.Eq != nil {
            self.structureOperator(ident, s.Operators.Eq, "==")
            ret
        }

        self.indent()
        if opt::Inline {
            self.write("inline ")
        }
        self.write("bool operator==(")
        self.writeBytes(ident)
        self.write(" _other) {")
        if len(s.Fields) > 0 {
            self.addIndent()
            self.write("\n")
            self.indent()
            self.write("return ")
            self.addIndent()
            mut writed := false
            for (_, mut f) in s.Fields {
                // Skip binded struct kinds.
                strct := f.Kind.Struct()
                if strct != nil && strct.Decl != nil && strct.Decl.Binded {
                    continue
                }
                if writed {
                    self.write(" &&")
                }
                writed = true
                self.write("\n")
                self.indent()
                self.write("this->")
                mut fIdent := StrBuilder.New(len(f.Decl.Ident))
                identCoder.field(fIdent, f.Decl)
                self.writeBytes(unsafe { fIdent.Buf() })
                self.write(" == _other.")
                self.writeBytes(unsafe { fIdent.Buf() })
            }
            self.doneIndent()
            if !writed {
                self.write("true")
            }
            self.write(";\n")
            self.doneIndent()
            self.indent()
            self.write("}")
        } else {
            self.write(" return true; }")
        }
        self.write("\n\n")
    }

    fn structureOperatorNotEq(mut &self, ident: []byte, mut &s: &StructIns) {
        if !s.Comparable {
            ret
        }
        self.indent()
        if opt::Inline {
            self.write("inline ")
        }
        self.write("bool operator!=(")
        self.writeBytes(ident)
        self.write(" _other) { return !this->operator==(_other); }\n\n")
    }

    // Write operator overloading forwarding for reserved function.
    fn structureOperator(mut &self, ident: []byte, mut &f: &FnIns, op: str) {
        if f == nil {
            ret
        }

        unary := len(f.Params) == 1 // Just self parameter.
        assignment := f.Decl.IsVoid()

        self.indent()
        if opt::Inline {
            self.write("inline ")
        }
        if assignment {
            self.writeBytes(ident)
            self.write("&")
        } else {
            if f.Result.Prim() == nil {
                // If result type is not primitive, always structure's itself.
                self.writeBytes(ident)
            } else {
                // Logical.
                self.write(typeCoder.Bool)
            }
        }
        self.write(" operator")
        self.write(op)
        self.write("(")
        if !unary {
            mut p := f.Params[1]
            self.tc.paramIns(self.Buf, p)
            self.write(" _other")
        }
        self.write(") { ")
        if !assignment {
            self.write("return ")
        }
        identCoder.funcIns(self.Buf, f)
        if !unary {
            self.write("(this, _other); ")
            if assignment {
                self.write("return *this; ")
            }
            self.write("}")
        } else {
            self.write("(this); }")
        }
        self.write("\n\n")
    }

    fn structureOperators(mut &self, mut &s: &StructIns) {
        mut sb := StrBuilder.New(40)
        identCoder.structureIns(sb, s)
        ident := unsafe { sb.Buf() }

        // Binary.
        self.structureOperatorEq(ident, s)
        self.structureOperatorNotEq(ident, s)
        self.structureOperator(ident, s.Operators.Gt, ">")
        self.structureOperator(ident, s.Operators.GtEq, ">=")
        self.structureOperator(ident, s.Operators.Lt, "<")
        self.structureOperator(ident, s.Operators.LtEq, "<=")
        self.structureOperator(ident, s.Operators.Shl, "<<")
        self.structureOperator(ident, s.Operators.Shr, ">>")
        self.structureOperator(ident, s.Operators.Add, "+")
        self.structureOperator(ident, s.Operators.Sub, "-")
        self.structureOperator(ident, s.Operators.Div, "/")
        self.structureOperator(ident, s.Operators.Mul, "*")
        self.structureOperator(ident, s.Operators.Mod, "%")
        self.structureOperator(ident, s.Operators.BitAnd, "&")
        self.structureOperator(ident, s.Operators.BitOr, "|")
        self.structureOperator(ident, s.Operators.BitXor, "^")

        // Unary.
        self.structureOperator(ident, s.Operators.Neg, "-")
        self.structureOperator(ident, s.Operators.Pos, "+")
        self.structureOperator(ident, s.Operators.BitNot, "~")

        // Assignment.
        self.structureOperator(ident, s.Operators.AddAssign, "+=")
        self.structureOperator(ident, s.Operators.SubAssign, "-=")
        self.structureOperator(ident, s.Operators.DivAssign, "/=")
        self.structureOperator(ident, s.Operators.MulAssign, "*=")
        self.structureOperator(ident, s.Operators.ModAssign, "%=")
        self.structureOperator(ident, s.Operators.ShlAssign, "<<=")
        self.structureOperator(ident, s.Operators.ShrAssign, ">>=")
        self.structureOperator(ident, s.Operators.BitOrAssign, "|=")
        self.structureOperator(ident, s.Operators.BitAndAssign, "&=")
        self.structureOperator(ident, s.Operators.BitXorAssign, "^=")
    }

    fn structureInsDecl(mut &self, mut &s: &StructIns) {
        for (_, mut m) in s.Methods {
            // Operator methods are declared by [structureDecl].
            if isHeadDecl(m) {
                self.funcDecl(m, false)
            }
        }
        self.write("struct ")
        identCoder.structureIns(self.Buf, s)
        self.write(" {\n")

        self.addIndent()
        for (_, mut f) in s.Fields {
            self.indent()
            self.fieldDecl(f)
            self.write("\n")
        }

        self.indent()
        self.structureDestructor(s)
        self.write("\n\n")

        self.structureOperators(s)
        self.write("\n")

        self.doneIndent()
        self.indent()
        self.write("};")
    }

    fn structureDecl(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.Instances {
            self.structureInsDecl(ins)
        }
    }

    fn structureDecls(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                self.structureDecl(s)
                self.write("\n")
            }
        }
    }

    fn structureMethodDecls(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                for (_, mut ins) in s.Instances {
                    for (_, mut m) in ins.Methods {
                        // Operator methods are declared by [structureDecl].
                        if !isHeadDecl(m) {
                            self.pushResult(m)
                            self.funcDecl(m, false)
                        }
                    }
                }
            }
        }
    }

    // The ident parameter means this function is anon, mostly.
    // But this parameter not only for anonymous functions.
    // It also useable as custom identifiers for functions.
    fn funcHead(mut &self, mut &buf: StrBuilder, mut &f: &FnIns, ptr: bool, ident: str) {
        if !ptr && opt::Inline && !f.Decl.IsEntryPoint() {
            buf.WriteStr("inline ")
        }
        self.tc.funcInsResult(buf, f)
        if ptr {
            buf.WriteStr("(*")
            identCoder.funcIns(buf, f)
            buf.WriteByte(')')
        } else {
            buf.WriteByte(' ')
            if ident == "" {
                identCoder.funcIns(buf, f)
            } else {
                buf.WriteStr(ident)
            }
        }
    }

    fn funcDeclIns(mut &self, mut &f: &FnIns, ptr: bool) {
        self.indent()
        self.funcHead(self.Buf, f, ptr, "")
        self.paramsIns(self.Buf, f)
        self.write(";\n")
    }

    fn funcDecl(mut &self, mut &f: &Fn, ptr: bool) {
        for (_, mut c) in f.Instances {
            self.funcDeclIns(c, ptr)
        }
    }

    fn funcDeclTrait(mut &self, mut &t: &Trait, mut &f: &Fn, ptr: bool) {
        for (_, mut c) in f.Instances {
            mut k := c.Params[0].Kind
            c.Params[0].Kind = &TypeKind{Kind: t}
            self.funcDeclIns(c, ptr)
            c.Params[0].Kind = k
        }
    }

    fn funcDecls(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut f) in file.Funcs {
                    if !f.Binded && f.Token != nil {
                        self.pushResult(f)
                        self.funcDecl(f, false)
                    }
                }
            })
        })
    }

    fn traitDataTypeMethods(mut &self, mut &owner: &Trait, mut &t: &Trait) {
        for (_, mut m) in t.Methods {
            mut ins := m.Instances[0]
            mut p := ins.Params[0]
            p.Kind = &TypeKind{
                Kind: t,
            }
            for (i, mut ip) in ins.Params[1:] {
                if IsAnonIdent(ip.Decl.Ident) {
                    ip.Decl.Ident = "_" + conv::Itoa(i)
                }
            }
            if !env::Production {
                mut lp := ins.Params[len(ins.Params)-1]
                match type lp.Kind.Kind {
                | &customType:
                    break
                |:
                    ins.Params = append(ins.Params, &ParamIns{
                        Decl: &Param{
                            Ident: "__file",
                        },
                        Kind: &TypeKind{
                            Kind: &customType{
                                kind: "const char*",
                            },
                        },
                    })
                }
            }
            self.pushResult(m)
            self.funcDeclTrait(owner, m, true)
        }
    }

    fn traitDataTypes(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.Traits {
                    if t.Token == nil {
                        ret
                    }
                    if len(t.Methods) == 0 {
                        continue
                    }
                    self.write("struct ")
                    identCoder.traitDecl(self.Buf, t)
                    self.write("MptrData")
                    self.write(" {\n")
                    self.addIndent()
                    self.traitDataTypeMethods(t, t)
                    self.doneIndent()
                    self.indent()
                    self.write("};\n\n")
                }
            })
        })
    }

    fn paramIns(mut &self, mut &buf: StrBuilder, mut &p: &ParamIns) {
        self.tc.paramIns(buf, p)
        buf.WriteByte(' ')
        identCoder.param(buf, p.Decl)
    }

    fn paramsIns(mut &self, mut &buf: StrBuilder, mut &f: &FnIns) {
        if !f.AsAnon && len(f.Params) == 0 {
            buf.WriteStr("(void)")
            ret
        }
        buf.WriteByte('(')
        if f.AsAnon {
            buf.WriteStr(ctxParamType + " " + ctxParamIdent)
            if len(f.Params) > 0 {
                buf.WriteStr(", ")
            }
        }
        for (i, mut p) in f.Params {
            self.paramIns(buf, p)
            if len(f.Params)-i > 1 {
                buf.WriteStr(", ")
            }
        }
        buf.WriteByte(')')
    }

    fn varInitExpr(mut &self, mut &v: &Var, init: fn()) {
        if v.Statically {
            self.write("static ")
        }

        self.tc.kind(self.Buf, v.Kind.Kind)
        self.write(" ")
        if v.Reference {
            self.write("*")
        }
        identCoder.var(self.Buf, v)
        if init != nil {
            self.write(" = ")
            init()
        }
        self.write(";")
    }

    fn var(mut &self, mut v: &Var) {
        if IsIgnoreIdent(v.Ident) {
            ret
        }
        if v.Value != nil && v.Value.Expr != nil {
            if v.Value.Data.Model != nil {
                if v.Reference {
                    self.varInitExpr(v, fn() {
                        self.write("&(")
                        self.ec.model(v.Value.Data.Model)
                        self.write(")")
                    })
                } else {
                    self.varInitExpr(v, fn() { self.ec.possibleRefExpr(v.Value.Data.Model) })
                }
                ret
            }
            self.varInitExpr(v, nil)
            ret
        }
        if v.Reference {
            self.varInitExpr(v, fn() { self.write("nullptr") })
            ret
        }
        if shouldInitialized(v.Kind.Kind) {
            self.varInitExpr(v, fn() { self.ec.initExpr(v.Kind.Kind) })
            ret
        }
        self.varInitExpr(v, nil)
    }

    fn anonFuncInsDecl(mut &self, mut &m: &AnonFnExprModel, ident: str) {
        self.funcHead(self.anonObj, m.Func, false, ident)
        self.paramsIns(self.anonObj, m.Func)
        self.anonObj.WriteByte(';')
    }

    fn anonFuncIns(mut &self, mut &m: &AnonFnExprModel, ident: str) {
        self.funcHead(self.Buf, m.Func, false, ident)
        self.paramsIns(self.Buf, m.Func)
        self.write(" ")
        self.sc.anonFuncScope(m, ident)
        if m.Func.Scope != nil {
            self.write("\n\n")
        }
    }

    fn funcIns(mut &self, mut &f: &FnIns) {
        self.funcHead(self.Buf, f, false, "")
        self.paramsIns(self.Buf, f)
        self.write(" ")
        self.sc.funcScope(f)
        if f.Scope != nil {
            self.write("\n\n")
        }
    }

    fn func(mut &self, mut &f: &Fn) {
        for (_, mut ins) in f.Instances {
            self.funcIns(ins)
        }
    }

    fn funcTrait(mut &self, mut &hash: &traitHash, mut &f: &Fn) {
        ident := f.Ident
        for (_, mut ins) in f.Instances {
            ins.Scope = nil

            mut s := StrBuilder.New(len(f.Ident) + len(ident) + len(hash.ti) + len("__") + (1 << 2))
            s.WriteStr(ident)
            s.WriteByte('_')
            s.WriteStr(hash.ti)
            s.WriteByte('_')
            s.WriteStr(conv::Itoa(hash.i))

            f.Ident = s.Str()

            mut k := ins.Params[0].Kind
            ins.Params[0].Kind = &TypeKind{Kind: hash.t}
            self.funcIns(ins)
            ins.Params[0].Kind = k
        }
        f.Ident = ident
    }

    fn traitWrapper(mut &self, mut &m: &Fn, mut &hash: &traitHash) {
        self.funcTrait(hash, m)

        if hash.s == nil {
            if env::Production {
                self.write(" { jule::panic(__JULE_ERROR__INVALID_MEMORY); }\n")
            } else {
                self.write(" { jule::panic(" + typeCoder.Str + "(__JULE_ERROR__INVALID_MEMORY \"\\nlocation: \") + " + typeCoder.Str + "(_00___file)); }\n")
            }
            ret
        }

        ptr := !m.Params[0].IsRef()

        mut sm := hash.s.FindMethod(m.Ident, false)
        if sm == nil || len(sm.Instances) == 0 {
            ret
        }

        self.addIndent()
        self.write("{\n")
        self.indent()
        if sm.Exceptional || !sm.IsVoid() {
            self.write("return ")
        }
        identCoder.func(self.Buf, sm)
        self.write("(")
        if ptr {
            self.write("_self_.safe_ptr<")
            self.tc.structureIns(self.Buf, hash.s)
            self.write(">(")
            if !env::Production {
                self.write("_00___file")
            }
            self.write(")")
        } else {
            self.write("_self_.data.as<")
            self.tc.structure(self.Buf, sm.Owner)
            self.write(">()")
        }
        for _, mp in m.Params[1:] {
            self.write(", ")
            identCoder.param(self.Buf, mp)
        }
        self.write(");\n}\n")
        self.doneIndent()
    }

    fn traitWrappers(mut &self) {
        for (_, mut hash) in self.tmap {
            for (_, mut m) in hash.t.Methods {
                self.traitWrapper(m, hash)
            }
        }
    }

    fn traitDataMethods(mut &self, mut &t: &Trait, &hash: &traitHash) {
        for (_, mut m) in t.Methods {
            mut mIdent := StrBuilder.New(len(m.Ident))
            identCoder.func(mIdent, m)
            self.indent()
            self.write(".")
            self.writeBytes(unsafe { mIdent.Buf() })
            self.write("=")
            self.writeBytes(unsafe { mIdent.Buf() })
            self.write("_")
            self.write(hash.ti)
            self.write("_")
            self.write(conv::Itoa(hash.i))
            self.write(",\n")
        }
    }

    fn traitData(mut &self, mut &hash: &traitHash, mut &old: &Trait) {
        if len(hash.t.Methods) == 0 {
            ret
        }
        mut ident := StrBuilder.New(len(hash.t.Ident))
        identCoder.traitDecl(ident, hash.t)
        if hash.t != old {
            if old != nil {
                self.doneIndent()
                self.indent()
                self.write("};\n")
            }
            self.write("static ")
            self.writeBytes(unsafe { ident.Buf() })
            self.write("MptrData ")
            self.writeBytes(unsafe { ident.Buf() })
            self.write("_mptr_data[] = {\n")
            old = hash.t
            self.addIndent()
        }
        self.indent()
        self.write("{\n")
        self.addIndent()
        self.traitDataMethods(hash.t, hash)
        self.doneIndent()
        self.indent()
        self.write("},\n")
    }

    fn traitDatas(mut &self) {
        let mut old: &Trait = nil
        for (_, mut hash) in self.tmap {
            self.traitData(hash, old)
        }
        if old != nil {
            self.doneIndent()
            self.indent()
            self.write("};\n")
        }
    }

    fn globals(mut &self) {
        for (_, mut v) in self.ir.Ordered.Globals {
            self.tc.kind(self.Buf, v.Kind.Kind)
            self.write(" ")
            identCoder.var(self.Buf, v)
            self.write(" = ")
            self.ec.model(v.Value.Data.Model)
            self.write(";\n")
        }
    }

    fn decls(mut &self) {
        self.traitDecls()
        self.structurePlainDecls()
        self.structureDecls()
        self.headPos = self.Buf.Len()
        self.structureMethodDecls()
        self.funcDecls()
        self.write("\n\n")
        self.traitDataTypes()
        self.write("\n\n")
        self.traitWrappers()
        self.write("\n\n")
        self.traitDatas()
        self.write("\n\n")
        self.declPos = self.Buf.Len()
        self.globals()
    }

    fn structureMethods(mut &self, mut &s: &StructIns) {
        for (_, mut f) in s.Methods {
            self.func(f)
            self.write("\n\n")
        }
    }

    fn structureOstream(mut &self, mut &s: &StructIns) {
        self.indent()
        self.write("std::ostream &operator<<(std::ostream &_Stream, ")
        identCoder.structureIns(self.Buf, s)
        self.write(" _Src) {\n")
        self.addIndent()
        self.indent()

        mut fts := s.FindMethod("Str", false)
        if FuncPattern.Str(fts) {
            self.write("_Stream << ")
            identCoder.func(self.Buf, fts)
            self.write("(&_Src);\n")
        } else {
            self.write(`_Stream << "`)
            cstrBytes(self.Buf, s.Decl.Ident)
            self.write("{\";\n")

            for (i, mut f) in s.Fields {
                self.indent()
                self.write(`_Stream << "`)
                cstrBytes(self.Buf, f.Decl.Ident)
                self.write(`:`)

                // Skip binded struct kinds.
                strct := f.Kind.Struct()
                if strct != nil && strct.Decl != nil && strct.Decl.Binded {
                    self.write(` cpp.`)
                    identCoder.field(self.Buf, f.Decl)
                    self.write(`"`)
                } else {
                    self.write(`" << _Src.`)
                    identCoder.field(self.Buf, f.Decl)
                }
                if i+1 < len(s.Fields) {
                    self.write(" << \", \"")
                }
                self.write(";\n")
            }

            self.indent()
            self.write("_Stream << \"}\";\n")
        }

        self.indent()
        self.write("return _Stream;\n")

        self.doneIndent()
        self.write("}")
    }

    fn structureIns(mut &self, mut &s: &StructIns) {
        self.structureMethods(s)
        self.write("\n\n")
        self.structureOstream(s)
    }

    fn structure(mut &self, mut &s: &Struct) {
        for (_, mut ins) in s.Instances {
            self.structureIns(ins)
            self.write("\n\n")
        }
    }

    fn structures(mut &self) {
        for (_, mut s) in self.ir.Ordered.Structs {
            if s.Token != nil {
                self.structure(s)
                self.write("\n\n")
            }
        }
    }

    fn funcs(mut &self) {
        self.iterPackages(fn(mut &pkg: &Package) {
            iterFiles(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut f) in file.Funcs {
                    if !env::Test && hasDirective(f.Directives, Directive.Test) {
                        continue
                    }
                    if !f.Binded && f.Token != nil {
                        self.func(f)
                        self.write("\n\n")
                    }
                }
            })
        })
    }

    fn pushInit(mut &self, mut &pkg: &Package) {
        iterFiles(pkg, fn(mut &file: &SymbolTable) {
            for _, f in file.Funcs {
                if f.Ident == build::InitFn {
                    self.indent()
                    identCoder.func(self.Buf, f)
                    self.write("();\n")
                }
            }
        })
    }

    fn anonHashes(mut &self) {
        // Use recursive algorithm, because anonymous function may have
        // anonymous functions, so [self.anons] may grow.
        // Make sure all whether all anonymous functions are handled.
    repeat:
        mut anons := self.anons
        self.anons = nil
        for (_, mut h) in anons {
            self.anonFuncIns(h.expr, h.ident)
        }
        if len(self.anons) > 0 {
            goto repeat
        }
    }

    fn initCaller(mut &self) {
        self.write("void " + initCallerIdent + "(void) {\n")
        self.addIndent()
        self.iterPackages(fn(mut &pkg: &Package) {
            self.pushInit(pkg)
        })
        self.doneIndent()
        self.write("\n}")
    }

    fn end(mut &self) {
        self.write(`int main(int argc, char *argv[], char *envp[]) {
    jule::setup_argv(argc, argv);
    jule::setup_envp(envp);

    __jule_call_initializers();
    `)

        if env::Test {
            self.write("test_point();")
        } else {
            self.write("entry_point();")
        }

        self.write(`

    return EXIT_SUCCESS;
}`)
    }

    fn serializeHead(mut &self) {
        self.prepareStructures()
        self.buildTraitMap()
        self.head()
        self.write("\n")
        self.decls()

        if self.resultDecls.Len() > 0 {
            mut head := make([]byte, 0, self.Buf.Len() + self.resultDecls.Len())
            head = append(head, unsafe { self.Buf.Buf() }[:self.headPos]...)
            head = append(head, unsafe { self.resultDecls.Buf() }...)
            self.declPos += self.resultDecls.Len()
            head = append(head, unsafe { self.Buf.Buf() }[self.headPos:]...)
            unsafe { self.Buf.SetBuf(head) }
        }

        self.write("\n")
        self.structures()
        self.funcs()
        self.initCaller()
        self.write("\n\n")

        self.anonHashes()

        if self.anyObj.Len() > 0 {
            mut head := make([]byte, 0, self.Buf.Len() + self.anyObj.Len())
            head = append(head, unsafe { self.Buf.Buf() }[:self.declPos]...)
            head = append(head, unsafe { self.anyObj.Buf() }...)
            head = append(head, unsafe { self.Buf.Buf() }[self.declPos:]...)
            unsafe { self.Buf.SetBuf(head) }
            self.declPos += self.anyObj.Len()
        }
        if self.anonObj.Len() > 0 {
            mut head := make([]byte, 0, self.Buf.Len() + self.anonObj.Len())
            head = append(head, unsafe { self.Buf.Buf() }[:self.declPos]...)
            head = append(head, unsafe { self.anonObj.Buf() }...)
            head = append(head, unsafe { self.Buf.Buf() }[self.declPos:]...)
            unsafe { self.Buf.SetBuf(head) }
        }
    }

    fn Serialize(mut &self) {
        self.serializeHead()
        self.end()
    }
}

fn iterFiles(mut &pkg: &Package, f: fn(mut &f: &SymbolTable)) {
    for (_, mut file) in pkg.Files {
        f(file)
    }
}

// Concatenate all strings into single string.
fn concatAllParts(parts: ...&Token): []byte {
    mut n := 0
    for _, part in parts {
        n += len(part.Kind)
    }
    if n == 0 {
        ret nil
    }
    mut s := StrBuilder.New(n)
    for _, p in parts {
        s.WriteStr(p.Kind)
    }
    ret unsafe { s.Buf() }
}

// Reports whether trait have method in this identifier.
fn containsTraitMethod(mut &t: &Trait, &ident: str): bool {
    for _, m in t.Methods {
        if m.Ident == ident {
            ret true
        }
    }
    ret false
}

// Pushes src methods to dest if not exist any method with relevant identifier.
// Also it uses deep walk algorithm for inheritances.
// So it will pushes inheritances of src trait to dest.
fn pushMethodsFromInherit(mut &dest: &Trait, mut &src: &Trait) {
    pushMethodsFromInherits(dest, src)
    for (_, mut m) in src.Methods {
        if !containsTraitMethod(dest, m.Ident) {
            dest.Methods = append(dest.Methods, m)
        }
    }
}

// Pushes inheritances of src to dest.
// Call pushMethodsFromInherit method per inheritance of src.
fn pushMethodsFromInherits(mut &dest: &Trait, mut &src: &Trait) {
    for (_, mut inh) in src.Inherits {
        mut t2 := inh.Kind.Trait()
        pushMethodsFromInherit(dest, t2)
    }
}

// Reports whether the m is operator overloading method.
fn isOpMethod(&m: &Fn): bool {
    if len(m.Generics) > 0 || len(m.Instances) == 0 {
        ret false
    }
    mi := m.Instances[0]
    const tableT = comptime::TypeOf(Operators)
    const tableV = comptime::ValueOf(mi.Owner.Operators)
    const for _, field in tableT.Fields() {
        if mi == tableV.Field(field.Name()).Unwrap() {
            ret true
        }
    }
    ret false
}

// Reports whether the m is a method which is declarated top of the struct.
fn isHeadDecl(mut &m: &Fn): bool {
    if len(m.Generics) > 0 || len(m.Instances) == 0 {
        ret false
    }
    if isOpMethod(m) {
        ret true
    }
    mut mi := m.Instances[0]
    const Static = false
    ret FuncPattern.Dispose(mi.Owner.FindMethod("Dispose", Static))
}