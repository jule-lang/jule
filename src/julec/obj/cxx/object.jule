// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use env
use obj::{IR}
use conv for std::conv
use std::fs::{File}
use jule for std::jule
use build for std::jule::build::{
    Directive,
    Derive,
}
use std::jule::lex::{
    Token,
    TokenId,
    is_ignore_ident,
    is_anon_ident,
}
use std::jule::sema::{
    FuncPattern,
    Package,
    SymbolTable,
    Param,
    ParamIns,
    Trait,
    Struct,
    FieldIns,
    Var,
    StructIns,
    Fn,
    FnIns,
    TypeKind,
    Prim,
    Sptr,
    TypeSymbol,
}
use path for std::fs::path
use strings for std::strings
use std::time::{Time}

pub struct SerializationInfo {
    pub compiler:         str
    pub compiler_command: str
}

struct TraitHash {
    t: &Trait
    s: &StructIns
    i: int
}

pub struct ObjectCoder {
    ir:   &IR
    info: SerializationInfo
    f:    &File
    tmap: []&TraitHash

    // Current indentation.
    indent_buffer: []byte
}

impl ObjectCoder {
    pub static fn new(mut &ir: &IR, mut &f: &File, info: SerializationInfo): &ObjectCoder {
        let mut oc = &ObjectCoder{
            ir: ir,
            info: info,
            f: f,
        }
        ret oc
    }

    fn write(mut &self, mut s: str) {
        _ = self.f.write([]byte(s))!
    }

    // Increase indentation.
    fn add_indent(mut &self) {
        const INDENT_KIND = '\t'
        self.indent_buffer = append(self.indent_buffer, INDENT_KIND)
    }

    // Decrase indentation.
    fn done_indent(mut &self) {
        self.indent_buffer = self.indent_buffer[:self.indent_buffer.len-1]
    }

    // Returns indention string by indent_buffer.
    fn indent(mut &self) {
        _ = self.f.write(self.indent_buffer)!
    }

    fn head(mut &self) {
        let time = Time.now()
        let abs = time.abs()
        self.write("// Auto generated by JuleC.\n")
        self.write("// JuleC version: ")
        self.write(jule::VERSION)
        self.write("\n")
        self.write("// Date: ")
        self.write(conv::fmt_uint(abs.day, 10))
        self.write("/")
        self.write(conv::fmt_uint(abs.month, 10))
        self.write("/")
        self.write(conv::fmt_uint(abs.year, 10))
        self.write(" (DD/MM/YYYY) UTC\n//\n// Recomended Compile Command;\n// ")
        self.write(self.info.compiler)
        self.write(" ")
        self.write(self.info.compiler_command)
        self.write("\n\n")

        if env::PRODUCTION {
            self.write("#define __JULE_ENABLE__PRODUCTION\n")
        }
        if !env::RC {
            self.write("#define __JULE_DISABLE__REFERENCE_COUNTING\n")
        }
        if !env::SAFETY {
            self.write("#define __JULE_DISABLE__SAFETY\n")
        }
        self.write("\n\n#include \"")
        self.write(build::PATH_API)
        self.write("\"\n\n")
    }

    fn links(mut &self) {
        for _, used in self.ir.used {
            match {
            | !used.cpp_linked:
                continue
            | build::is_std_header_path(used.path):
                self.write("#include ")
                self.write(used.path)
                self.write("\n")
            |:
                self.write("#include \"")
                self.write(used.path)
                self.write("\n")
            }
        }
    }

    fn prepare_structures(mut &self) {
        for (_, mut s) in self.ir.ordered.structs {
            if !s.cpp_linked && s.token != nil {
                prepare_structure(s)
            }
        }
    }

    fn iter_packages(mut &self, f: fn(mut &pkg: &Package)) {
        for (_, mut used) in self.ir.used {
            if !used.cpp_linked {
                f(used.package)
            }
        }
        f(self.ir.main)
    }

    fn build_trait_map(mut &self) {
        self.iter_packages(fn(mut &pkg: &Package) {
            iter_files(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.traits {
                    if t.token == nil {
                        ret
                    }
                    let mut i = 0
                    for (_, mut s) in t.implemented {
                        for (_, mut ins) in s.instances {
                            self.tmap = append(self.tmap, &TraitHash{
                                t: t,
                                s: ins,
                                i: i,
                            })
                            i++
                        }
                    }
                }
            })
        })
    }

    fn trait_decls(mut &self) {
        self.iter_packages(fn(mut &pkg: &Package) {
            iter_files(pkg, fn(mut &file: &SymbolTable) {
                for (_, mut t) in file.traits {
                    if t.token == nil {
                        ret
                    }
                    self.indent()
                    self.write("struct ")
                    self.write(IdentCoder.trait_decl(t))
                    self.write("{};\n")
                }
            })
        })
    }

    fn decls(mut &self) {
        self.trait_decls()
    }

    pub fn serialize(mut &self) {
        self.prepare_structures()
        self.build_trait_map()
        self.head()
        self.links()
        self.write("\n")
        self.decls()
    }
}

fn iter_files(mut &pkg: &Package, f: fn(mut &f: &SymbolTable)) {
    for (_, mut file) in pkg.files {
        f(file)
    }
}

fn prepare_structure(mut &s: &Struct) {
    for (_, mut ins) in s.instances {
        for (_, mut m) in ins.methods {
            if m.statically {
                continue
            }
            for (_, mut ins) in m.instances {
                let mut p = ins.params[0]
                if !p.decl.is_ref() {
                    p.kind = &TypeKind{
                        kind: &CustomType{
                            kind: TypeCoder.as_ptr(TypeCoder.kind(p.kind)),
                        },
                    }
                } else {
                    p.kind = &TypeKind{
                        kind: &CustomType{
                            kind: TypeCoder.kind(p.kind),
                        },
                    }
                }
            }
        }
    }
}

// Concatenate all strings into single string.
fn concat_all_parts(parts: ...&Token): str {
    let mut s = ""
    for _, p in parts {
        s += p.kind
    }
    ret s
}