// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use obj::{IR}

use std::jule::build::{
    is_std_header_path,
    is_valid_header_ext,
}
use std::jule::lex::{
    TokenId,
    is_ignore_ident,
    is_anon_ident,
}
use std::jule::sema::{
    Package,
    SymbolTable,
    Param,
    ParamIns,
    Trait,
    Struct,
    FieldIns,
}
use strings for std::strings

struct ObjectCoder {
    ir: &IR
    // Current indention.
    indent_buffer: str

    ec: &ExprCoder
    sc: &ScopeCoder
}

impl ObjectCoder {
    static fn new(mut &ir: &IR): &ObjectCoder {
        let mut objc = new(ObjectCoder)
        objc.ec = ExprCoder.new(objc)
        objc.sc = ScopeCoder.new(objc)
        ret objc
    }

    // Increase indentation.
    fn add_indent(mut self) {
        const INDENT_KIND = "\t"
        self.indent_buffer += INDENT_KIND
    }

    // Decrase indentation.
    fn done_indent(mut self) {
        self.indent_buffer = self.indent_buffer[:self.indent_buffer.len - 1]
    }

    // Returns indention string by indent_buffer.
    fn indent(self): str {
        ret self.indent_buffer
    }

    // Generates all C/C++ include directives.
    fn gen_links(mut self): str {
        let mut obj = ""
        for (_, mut pkg) in self.ir.used {
            match {
            | !pkg.cpp_linked:
                continue
            | is_std_header_path(pkg.path):
                obj += "#include "
                obj += pkg.path
                obj += "\n"
            }
        }

        for (_, mut pkg) in self.ir.used {
            match {
            | !pkg.cpp_linked:
                continue
            | is_cpp_header_file(pkg.path):
                obj += `#include "`
                obj += pkg.path
                obj += "\"\n"
            }
        }
        ret obj
    }

    // Generates C++ code of parameter instance.
    fn gen_param_ins(self, mut &p: &ParamIns): str {
        let mut obj = TypeCoder.param_ins(p)
        obj += " "
        obj += IdentCoder.param(p.decl)
        ret obj
    }

    // Generates C++ code of parameter.
    fn gen_param(mut self, mut &p: &Param): str {
        let mut obj = TypeCoder.param(p)
        if p.ident != "" && !is_ignore_ident(p.ident) && !is_anon_ident(p.ident) {
            obj += " "
            obj += IdentCoder.param(p)
        }
        ret obj
    }

    // Generates C++ code of parameters.
    fn gen_params(mut self, mut &params: []&Param): str {
        match {
        | params.len == 0:
            ret "(void)"
        | params.len == 1 && params[0].is_self():
            ret "(void)"
        }
        let mut obj = "("
        for (_, mut p) in params {
            if !p.is_self() {
                obj += self.gen_param(p) + ","
            }
        }

        // Remove comma.
        obj = obj[:obj.len-1]
        ret obj + ")"
    }

    fn gen_params_ins(mut self, mut &params: []&ParamIns): str {
        match {
        | params.len == 0:
            ret "(void)"
        | params.len == 1 && params[0].decl.is_self():
            ret "(void)"
        }

        let mut obj = "("
        for (_, mut p) in params {
            if !p.decl.is_self() {
                obj += self.gen_param_ins(p) + ","
            }
        }

        // Remove comma.
        obj = obj[:obj.len-1]
        ret obj + ")"
    }

    // Generates C++ declaration code of parameters.
    fn gen_params_prototypes(mut self, mut &params: []&ParamIns): str {
        match {
        | params.len == 0:
            ret "(void)"
        | params.len == 1 && params[0].decl.is_self():
            ret "(void)"
        }

        let mut obj = "("
        for (_, mut p) in params {
            if !p.decl.is_self() {
                obj += TypeCoder.param_ins(p)
                obj += ","
            }
        }

        // Remove comma.
        obj = obj[:obj.len-1]
        ret obj + ")"
    }

    // Generates C++ code of trait.
    fn gen_trait(mut self, mut &t: &Trait): str {
        const INDENTION = "\t"
        let outid = IdentCoder.trait_decl(t)

        let mut obj = "struct "
        obj += outid
        obj += " {\n"
        obj += INDENTION
        obj += "virtual ~"
        obj += outid
        obj += "(void) {}\n\n"
        for (_, mut f) in t.methods {
            obj += INDENTION
            obj += "virtual "
            obj += TypeCoder.func_result(f)
            obj += " _method_"
            obj += f.ident
            obj += self.gen_params(f.params)
            obj += " {"
            if !f.is_void() {
                obj += " return {}; "
            }
            obj += "}\n"
        }
        obj += "};"
        ret obj
    }

    // Generates C++ code of SymbolTable's all traits.
    fn gen_traits_tbl(mut self, mut &tbl: &SymbolTable): str {
        let mut obj = ""
        for (_, mut t) in tbl.traits {
            obj += self.gen_trait(t)
            obj += "\n\n"
        }
        ret obj
    }

    // Generates C++ code of package's all traits.
    fn gen_traits_pkg(mut self, mut &pkg: &Package): str {
        let mut obj = ""
        for (_, mut tbl) in pkg.files {
            obj += self.gen_traits_tbl(tbl)
        }
        ret obj
    }

    // Generates C++ code of all traits.
    fn gen_traits(mut self): str {
        let mut obj = ""
        for (_, mut u) in self.ir.used {
            if !u.cpp_linked {
                obj += self.gen_traits_pkg(u.package)
            }
        }
        obj += self.gen_traits_pkg(self.ir.main)
        ret obj
    }

    // Generates C++ declaration code of trait.
    fn gen_trait_decl(mut self, &t: &Trait): str {
        let mut obj = "struct "
        obj += IdentCoder.trait_decl(t)
        obj += ";"
        ret obj
    }

    // Generates C++ declaration code of all traits.
    fn gen_trait_decls(mut self, mut &p: &Package): str {
        let mut obj = ""
        for (_, mut f) in p.files {
            for _, t in f.traits {
                if t.token.id != TokenId.Na {
                    obj += self.gen_trait_decl(t)
                    obj += "\n"
                }
            }
        }
        ret obj
    }

    // Generates C++ plain-prototype code of structure.
    fn gen_struct_plain_decl(mut self, mut &s: &Struct): str {
        let mut obj = ""
        for (_, mut ins) in s.instances {
            obj += "\nstruct "
            obj += IdentCoder.structure_ins(ins)
            obj += ";\n"
        }
        ret obj
    }

    // Generates C++ plain-prototype code of all structures.
    fn gen_struct_plain_decls(mut self): str {
        let mut obj = ""
        for (_, mut s) in self.ir.ordered.structs {
            if !s.cpp_linked && s.token.id != TokenId.Na {
                obj += self.gen_struct_plain_decl(s)
                obj += "\n"
            }
        }
        ret obj
    }

    // Generates C++ derive code of structure's implemented traits.
    fn gen_struct_traits(mut self, &s: &Struct): str {
        if s.implements.len == 0 {
            ret ""
        }
        let mut obj = ": "
        for _, i in s.implements {
            obj += "public "
            obj += IdentCoder.trait_decl(i)
            obj += ","
        }
        obj = obj[:obj.len-1] // Remove last comma.
        ret obj
    }
}

fn is_cpp_header_file(path: str): bool {
    let offset = strings::find_last_byte(path, '.')
    if offset == -1 {
        ret false
    }
    ret is_valid_header_ext(path[offset:])
}

/*
use env

use conv for std::conv
use std::jule::{VERSION}
use std::jule::build::{
    Directive,
    Derive,
    INIT_FN,
    PATH_API,
    is_valid_cpp_ext,
}
use std::jule::lex::{
    TokenKind,
}
use std::jule::sema::{
    ImportInfo,
    Var,
    StructIns,
    Fn,
    FnIns,
    BUILTIN_TRAIT_DISPOSE,
}
use std::time::{Time}

impl ObjectCoder {
    // Generates C++ declaration code of field.
    fn gen_field_decl(mut self, mut &f: &FieldIns): str {
        let mut obj = TypeCoder.from_kind(f.kind)
        obj += " "
        obj += IdentCoder.from_field(f.decl)
        obj += " = "
        if f.default == nil {
            // No default expression.
            // Use default expression of data-type.
            obj += get_init_expr(f.kind)
        } else {
            obj += gen_expr(f.default.model)
        }
        obj += ";"
        ret obj
    }

    fn gen_struct_self_field_type_kind(mut self, mut &s: &StructIns): str {
        ret as_sptr_kind(gen_struct_kind_ins(s))
    }

    // Generates C++ field declaration code of structure's self field.
    fn gen_struct_self_field(mut self, mut &s: &StructIns): str {
        let mut obj = gen_struct_self_field_type_kind(s)
        obj += " self;"
        ret obj
    }

    fn gen_struct_self_field_init_st(mut self, mut &s: &StructIns): str {
        let mut obj = "this->self = "
        obj += gen_struct_self_field_type_kind(s)
        obj += "::make(this, nullptr);"
        ret obj
    }

    fn gen_struct_constructor(mut self, mut &s: &StructIns): str {
        let mut obj = struct_ins_out_ident(s)

        obj += "("
        if s.fields.len > 0 {
            for (_, mut f) in s.fields {
                obj += gen_type_kind(f.kind)
                obj += " __param_"
                obj += f.decl.ident
                obj += ", "
            }
            obj = obj[:obj.len-2] // Remove last comma.
        } else {
            obj += "void"
        }

        obj += ")"
        if s.fields.len > 0 {
            obj += ": "
            for _, f in s.fields {
                obj += field_out_ident(f.decl)
                obj += "("
                obj += "__param_"
                obj += f.decl.ident
                obj += "), "
            }
            obj = obj[:obj.len-2] // Remove trailing comma.
        }

        obj += " {"
        if s.decl.has_ref_accessible() {
            obj += "\n"
            add_indent()
            obj += indent()
            obj += gen_struct_self_field_init_st(s)
            obj += "\n"
            done_indent()
            obj += "\n"
            obj += indent()
        }
        obj += "}"
        ret obj
    }

    fn gen_struct_destructor(mut self, mut &s: &StructIns): str {
        const STATIC = false // Dispose method must be non-static
        let mut disposed = fn_is_dispose(s.decl.find_method("dispose", STATIC))
        let ref_access = s.decl.has_ref_accessible()
        // Call destructor if implemented.
        if !ref_access && !disposed {
            ret ""
        }

        let mut obj = "~"
        obj += struct_ins_out_ident(s)
        obj += "(void) { "

        if disposed {
            let dispose_method = s.find_method("dispose", false)
            obj += "this->"
            obj += fn_out_ident(dispose_method)
            obj += "(); "
        }

        if ref_access {
            obj += "this->self.ref = nullptr; "
        }

        obj += "}"
        ret obj
    }

    fn gen_struct_operators(mut self, mut &s: &StructIns): str {
        let out_ident = struct_ins_out_ident(s)
        let mut obj = ""

        obj += indent()
        if env::OPT_INLINE {
            obj += "inline "
        }
        obj += "bool operator==(const "
        obj += out_ident
        obj += " &_Src) const {"
        if s.fields.len > 0 {
            add_indent()
            obj += "\n"
            obj += indent()
            obj += "return "
            add_indent()
            let mut n = 0
            for (_, mut f) in s.fields {
                // Skip C++-linked struct kinds.
                let strct = f.kind.strct()
                if strct != nil && strct.decl != nil && strct.decl.cpp_linked {
                    continue
                }

                n++
                obj += "\n"
                obj += indent()
                obj += "this->"
                let f_ident = field_out_ident(f.decl)
                obj += f_ident
                obj += " == _Src."
                obj += f_ident
                obj += " &&"
            }
            done_indent()
            if n > 0 {
                obj = obj[:obj.len-3] // Remove last suffix " &&"
            } else {
                obj += "true"
            }
            obj += ";\n"
            done_indent()
            obj += indent()
            obj += "}"
        } else {
            obj += " return true; }"
        }
        obj += "\n\n"
        obj += indent()
        if env::OPT_INLINE {
            obj += "inline "
        }
        obj += "bool operator!=(const "
        obj += out_ident
        obj += " &_Src) const { return !this->operator==(_Src); }"
        ret obj
    }

    fn gen_struct_derive_defs_prototypes(mut self, &s: &StructIns): str {
        let mut obj = ""

        if s.decl.is_derives(Derive.Clone) {
            obj += indent()
            obj += get_derive_fn_decl_clone(s.decl)
            obj += ";\n\n"
        }

        ret obj
    }

    fn gen_struct_ins_prototype(mut self, mut &s: &StructIns): str {
        let mut obj = "struct "
        let out_ident = struct_ins_out_ident(s)

        obj += out_ident
        obj += gen_struct_traits(s.decl)
        obj += " {\n"

        let ref_access = s.decl.has_ref_accessible()

        add_indent()
        if ref_access {
            obj += indent()
            obj += gen_struct_self_field(s)
            obj += "\n\n"
        }
        if s.fields.len > 0 {
            for (_, mut f) in s.fields {
                obj += indent()
                obj += gen_field_decl(f)
                obj += "\n"
            }
            obj += "\n\n"
            obj += indent()
            obj += gen_struct_constructor(s)
            obj += "\n\n"
        }

        obj += indent()
        obj += gen_struct_destructor(s)
        obj += "\n\n"

        // Default constructor.
        obj += indent()
        obj += out_ident
        if ref_access {
            obj += "(void) { "
            obj += gen_struct_self_field_init_st(s)
            obj += " }\n\n"
        } else {
           obj += "(void) = default;\n\n"
        }

        for (_, mut f) in s.methods {
            obj += gen_fn_prototype(f, true)
            obj += "\n\n"
        }

        obj += gen_struct_derive_defs_prototypes(s)

        obj += gen_struct_operators(s)
        obj += "\n"

        done_indent()
        obj += indent() + "};"
        ret obj
    }

    // Generates C++ declaration code of structure.
    fn gen_struct_prototype(mut self, mut &s: &Struct): str {
        let mut obj = ""
        for (_, mut ins) in s.instances {
            obj += gen_struct_ins_prototype(ins)
            obj += "\n\n"
        }
        ret obj
    }

    // Generates C++ declaration code of all structures.
    fn gen_struct_prototypes(mut self, mut &structs: []&Struct): str {
        let mut obj = ""
        for (_, mut s) in structs {
            if !s.cpp_linked && s.token.id != TokenId.Na {
                obj += gen_struct_prototype(s)
                obj += "\n"
            }
        }
        ret obj
    }

    fn gen_fn_decl_head(mut self, mut &f: &FnIns, method: bool): str {
        let mut obj = ""

        if method && f.decl.statically {
            obj += "static "
        }

        if env::OPT_INLINE && !f.decl.is_entry_point() {
            obj += "inline "
        }

        obj += gen_fn_ins_result(f) + " "

        if !method && f.decl.owner != nil {
            obj += struct_ins_out_ident(f.owner)
            obj += "::"
        }
        obj += fn_ins_out_ident(f)
        ret obj
    }

    // Generates C++ declaration code of function's combinations.
    fn gen_fn_prototype(mut self, mut &f: &Fn, method: bool): str {
        let mut obj = ""
        for (_, mut c) in f.instances {
            obj += indent()
            obj += gen_fn_decl_head(c, method)
            obj += gen_params_prototypes(c.params)
            obj += CPP_ST_TERM + "\n"
        }
        ret obj
    }

    // Generates C++ declaration code of all functions.
    fn gen_fn_prototypes(mut self, mut &pkg: &Package): str {
        let mut obj = ""
        for (_, mut file) in pkg.files {
            for (_, mut f) in file.funcs {
                if !f.cpp_linked && f.token.id != TokenId.Na {
                    obj += gen_fn_prototype(f, false)
                }
            }
        }
        ret obj
    }

    // Generates C++ code of all can-be-prototyped declarations.
    fn gen_prototypes(mut self): str {
        let mut obj = ""

        for (_, mut u) in self.ir.used {
            if !u.cpp_linked {
                obj += gen_trait_prototypes(u.package)
            }
        }
        obj += gen_trait_prototypes(self.ir.main)


        obj += gen_struct_plain_prototypes(self.ir.ordered.structs)

        obj += gen_traits(self.ir)
        obj += "\n"

        obj += gen_struct_prototypes(self.ir.ordered.structs)

        for (_, mut u) in ir.used {
            if !u.cpp_linked {
                obj += gen_fn_prototypes(u.package)
            }
        }
        obj += gen_fn_prototypes(self.ir.main)

        ret obj
    }

    // Generats C++ code of variable with initialize expression.
    fn gen_var_init_expr(mut self, mut &v: &Var, init: str): str {
        let mut obj = ""
        if v.statically {
            obj += "static "
        }

        obj += gen_type_kind(v.kind.kind)
        obj += " "
        if v.reference {
            obj += "&"
        }
        obj += var_out_ident(v)
        if init != "" {
            obj += " = "
            obj += init
        }
        obj += CPP_ST_TERM
        ret obj
    }

    // Generates C++ code of variable.
    fn gen_var(mut self, mut v: &Var): str {
        if is_ignore_ident(v.ident) {
            ret ""
        }
        if v.value != nil && v.value.expr != nil {
            if v.value.data.model != nil {
                ret gen_var_init_expr(v, gen_val(v.value))
            }
            ret gen_var_init_expr(v, "")
        }
        ret gen_var_init_expr(v, get_init_expr(v.kind.kind))
    }

    fn gen_pkg_globals(mut self, mut &p: &Package, mut &global_initializers: str): str {
        let mut obj = ""
        for (_, mut f) in p.files {
            for (_, mut v) in f.vars {
                if v.token.id != TokenId.Na && !v.cpp_linked && !v.constant {
                    obj += gen_type_kind(v.kind.kind)
                    obj += " "
                    if v.reference {
                        obj += "&"
                    }
                    obj += var_out_ident(v)
                    obj += ";\n"

                    global_initializers += indent() // Indentation for initializer scope.
                    global_initializers += var_out_ident(v)
                    if v.value != nil && v.value.expr != nil {
                        if v.value.data.model != nil {
                            global_initializers += " = "
                            global_initializers += gen_val(v.value)
                        }
                    } else {
                        global_initializers += " = "
                        global_initializers += get_init_expr(v.kind.kind)
                    }
                    global_initializers += ";\n"
                }
            }
        }
        ret obj
    }

    // Generates C++ code of all globals.
    fn gen_globals(mut self, mut &global_initializers: str): str {
        let mut obj = ""

        self.add_indent() // For global initializers's function indentation.

        for (_, mut u) in self.ir.used {
            if !u.cpp_linked {
                obj += gen_pkg_globals(u.package, global_initializers)
            }
        }
        obj += gen_pkg_globals(self.ir.main, global_initializers)

        self.done_indent()

        ret obj
    }

    // Generates C++ code of function.
    fn gen_fn(mut self, mut &f: &Fn): str {
        let mut obj = ""
        for (_, mut ins) in f.instances {
            obj += gen_fn_decl_head(ins, false)
            obj += gen_params_ins(ins.params)
            obj += " "
            obj += gen_fn_scope(ins)
            obj += "\n\n"
        }
        ret obj
    }

    // Generates C++ code of all functions of package.
    fn gen_pkg_fns(mut self, mut &p: &Package): str {
        let mut obj = ""
        for (_, mut f) in p.files {
            for (_, mut f) in f.funcs {
                if !env::TEST && has_directive(f.directives, Directive.Test) {
                    continue
                }
                if !f.cpp_linked && f.token.id != TokenId.Na {
                    obj += gen_fn(f)
                    obj += "\n\n"
                }
            }
        }
        ret obj
    }

    // Generates C++ code of structure's methods.
    fn gen_struct_method_defs(mut self, mut &s: &StructIns): str {
        let mut obj = ""
        for (_, mut f) in s.methods {
            obj += indent()
            obj += gen_fn(f)
            obj += "\n\n"
        }
        ret obj
    }

    // Reports method is reversed to_str method.
    fn fn_is_to_str(mut self, mut &f: &Fn): bool {
        if f == nil ||
            !f.public ||
            f.is_void() ||
            f.generics.len != 0 ||
            f.params.len != 1 ||
            f.params[0].mutable ||
            f.params[0].is_ref() {
            ret false
        }

        let mut ins = f.instances[0]
        let prim = ins.result.prim()
        if prim == nil {
            ret false
        }
        ret prim.is_str()
    }

    // Generates C++ code of structure's ostream.
    fn gen_struct_ostream(mut self, mut &s: &StructIns): str {
        let mut obj = ""
        obj += indent()
        obj += "std::ostream &operator<<(std::ostream &_Stream, const "
        obj += struct_ins_out_ident(s)
        obj += " &_Src) {\n"
        add_indent()
        obj += indent()

        let mut fts = s.find_method("to_str", false)
        if fn_is_to_str(fts) {
            obj += "_Stream << (("
            obj += struct_ins_out_ident(s)
            obj += ")(_Src))."
            obj += fn_out_ident(fts)
            obj += "();\n"
        } else {
            obj += `_Stream << "`
            obj += s.decl.ident
            obj += "{\";\n"

            for (i, mut f) in s.fields {
                obj += indent()
                obj += `_Stream << "`
                obj += f.decl.ident
                obj += `:`

                // Skip C++-linked struct kinds.
                let strct = f.kind.strct()
                if strct != nil && strct.decl != nil && strct.decl.cpp_linked {
                    obj += ` cpp.`
                    obj += field_out_ident(f.decl)
                    obj += `"`
                } else {
                    obj += `" << _Src.`
                    obj += field_out_ident(f.decl)
                }
                if i+1 < s.fields.len {
                    obj += " << \", \""
                }
                obj += ";\n"
            }

            obj += indent()
            obj += "_Stream << \"}\";\n"
        }

        obj += indent()
        obj += "return _Stream;\n"

        done_indent()
        obj += indent()
        obj += "}"
        ret obj
    }

    fn gen_struct_derive_defs(mut self, mut &s: &StructIns): str {
        let mut obj = ""

        if s.decl.is_derives(Derive.Clone) {
            obj += indent()
            obj += get_derive_fn_def_clone(s.decl)
            obj += "{\n"
            add_indent()
            obj += indent()
            obj += gen_struct_kind_ins(s)
            obj += " clone;\n"
            for _, f in s.fields {
                let ident = field_out_ident(f.decl)

                obj += indent()
                obj += "clone."
                obj += ident
                obj += " = jule::clone(this->"
                obj += ident
                obj += ");\n"
            }
            obj += indent()
            obj += "return clone;\n"
            done_indent()
            obj += indent()
            obj += "}"
        }

        ret obj
    }

    // Generates C++ code of structure instance definition.
    fn gen_struct_ins(mut self, mut &s: &StructIns): str {
        let mut obj = gen_struct_method_defs(s)
        obj += "\n\n"
        obj += gen_struct_derive_defs(s)
        obj += "\n\n"
        obj += gen_struct_ostream(s)
        ret obj
    }

    // Generates C++ code of structure definition.
    fn gen_struct(mut self, mut &s: &Struct): str {
        let mut obj = ""
        for (_, mut ins) in s.instances {
            obj += gen_struct_ins(ins)
            obj += "\n\n"
        }
        ret obj
    }

    // Generates C++ code of all structures.
    fn gen_structs(mut self, mut &structs: []&Struct): str {
        let mut obj = ""
        for (_, mut s) in structs {
            if !s.cpp_linked && s.token.id != TokenId.Na {
                obj += gen_struct(s)
                obj += "\n\n"
            }
        }
        ret obj
    }

    // Generates C++ code of all functions.
    fn gen_fns(mut self): str {
        let mut obj = ""
        for (_, mut u) in self.ir.used {
            if !u.cpp_linked {
                obj += gen_pkg_fns(u.package)
            }
        }
        obj += gen_pkg_fns(self.ir.main)
        ret obj
    }

    fn push_init(self, mut &pkg: &Package, mut &obj: str) {
        const INDENTION = "\t"
        const CPP_LINKED = false
        let f = pkg.find_fn(INIT_FN, CPP_LINKED)
        if f == nil {
            ret
        }
        obj += "\n" + INDENTION
        obj += fn_out_ident(f)
        obj += "();"
    }

    // Generated C++ code of all initializer functions.
    fn gen_init_caller(mut self, &global_initializers: str): str {
        let mut obj = "void "
        obj += INIT_CALLER_IDENT
        obj += "(void) {\n"
        obj += global_initializers

        for (_, mut u) in self.ir.used {
            if !u.cpp_linked {
                push_init(u.package, obj)
            }
        }
        push_init(self.ir.main, obj)

        obj += "\n}"
        ret obj
    }
}








/*
// Reports method is reversed dispose method.
fn fn_is_dispose(mut f: &Fn): bool {
    ret f != nil &&
        f.public &&
        f.is_void() &&
        f.generics.len == 0 &&
        f.params.len == 1 &&
        f.params[0].mutable &&
        !f.params[0].is_ref()
}

pub fn append_standard(mut &obj_code: str, compiler: str, compiler_cmd: str) {
    let time = Time.now().abs()

    let mut time_str = ""
    time_str += conv::fmt_uint(time.day, 10)
    time_str += "/"
    time_str += conv::fmt_uint(time.month, 10)
    time_str += "/"
    time_str += conv::fmt_uint(time.year, 10)
    time_str += " "
    time_str += conv::fmt_uint(time.hour, 10)
    time_str += "."
    time_str += conv::fmt_uint(time.minute, 10)
    time_str += " (DD/MM/YYYY) (HH.MM) UTC"

    let mut s = ""
    s += "// Auto generated by JuleC.\n"
    s += "// JuleC version: "
    s += VERSION
    s += "\n"
    s += "// Date: "
    s += time_str
    s += `
//
// Recommended Compile Command;
// `
    s += compiler
    s += " "
    s += compiler_cmd
    s += "\n\n"

    if env::PRODUCTION {
        s += "#define __JULE_ENABLE__PRODUCTION\n"
    }
    if !env::RC {
        s += "#define __JULE_DISABLE__REFERENCE_COUNTING\n"
    }
    if !env::SAFETY {
        s += "#define __JULE_DISABLE__SAFETY\n"
    }

    s += "\n\n#include \""
    s += PATH_API
    s += "\"\n\n"
    s += obj_code
    s += `
int main(int argc, char *argv[], char *envp[]) {
    jule::setup_argv(argc, argv);
    jule::setup_envp(envp);

    __jule_call_initializers();
    `
    if env::TEST {
        s += "test_point();"
    } else {
        s += "entry_point();"
    }

    s += `

    return EXIT_SUCCESS;
}`
    obj_code = s
}

// Generates C++ codes from SymbolTables.
pub fn gen(mut &ir: &IR): str {
    let mut oc = ObjectCoder.new(ir)
    let mut global_initializers = ""
    let mut obj = ""
    obj += oc.gen_links()
    obj += "\n"
    obj += oc.gen_prototypes()
    obj += "\n\n"
    obj += oc.gen_globals(global_initializers)
    obj += "\n"
    obj += oc.gen_structs()
    obj += oc.gen_fns()
    obj += "\n"
    obj += oc.gen_init_caller(global_initializers)
    obj += "\n"
    ret obj
}*/
