// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "env"
use "obj"
use "opt"
use "std/conv"
use "std/fmt"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/sema"
use "std/jule/token"
use "std/jule/types"
use "std/math"
use "std/os"
use "std/runtime"
use "std/strings"
use "std/unicode/utf8"

const collectionIdent = "__jule_collection"
const collectionItIdent = "it"

// Common group of semantic analysis expression model types and optimizer specific types.
enum compExprModel: type {
	ExprModel: sema::ExprModel,
	str,  // For built-in expressions.
	&str, // For built-in expressions.
	&opt::UnsafeBinaryExprModel,
	&opt::UnsafeIndexingExprModel,
	&opt::StrCompExprModel,
	&opt::RefExprModel,
	&opt::EmptyCompareExprModel,
	&opt::UnsafeDerefExprModel,
	&opt::UnsafeCastingExprModel,
}

struct exprCoder {
	oc: &ObjectCoder

	// It will executed before common variable handling algorithm.
	// If it returns true, common algorithm will not be executed.
	varPrefixes: []fn(mut v: &sema::Var): bool
}

impl exprCoder {
	static fn new(mut &oc: &ObjectCoder): &exprCoder {
		ret &exprCoder{
			oc: oc,
		}
	}

	fn string(mut &self, &c: &constant::Const) {
		content := c.ReadStr()
		if len(content) == 0 { // Empty.
			self.oc.write(typeCoder.Str + "()")
			ret
		}
		len := conv::FmtInt(i64(len(content)), 10)
		self.oc.write(typeCoder.Str)
		self.oc.write("::lit(")
		cstrLit(self.oc.Buf, content)
		self.oc.write(", ")
		self.oc.write(len)
		self.oc.write(")")
	}

	fn boolean(mut &self, b: bool) {
		if b {
			self.oc.write("true")
		} else {
			self.oc.write("false")
		}
	}

	fn nilLit(mut &self) {
		self.oc.write("nullptr")
	}

	fn ftoaSpecialCases(mut &self, &x: f64): bool {
		match {
		| math::IsNaN(x):
			self.oc.write("NAN")
		| math::IsInf(x, 1):
			self.oc.write("INFINITY")
		| math::IsInf(x, -1):
			self.oc.write("-INFINITY")
		|:
			ret false
		}
		ret true
	}

	fn float32(mut &self, &c: &constant::Const) {
		x := c.AsF64()

		// Special cases.
		if self.ftoaSpecialCases(x) {
			ret
		}

		match {
		| x == types::MaxF32:
			self.oc.write("jule::MAX_F32")
		| x == types::MinF32:
			self.oc.write("jule::MIN_F32")
		|:
			ftoa(self.oc.Buf, x, 1<<5)
			self.oc.write("f")
		}
	}

	fn float64(mut &self, &c: &constant::Const) {
		x := c.AsF64()

		// Special cases.
		if self.ftoaSpecialCases(x) {
			ret
		}

		match {
		| x == types::MaxF64:
			self.oc.write("jule::MAX_F64")
		| x == types::MinF64:
			self.oc.write("jule::MIN_F64")
		|:
			ftoa(self.oc.Buf, x, 1<<6)
		}
	}

	fn constant(mut &self, mut c: &constant::Const) {
		match {
		| c.IsStr():
			self.string(c)
		| c.IsBool():
			self.boolean(c.ReadBool())
		| c.IsF64():
			match {
			| c.Kind == types::Kind.F32:
				self.float32(c)
			|:
				self.float64(c)
			}
		| c.IsI64():
			itoa(self.oc.Buf, c.ReadI64())
		| c.IsU64():
			utoa(self.oc.Buf, c.ReadU64())
		| c.IsNil():
			self.nilLit()
		|:
			self.oc.write("<unimplemented_constant_expression>")
		}
	}

	fn operatorOverloadingUnary(mut &self, mut &s: &sema::StructIns, op: token::Id, mut e: compExprModel) {
		const Unary = true
		mut f := obj::FindOperator(s, op, Unary)
		if f == nil {
			panic("cxx: unary operator overloading is not exist, this is an implementation mistake")
		}
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(&")
		self.possibleRefExpr(e)
		self.oc.write(")")
	}

	fn divByZeroBinary(mut &self, &op: &token::Token, mut &l: &sema::OperandExprModel, mut &r: &sema::OperandExprModel) {
		const xVar = "__jule_x"
		const yVar = "__jule_y"
		self.oc.write("({ ")
		self.oc.tc.kind(self.oc.Buf, l.Kind)
		self.oc.write(" ")
		self.oc.write(xVar)
		self.oc.write(" = ")
		self.possibleRefExpr(l.Model)
		self.oc.write("; ")
		self.oc.tc.kind(self.oc.Buf, r.Kind)
		self.oc.write(" ")
		self.oc.write(yVar)
		self.oc.write(" = ")
		self.possibleRefExpr(r.Model)
		self.oc.write("; if (")
		self.oc.write(yVar)
		self.oc.write(` == 0) __jule_panic_s("runtime: divide by zero"`)
		if !env::Production {
			self.oc.write(" \"\\nlocation: ")
			self.oc.locInfo(op)
			self.oc.write("\"")
		}
		self.oc.write("); ((")
		self.oc.tc.kind(self.oc.Buf, l.Kind)
		self.oc.write(")(")
		self.oc.write(xVar)
		match op.Id {
		| token::Id.Solidus
		| token::Id.SolidusEq:
			self.oc.write(" / ")
		| token::Id.Percent
		| token::Id.PercentEq:
			self.oc.write(" % ")
		}
		self.oc.write(yVar)
		self.oc.write(")); })")
	}

	fn _unsafeBinary(mut &self, mut &buf: strings::Builder, &l: str, &r: str,
		mut &lk: &sema::Type, mut &rk: &sema::Type, op: token::Id, kind: str) {
		// Operator overloading.
		if lk.Struct() != nil {
			mut s := lk.Struct()
			operatorOverloadingBinary(buf, s, l, r, op, kind)
			ret
		}

		// Special cases for comparable types.
		if op == token::Id.Eqs || op == token::Id.NotEq {
			match {
			| obj::IsAny(lk):
				// If this binary operator comparing <any> type.
				// The left operand is will be <any> one always.
				if !rk.IsNil() && !obj::IsAny(rk) {
					buf.WriteByte('(')!
					if op == token::Id.NotEq {
						buf.WriteByte('!')!
					}
					i := self.oc.pushAnyType(rk)
					buf.WriteStr(anyTypeIdent)!
					buf.WriteStr(conv::Itoa(i))!
					buf.WriteStr("_compare(")!
					buf.WriteStr(l)!
					buf.WriteStr(", ")!
					buf.WriteStr(r)!
					buf.WriteStr("))")!
					ret
				}
			| lk.Arr() != nil:
				// If this binary operator comparing array type.
				// The left operand is will be array one always.
				arr := lk.Arr()
				mut f := obj::RuntimeFindFn(self.oc.ir.Runtime, obj::RuntimeFunc.arrayCmp)
				mut ins := obj::FindFnGenericInstance(f, arr.Elem)
				if op == token::Id.NotEq {
					buf.WriteByte('!')!
				}
				identCoder.funcIns(buf, ins)
				buf.WriteByte('(')!
				buf.WriteStr(l)!
				buf.WriteStr(".begin(), ")!
				buf.WriteStr(r)!
				buf.WriteStr(".begin(), ")!
				buf.WriteStr(conv::Itoa(arr.N))!
				buf.WriteByte(')')!
				ret
			}
		}

		match op {
		| token::Id.Plus | token::Id.Minus | token::Id.Star | token::Id.Shl:
			// guarantee unsigned integer wrap around
			lp := lk.Prim()
			if lp != nil && types::IsUnsigInt(lp.Kind) {
				buf.WriteByte('(')!
				self.oc.tc.prim(buf, lp)
				buf.WriteByte(')')!
			}
		}

		buf.WriteByte('(')!
		buf.WriteStr(l)!
		buf.WriteByte(' ')!
		buf.WriteStr(kind)!
		buf.WriteByte(' ')!
		buf.WriteStr(r)!
		buf.WriteByte(')')!
	}

	fn unsafeBinary(mut &self, mut m: &sema::BinaryExprModel) {
		i := self.oc.Buf.Len()
		mut oldbuf := unsafe { self.oc.Buf.Buf() }
		self.possibleRefExpr(m.Left.Model)
		l := str(unsafe { self.oc.Buf.Buf()[i:] })
		unsafe { self.oc.Buf.SetBuf(oldbuf) }
		self.possibleRefExpr(m.Right.Model)
		r := str(unsafe { self.oc.Buf.Buf()[i:] })
		unsafe { self.oc.Buf.SetBuf(oldbuf) }
		self._unsafeBinary(self.oc.Buf, l, r, m.Left.Kind, m.Right.Kind, m.Op.Id, m.Op.Kind)
	}

	fn shl(mut &self, mut &l: &sema::OperandExprModel, mut &r: &sema::OperandExprModel) {
		const xVar = "__jule_x"
		const yVar = "__jule_y"
		self.oc.write("({ ")
		self.oc.tc.kind(self.oc.Buf, l.Kind)
		self.oc.write(" ")
		self.oc.write(xVar)
		self.oc.write(" = ")
		self.possibleRefExpr(l.Model)
		self.oc.write("; ")
		self.oc.tc.kind(self.oc.Buf, r.Kind)
		self.oc.write(" ")
		self.oc.write(yVar)
		self.oc.write(" = ")
		self.possibleRefExpr(r.Model)
		self.oc.write("; ((")
		self.oc.tc.kind(self.oc.Buf, l.Kind)
		self.oc.write(")(")
		self.oc.write(yVar)
		self.oc.write(" >= ")
		self.oc.write(conv::Itoa(types::BitSizeOf(l.Kind.Prim().Kind)))
		self.oc.write(" ? 0 : ")
		self.oc.write(xVar)
		self.oc.write(" << ")
		self.oc.write(yVar)
		self.oc.write(")); })")
	}

	fn shr(mut &self, mut &l: &sema::OperandExprModel, mut &r: &sema::OperandExprModel) {
		const xVar = "__jule_x"
		const yVar = "__jule_y"
		self.oc.write("({ ")
		self.oc.tc.kind(self.oc.Buf, l.Kind)
		self.oc.write(" ")
		self.oc.write(xVar)
		self.oc.write(" = ")
		self.possibleRefExpr(l.Model)
		self.oc.write("; ")
		self.oc.tc.kind(self.oc.Buf, r.Kind)
		self.oc.write(" ")
		self.oc.write(yVar)
		self.oc.write(" = ")
		self.possibleRefExpr(r.Model)
		self.oc.write("; ((")
		self.oc.tc.kind(self.oc.Buf, l.Kind)
		self.oc.write(")(")
		self.oc.write(yVar)
		self.oc.write(" >= ")
		self.oc.write(conv::Itoa(types::BitSizeOf(l.Kind.Prim().Kind)))
		self.oc.write(" ? 0 : ")
		self.oc.write(xVar)
		self.oc.write(" >> ")
		self.oc.write(yVar)
		self.oc.write(")); })")
	}

	fn binary(mut &self, mut m: &sema::BinaryExprModel) {
		match m.Op.Id {
		| token::Id.Solidus | token::Id.Percent:
			// Do not check division safety of structures and skip if safety disabled.
			if env::Safety && m.Left.Kind.Struct() == nil {
				self.divByZeroBinary(m.Op, m.Left, m.Right)
				ret
			}
		| token::Id.Shl:
			// Do not check shifting of structures.
			if m.Left.Kind.Struct() == nil {
				self.shl(m.Left, m.Right)
				ret
			}
		| token::Id.Shr:
			// Do not check shifting of structures.
			if m.Left.Kind.Struct() == nil {
				self.shr(m.Left, m.Right)
				ret
			}
		}
		self.unsafeBinary(m)
	}

	fn var(mut &self, mut m: &sema::Var) {
		for _, prefix in self.varPrefixes {
			if prefix(m) {
				ret
			}
		}
		if m.Binded {
			d := obj::FindDirective(m.Directives, build::Directive.Namespace)
			if d != nil {
				self.oc.writeBytes(concatAllParts(d.Args...))
				self.oc.write("::")
			}
		}
		identCoder.var(self.oc.Buf, m)
	}

	fn structureIns(mut &self, mut m: &sema::StructIns) {
		self.oc.tc.structureIns(self.oc.Buf, m)
	}

	fn unary(mut &self, mut m: &sema::UnaryExprModel) {
		// Operator overloading.
		if m.Expr.Kind.Struct() != nil {
			mut s := m.Expr.Kind.Struct()
			self.operatorOverloadingUnary(s, m.Op.Id, m.Expr.Model)
			ret
		}

		match m.Op.Id {
		| token::Id.Caret:
			self.oc.write("(~(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write("))")
			ret
		| token::Id.Star:
			if env::Production || m.Expr.Kind.Sptr() == nil {
				break
			}
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".get(\"")
			self.oc.locInfo(m.Op)
			self.oc.write("\")")
			ret
		}
		self.oc.write("(")
		self.oc.write(m.Op.Kind)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write("))")
	}

	fn structureLit(mut &self, mut m: &sema::StructLitExprModel) {
		if m.Strct.Decl.Binded {
			self.oc.write("(")
		}
		self.oc.tc.structureIns(self.oc.Buf, m.Strct)
		if m.Strct.Decl.Binded {
			self.oc.write(")")
		}
		self.oc.write("{")
		// Fields are should be in order.
		// In other words, GCC will produce error(s).
		mut inited := false
	fields:
		for (_, mut f) in m.Strct.Fields {
			for (_, mut arg) in m.Args {
				// Field exist, initialize it with literal expression.
				if arg.Field == f {
					if inited {
						self.oc.write(", ")
					}
					self.oc.write(".")
					identCoder.field(self.oc.Buf, f.Decl)
					self.oc.write("=")
					self.possibleRefExpr(arg.Expr.Model)
					inited = true
					continue fields
				}
			}
			if m.Strct.Decl.Binded {
				// Do not initialize field of binded struct.
				inited = false
				continue
			}
			if inited {
				self.oc.write(", ")
			}
			// Field is not exist in literal arguments.
			// Initialize it by default.
			inited = self.handleFieldByDefault(f)
		}
		self.oc.write("}")
	}

	fn allocStructure(mut &self, mut m: &sema::AllocStructLitExprModel) {
		self.oc.write("jule::new_ptr<")
		identCoder.structureIns(self.oc.Buf, m.Lit.Strct)
		self.oc.write(">(")
		self.structureLit(m.Lit)
		self.oc.write(")")
	}

	fn possibleRefExpr(mut &self, expr: compExprModel) {
		match type expr {
		| &sema::Var:
			v := (&sema::Var)(expr)
			if v.Reference {
				self.oc.write("(*(")
				self.model(expr)
				self.oc.write("))")
				ret
			}
		}
		self.model(expr)
	}

	fn castTraitFromTrait(mut &self, mut &m: &sema::CastingExprModel, mut t1: &sema::Trait, mut t2: &sema::Trait) {
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".map(")
		self.oc.pushAndWriteMaskMapper(t1, t2)
		self.oc.write(")")
	}

	// Casting expression.
	//
	// Special cases:
	//  - The any type castings should be came first than others.
	//    Otherwise, code generation might be wrong because <any> the
	//    uses special casting algorithms.
	fn casting(mut &self, mut m: &sema::CastingExprModel) {
		match {
		| obj::IsAny(m.Kind):
			if m.ExprKind.IsNil() {
				self.oc.write(typeCoder.Any + "()")
				ret
			}
			if m.ExprKind.TypeEnum() != nil {
				self.possibleRefExpr(m.Expr.Model)
				ret
			}
			i := self.oc.pushAnyType(m.ExprKind)
			self.oc.write(typeCoder.Any + "(")
			match type m.Expr.Model {
			| &constant::Const:
				prim := m.ExprKind.Prim()
				if prim != nil && types::IsInt(prim.Kind) {
					self.oc.write("static_cast<")
					self.oc.tc.prim(self.oc.Buf, prim)
					self.oc.write(">(")
					self.possibleRefExpr(m.Expr.Model)
					self.oc.write(")")
					break
				}
				fall
			|:
				self.possibleRefExpr(m.Expr.Model)
			}
			self.oc.write(", &" + anyTypeIdent)
			self.oc.write(conv::Itoa(i))
			self.oc.write(")")
			ret
		| obj::IsAny(m.ExprKind):
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".")
			if m.Kind.Sptr() != nil {
				self.oc.write("cast_ptr<")
				self.oc.tc.kind(self.oc.Buf, m.Kind.Sptr().Elem)
			} else {
				self.oc.write("cast<")
				self.oc.tc.kind(self.oc.Buf, m.Kind)
			}
			self.oc.write(">(")
			if !env::Production {
				self.oc.write("\"")
				self.oc.locInfo(m.Token)
				self.oc.write("\", ")
			}
			self.oc.write("&" + anyTypeIdent)
			self.oc.write(conv::Itoa(self.oc.pushAnyType(m.Kind)))
			self.oc.write(")")
			ret
		| m.ExprKind.Ptr() != nil
		| m.Kind.Ptr() != nil:
			self.oc.write("((")
			self.oc.tc.kind(self.oc.Buf, m.Kind)
			self.oc.write(")(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write("))")
			ret
		| m.ExprKind.Trait() != nil:
			if m.Kind.Trait() != nil {
				self.castTraitFromTrait(m, m.Kind.Trait(), m.ExprKind.Trait())
				ret
			}
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".")
			if m.Kind.Sptr() != nil {
				self.oc.write("cast_ptr<")
				self.oc.tc.kind(self.oc.Buf, m.Kind.Sptr().Elem)
			} else {
				self.oc.write("cast<")
				self.oc.tc.kind(self.oc.Buf, m.Kind)
			}
			self.oc.write(">(")
			if !env::Production {
				self.oc.write("\"")
				self.oc.locInfo(m.Token)
				self.oc.write("\", ")
			}
			self.oc.write("(" + typeCoder.Trait + "::Type*)&")
			identCoder.traitDecl(self.oc.Buf, m.ExprKind.Trait())
			self.oc.write("_mptr_data")
			self.oc.write(conv::Itoa(obj::FindTraitTypeOffset(m.ExprKind.Trait(), m.Kind)))
			self.oc.write(")")
			ret
		| m.Kind.Trait() != nil:
			self.oc.tc.kind(self.oc.Buf, m.Kind)
			self.oc.write("(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(", (" + typeCoder.Trait + "::Type*)&")
			identCoder.traitDecl(self.oc.Buf, m.Kind.Trait())
			self.oc.write("_mptr_data")
			self.oc.write(conv::Itoa(obj::FindTraitTypeOffset(m.Kind.Trait(), m.ExprKind)))
			self.oc.write(")")
			ret
		}
		mut prim := m.Kind.Prim()
		if prim != nil && prim.IsStr() {
			mut eprim := m.ExprKind.Prim()
			if eprim != nil && prim != nil {
				if eprim.IsU8() {
					self.oc.write("__jule_strFromByte(")
				} else {
					self.oc.write("__jule_strFromRune(")
				}
				self.possibleRefExpr(m.Expr.Model)
				self.oc.write(")")
				ret
			}
			mut slc := m.ExprKind.Slc()
			if slc != nil {
				eprim = slc.Elem.Prim()
				// []rune or []byte
				if eprim.IsI32() {
					self.oc.write("__jule_runesToStr(")
				} else {
					self.oc.write("__jule_bytesToStr(")
				}
				self.possibleRefExpr(m.Expr.Model)
				self.oc.write(")")
				ret
			}
		}
		prim = m.ExprKind.Prim()
		if prim != nil && prim.IsStr() {
			mut slc := m.Kind.Slc()
			if slc != nil {
				prim = slc.Elem.Prim()
				// []rune or []byte
				if prim.IsI32() {
					self.oc.write("__jule_strToRunes(")
				} else {
					self.oc.write("__jule_strToBytes(")
				}
				self.possibleRefExpr(m.Expr.Model)
				self.oc.write(")")
				ret
			}
		}
		self.oc.write("static_cast<")
		self.oc.tc.kind(self.oc.Buf, m.Kind)
		self.oc.write(">(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(")")
	}

	fn args(mut &self, mut &m: &sema::FnCallExprModel) {
		mut j := 0
		if m.Func.Owner != nil && !m.Func.Decl.Statically ||
			len(m.Func.Params) > 0 && m.Func.Params[0].Decl.IsSelf() {
			j++ // Skip receiver parameter.
		}
		for i, arg in m.Args {
			p := m.Func.Params[j]
			if p.Decl != nil && p.Decl.Reference {
				match type arg {
				| &sema::Var:
					v := (&sema::Var)(arg)
					if v.Reference {
						self.model(arg)
						goto end
					}
				}
				self.oc.write("&(")
				self.model(arg)
				self.oc.write(")")
				goto end
			}
			self.possibleRefExpr(arg)
		end:
			if len(m.Args)-i > 1 {
				self.oc.write(", ")
			}
			j++
		}
	}

	fn modelForCall(mut &self, mut expr: compExprModel) {
		match type expr {
		| &sema::FnIns:
			self.funcIns((&sema::FnIns)(expr))
			ret
		| &sema::StructSubIdentExprModel:
			mut ssie := (&sema::StructSubIdentExprModel)(expr)
			if ssie.Method != nil {
				self.funcIns(ssie.Method)
				ret
			}
		}
		self.possibleRefExpr(expr)
	}

	fn pushCallInf(mut &self, &m: &sema::FnCallExprModel) {
		if env::Production || !m.Func.Anon {
			self.oc.write("(")
			ret
		}
		if m.Func.Anon {
			match type m.Expr {
			| &sema::StructSubIdentExprModel:
				if (&sema::StructSubIdentExprModel)(m.Expr).Field.Decl.Owner.Binded {
					self.oc.write("(")
					ret
				}
			}
			self.oc.write(".call")
		}
		self.oc.write("(\"")
		self.oc.locInfo(m.Token)
		self.oc.write("\"")
		if len(m.Args) != 0 {
			self.oc.write(", ")
		}
	}

	fn isWrapped(mut &self, mut &m: &sema::FnCallExprModel): bool {
		if !m.Func.IsBuiltin() && len(m.Func.Decl.Params) > 0 && m.Func.Decl.Params[0].IsSelf() {
			match type m.Expr {
			| &sema::StructSubIdentExprModel:
				mut ssie := (&sema::StructSubIdentExprModel)(m.Expr)
				match {
				| m.Func.Decl.Params[0].IsRef()
				| ssie.Expr.Kind.Sptr() != nil:
					break
				|:
					if ssie.Expr.Kind.Struct() != nil {
						if !ssie.Expr.Lvalue {
							self.oc.write("({ auto _wrap_copy = ")
							self.model(ssie.Expr.Model)
							self.oc.write("; ")
							ret true
						}
					}
				}
			}
		}
		ret false
	}

	fn writeReceiver(mut &self, mut m: compExprModel): (safeDeref: bool) {
		match type m {
		| &sema::UnaryExprModel:
			self.possibleRefExpr((&sema::UnaryExprModel)(m).Expr.Model)
			ret true
		| &opt::UnsafeDerefExprModel:
			self.possibleRefExpr((&opt::UnsafeDerefExprModel)(m).Base.Expr.Model)
			ret false
		|:
			panic("cxx: implementation mistake, this panic call should be unreachable")
		}
	}

	fn pureFuncCall(mut &self, mut &m: &sema::FnCallExprModel) {
		wrapped := self.isWrapped(m)
		self.modelForCall(m.Expr)
		if !m.Func.IsBuiltin() {
			if m.Func.Decl.Binded && len(m.Func.Generics) > 0 {
				if !obj::HasDirective(m.Func.Decl.Directives, build::Directive.Cdef) {
					self.oc.write("<")
					for (i, mut g) in m.Func.Generics {
						self.oc.tc.kind(self.oc.Buf, g.Kind)
						if len(m.Func.Generics)-i > 1 {
							self.oc.write(", ")
						}
					}
					self.oc.write(">")
				}
			}
		}
		self.pushCallInf(m)
		if m.Func.AsAnon && !m.Func.Anon {
			// Function used as anonymous.
			// So pass nullptr to ctx parameter.
			// Do not pass nullptr if function is anonymous,
			// beacause it stores ctx data internally and it will pass.
			self.oc.write("nullptr")
			if len(m.Args) > 0 {
				self.oc.write(", ")
			}
		}
		if !m.Func.IsBuiltin() && len(m.Func.Decl.Params) > 0 && m.Func.Decl.Params[0].IsSelf() {
			match type m.Expr {
			| &sema::StructSubIdentExprModel:
				mut ssie := (&sema::StructSubIdentExprModel)(m.Expr)
				match {
				| m.Func.Decl.Params[0].IsRef():
					// Ignore dereferencing, use data directly to call method.
					_ = self.writeReceiver(ssie.Expr.Model)
				| ssie.Expr.Kind.Sptr() != nil:
					// Ignore dereferencing, use data directly to call [ptr] method.
					safe := self.writeReceiver(ssie.Expr.Model)
					if safe {
						self.oc.write(".ptr(")
						if !env::Production {
							self.oc.write("\"")
							self.oc.locInfo(m.Token)
							self.oc.write("\"")
						}
						self.oc.write(")")
					}
				|:
					if ssie.Expr.Kind.Struct() != nil {
						match type ssie.Expr.Model {
						| &sema::Var:
							v := (&sema::Var)(ssie.Expr.Model)
							if v.Reference {
								break
							}
							fall
						|:
							// Add address taking operation for non-pointers.
							self.oc.write("&")
						}
					}
					if wrapped {
						self.oc.write("_wrap_copy")
					} else if ssie.Expr.Kind.Ptr() == nil {
						self.model(ssie.Expr.Model)
					} else {
						// Ignore dereferencing, use data directly to call method.
						self.possibleRefExpr((&sema::UnaryExprModel)(ssie.Expr.Model).Expr.Model)
					}
				}
				if len(m.Args) > 0 {
					self.oc.write(", ")
				}
			| &sema::TraitSubIdentExprModel:
				self.possibleRefExpr((&sema::TraitSubIdentExprModel)(m.Expr).Expr)
				self.oc.write(".data")
				if len(m.Args) > 0 {
					self.oc.write(", ")
				}
			}
		}
		self.args(m)
		self.oc.write(")")

		if wrapped {
			self.oc.write("; })")
		}
	}

	fn coFuncCall(mut &self, mut &m: &sema::FnCallExprModel) {
		self.oc.write("{\n")
		self.oc.addIndent()
		self.oc.indent()

		const noWrap = ""
		const argData = "__jule_argdata"
		mut i := noWrap
		if len(m.Func.Params) > 0 || m.Func.AsAnon {
			i = conv::Itoa(self.oc.pushCoSpawn(m.Func))
			t := coSpawnPrefix + coSpawnArgDataSuffix + i
			self.oc.write(t)
			self.oc.write(" *")
			self.oc.write(argData)
			self.oc.write(" = new (std::nothrow) ")
			self.oc.write(t)
			self.oc.write("; if (!")
			self.oc.write(argData)
			self.oc.write(`) __jule_panic((`)
			self.oc.write(typeCoder.U8)
			self.oc.write(`*)"memory allocation failed for concurrent call", 44);` + "\n")
			self.oc.indent()

			// setup function data
			self.oc.write(argData)
			self.oc.write("->")
			self.oc.write(coSpawnArgDataFunc)
			self.oc.write(" = ")
			self.modelForCall(m.Expr)
			self.oc.write(";\n")

			// setup argument data
			for j in m.Func.Params {
				self.oc.indent()
				self.oc.write(argData)
				self.oc.write("->")
				self.oc.write(coSpawnArgDataParam)
				self.oc.write(conv::Itoa(j))
				self.oc.write(" = ")
				self.possibleRefExpr(m.Args[j])
				self.oc.write(";\n")
			}
			self.oc.indent()
		}

		// spawn thread
		if i != noWrap {
			self.oc.write("if (!")
		}
		self.oc.write("__jule_coSpawn((void*)")
		if i == noWrap {
			identCoder.funcIns(self.oc.Buf, m.Func)
		} else {
			self.oc.write(coSpawnPrefix + coSpawnMethodSuffix + i)
		}
		self.oc.write(", ")
		if i == noWrap {
			self.oc.write("NULL")
		} else {
			self.oc.write("(void*)")
			self.oc.write(argData)
		}
		self.oc.write(")")
		if i == noWrap {
			self.oc.write(";")
		} else {
			self.oc.write(") { delete ")
			self.oc.write(argData)
			self.oc.write("; __jule_panic((")
			self.oc.write(typeCoder.U8)
			self.oc.write(`*)"thread creation failed for concurrent call", 42); }`)
		}
		self.oc.write("\n")
		self.oc.doneIndent()
		self.oc.indent()
		self.oc.write("}")
	}

	fn writeUseExpr(mut &self, mut &f: &sema::FnIns, mut d: &sema::Data) {
		if d.Kind.Tup() == nil {
			self.possibleRefExpr(d.Model)
			self.oc.write(";")
			ret
		}
		mut tup := (&sema::TupleExprModel)(d.Model)
		self.oc.tc.rc.tup(self.oc.Buf, f.Result.Tup())
		self.oc.write("{")
		for i, data in tup.Datas {
			self.oc.write("." + resultArgName)
			self.oc.write(conv::Itoa(i))
			self.oc.write("=")
			self.possibleRefExpr(data.Model)
			if len(tup.Datas)-i > 1 {
				self.oc.write(", ")
			}
		}
		self.oc.write("};")
	}

	fn funcCall(mut &self, mut m: &sema::FnCallExprModel) {
		if m.IsCo {
			// Do not check for exceptionals,
			// exceptional functions cannot be called with co.
			self.coFuncCall(m)
			ret
		}
		if m.Func.IsBuiltin() ||
			!m.Func.Decl.Exceptional ||
			m.Except != nil && len(m.Except.Stmts) == 0 {
			self.pureFuncCall(m)
			ret
		}

		// Generate code for exceptional.
		self.oc.write("({\n")
		self.oc.addIndent()
		self.oc.indent()
		self.oc.write("auto except = ")
		self.pureFuncCall(m)
		self.oc.write(";\n")
		self.oc.indent()
		if m.Except != nil {
			if m.Func.Result == nil || !m.Assigned {
				self.oc.write("if (!except.ok()) ")
				self.oc.sc.scope(m.Except)
				self.oc.write("\n")
			} else {
				forwarded := obj::IsForwarded(m.Except)
				self.oc.write("(except.ok()) ? (except.result) : (")
				if forwarded {
					self.oc.write("{")
				}
				mut stmt := m.Except.Stmts[len(m.Except.Stmts)-1]
				match type stmt {
				| &sema::Data:
					m.Except.Stmts = m.Except.Stmts[:len(m.Except.Stmts)-1]
					self.oc.write("{\n")
					self.oc.addIndent()
					self.oc.sc.scopeStmts(m.Except)
					self.oc.write("\n")
					self.oc.indent()
					self.writeUseExpr(m.Func, (&sema::Data)(stmt))
					self.oc.write("\n")
					self.oc.doneIndent()
					self.oc.indent()
					self.oc.write("}")
				|:
					self.oc.sc.scope(m.Except)
				}
				if forwarded {
					self.oc.write(" ")
					self.initExpr(m.Func.Result)
					self.oc.write(";}")
				}
				self.oc.write(");\n")
			}
			self.oc.doneIndent()
		} else {
			self.oc.write(`if (!except.ok()) __jule_panic_s(jule::Str("unhandled exceptional: ") + except.error.type->to_str(except.error.data) + jule::Str("\nlocation: `)
			self.oc.locInfo(m.Token)
			self.oc.write("\"));\n")
			if !m.Func.Decl.IsVoid() {
				self.oc.indent()
				self.oc.write("(except.result);\n")
			}
			self.oc.doneIndent()
		}

		self.oc.indent()
		self.oc.write("})")
	}

	fn slice(mut &self, mut m: &sema::SliceExprModel) {
		if len(m.Elems) == 0 {
			self.oc.tc.asSlice(self.oc.Buf, m.ElemKind)
			self.oc.write("()")
			ret
		}
		self.oc.write("({ auto " + collectionIdent + " = ")
		self.oc.tc.asSlice(self.oc.Buf, m.ElemKind)
		size := conv::Itoa(len(m.Elems))
		self.oc.write("::alloc(")
		self.oc.write(size)
		self.oc.write(", ")
		self.oc.write(size)
		self.oc.write("); auto ")
		self.oc.write(collectionItIdent)
		self.oc.write(" = ")
		self.oc.write(collectionIdent)
		self.oc.write(".begin(); ")
		for i in m.Elems {
			self.oc.write("(*")
			self.oc.write(collectionItIdent)
			self.oc.write("++) = ")
			self.possibleRefExpr(m.Elems[i])
			self.oc.write("; ")
		}
		self.oc.write(collectionIdent)
		self.oc.write("; })")
	}

	fn indexing(mut &self, mut m: &sema::IndexingExprModel) {
		match type m.Expr.Model {
		| &constant::Const:
			// Cosntant string indexed. Use fast way, avoid making literal.
			self.oc.write(typeCoder.Str + "::at(")
			if !env::Production {
				self.oc.write("\"")
				self.oc.locInfo(m.Token)
				self.oc.write("\", ")
			}
			self.oc.write("reinterpret_cast<const " + typeCoder.U8 + "*>(")
			s := (&constant::Const)(m.Expr.Model).ReadStr()
			cstrLit(self.oc.Buf, s)
			self.oc.write("), ")
			self.oc.write(conv::Itoa(len(s)))
			self.oc.write(", ")
			self.possibleRefExpr(m.Index.Model)
			self.oc.write(")")
			ret
		}

		// Index access with safety measures.
		match {
		| m.Expr.Kind.Map() != nil:
			mut _map := m.Expr.Kind.Map()
			mut s := obj::RuntimeFindStruct(self.oc.ir.Runtime, obj::RuntimeStruct._Map)
			mut ins := obj::FindStructGenericInstance(s, _map.Key, _map.Val)
			const Static = false
			mut f := ins.FindMethod("get", Static).Instances[0]
			identCoder.funcIns(self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(", ")
			self.possibleRefExpr(m.Index.Model)
			self.oc.write(")")
		| env::Production
		| m.Expr.Kind.Ptr() != nil
		| obj::IsExprComesFromBind(m.Expr):
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write("[")
			self.possibleRefExpr(m.Index.Model)
			self.oc.write("]")
		|:
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(".at(\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\", ")
			self.possibleRefExpr(m.Index.Model)
			self.oc.write(")")
		}
	}

	fn unsafeIndexing(mut &self, mut m: &opt::UnsafeIndexingExprModel) {
		self.possibleRefExpr(m.Node.Expr.Model)
		// Index access with safety measures.
		match {
		| env::Production
		| m.Node.Expr.Kind.Ptr() != nil
		| m.Node.Expr.Kind.Map() != nil:
			self.oc.write("[")
			self.possibleRefExpr(m.Node.Index.Model)
			self.oc.write("]")
		|:
			self.oc.write(".__at(")
			self.possibleRefExpr(m.Node.Index.Model)
			self.oc.write(")")
		}
	}

	fn anonFunc(mut &self, mut m: &sema::AnonFnExprModel) {
		closure := obj::IsClosure(m)
		ident := self.oc.pushAnonFn(m)
		self.oc.write("jule::__new_closure<")
		self.oc.tc.anonFunc(self.oc.Buf, m.Func)
		self.oc.write(">((void*)")
		self.oc.write(ident)
		if closure {
			self.oc.write(", jule::Ptr<")
			self.oc.write(ident)
			self.oc.write(anonFnCtxSuffix)
			self.oc.write(">::make(")
			self.oc.write(ident)
			self.oc.write(anonFnCtxSuffix + "{")
			for (i, mut v) in m.Captured {
				self.oc.write(".")
				identCoder.var(self.oc.Buf, v)
				self.oc.write("=")
				self.var(v)
				if len(m.Captured)-i > 1 {
					self.oc.write(",")
				}
			}
			self.oc.write("}).as<" + typeCoder.Uintptr + ">(), ")
			self.oc.write(ident)
			self.oc.write(anonFnCtxHandlerSuffix + ")")
		} else {
			self.oc.write(", nullptr, nullptr)")
		}
	}

	fn mapExpr(mut &self, mut m: &sema::MapExprModel) {
		mut s := obj::RuntimeFindStruct(self.oc.ir.Runtime, obj::RuntimeStruct._Map)
		mut ins := obj::FindStructGenericInstance(s, m.Kind.Key, m.Kind.Val)
		const Static = true
		mut maker := ins.FindMethod("make", Static).Instances[0]
		if len(m.Entries) == 0 {
			identCoder.funcIns(self.oc.Buf, maker)
			self.oc.write("()")
			ret
		}

		mut f := ins.FindMethod("set", !Static).Instances[0]

		const mapVar = "__jule_map"
		self.oc.write("({ ")
		self.oc.tc.mapType(self.oc.Buf, m.Kind)
		self.oc.write(" ")
		self.oc.write(mapVar)
		self.oc.write(" = ")
		identCoder.funcIns(self.oc.Buf, maker)
		self.oc.write("(); ")
		for (_, mut pair) in m.Entries {
			self.oc.write("(*")
			identCoder.funcIns(self.oc.Buf, f)
			self.oc.write("(")
			self.oc.write(mapVar)
			self.oc.write(", ")
			self.possibleRefExpr(pair.Key)
			self.oc.write(")) = ")
			self.possibleRefExpr(pair.Val)
			self.oc.write("; ")
		}
		self.oc.write(mapVar)
		self.oc.write("; })")
	}

	fn slicing(mut &self, mut m: &sema::SlicingExprModel) {
		self.possibleRefExpr(m.Expr)
		self.oc.write(".slice(")
		if !env::Production {
			self.oc.write("\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\", ")
		}
		self.possibleRefExpr(m.Left)
		if m.Right != nil {
			self.oc.write(", ")
			self.possibleRefExpr(m.Right)
		}
		self.oc.write(")")
	}

	fn traitSub(mut &self, mut m: &sema::TraitSubIdentExprModel) {
		self.oc.write("((")
		identCoder.traitDecl(self.oc.Buf, m.Trt)
		self.oc.write("MptrData")
		self.oc.write("*)")
		self.possibleRefExpr(m.Expr)
		self.oc.write(".safe_type(")
		if !env::Production {
			self.oc.write("\"")
			self.oc.locInfo(m.Token)
			self.oc.write("\"")
		}
		self.oc.write("))->")
		identCoder.func(self.oc.Buf, m.Method)
	}

	fn structureSub(mut &self, mut m: &sema::StructSubIdentExprModel) {
		self.possibleRefExpr(m.Expr.Model)
		if m.Field == nil {
			ret
		}
		self.oc.write(".")
		identCoder.field(self.oc.Buf, m.Field.Decl)
	}

	fn array(mut &self, mut m: &sema::ArrayExprModel) {
		// Plain initialization if array is zero-length or
		// no specific expression and not able to init elements.
		if m.Kind.N == 0 || len(m.Elems) == 0 && !ableToInit(m.Kind.Elem) {
			self.oc.tc.array(self.oc.Buf, m.Kind)
			self.oc.write("()")
			ret
		}

		// Filled.
		if len(m.Elems) == 2 && m.Elems[1] == nil {
			self.oc.tc.array(self.oc.Buf, m.Kind)
			self.oc.write("(")
			self.possibleRefExpr(m.Elems[0])
			self.oc.write(")")
			ret
		}

		self.oc.write("({ auto " + collectionIdent + " = ")
		self.oc.tc.array(self.oc.Buf, m.Kind)
		self.oc.write("(); auto ")
		self.oc.write(collectionItIdent)
		self.oc.write(" = ")
		self.oc.write(collectionIdent)
		self.oc.write(".begin(); ")
		if len(m.Elems) != m.Kind.N {
			// Define end pointer for remainders.
			self.oc.write("const auto ")
			self.oc.write(collectionIdent)
			self.oc.write("_end = ")
			self.oc.write(collectionIdent)
			self.oc.write(".end(); ")
		}
		for i in m.Elems {
			self.oc.write("(*")
			self.oc.write(collectionItIdent)
			self.oc.write("++) = ")
			self.possibleRefExpr(m.Elems[i])
			self.oc.write("; ")
		}
		if len(m.Elems) != m.Kind.N && ableToInit(m.Kind.Elem) {
			self.fillCollectionByDefault(m.Kind.Elem)
		}
		self.oc.write(collectionIdent)
		self.oc.write("; })")
		ret
	}

	// Writes complete expression model of function instance.
	// Usefull for strict type safety.
	fn funcInsCommon(mut &self, mut m: &sema::FnIns) {
		self.oc.tc.func(self.oc.Buf, m)
		self.oc.write("(")
		self.funcIns(m)
		self.oc.write(")")
	}

	fn funcIns(mut &self, mut m: &sema::FnIns) {
		if m.Decl != nil && m.Decl.Binded {
			d := obj::FindDirective(m.Decl.Directives, build::Directive.Namespace)
			if d != nil {
				self.oc.writeBytes(concatAllParts(d.Args...))
				self.oc.write("::")
			}
		}
		identCoder.funcIns(self.oc.Buf, m)
	}

	fn tuple(mut &self, mut m: &sema::TupleExprModel) {
		for (i, mut d) in m.Datas {
			self.possibleRefExpr(d.Model)
			self.oc.write(";")
			if len(m.Datas)-i > 1 {
				self.oc.write("\n")
				self.oc.indent()
			}
		}
	}

	fn newCall(mut &self, mut m: &sema::BuiltinNewCallExprModel) {
		self.oc.write("jule::new_ptr<")
		self.oc.tc.kind(self.oc.Buf, m.Kind)
		self.oc.write(">(")
		if m.Init != nil {
			self.possibleRefExpr(m.Init)
		} else if ableToInit(m.Kind) {
			self.initExpr(m.Kind)
		}
		self.oc.write(")")
	}

	fn printCall(mut &self, mut m: &sema::BuiltinPrintCallExprModel) {
		self.oc.write("jule::print(")
		mut decl := obj::RuntimeFindFn(self.oc.ir.Runtime, obj::RuntimeFunc.toStr)
		mut f := obj::FindFnGenericInstance(decl, m.Expr.Kind)
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write("))")
	}

	fn printlnCall(mut &self, mut m: &sema::BuiltinPrintlnCallExprModel) {
		self.oc.write("jule::println(")
		mut decl := obj::RuntimeFindFn(self.oc.ir.Runtime, obj::RuntimeFunc.toStr)
		mut f := obj::FindFnGenericInstance(decl, m.Expr.Kind)
		identCoder.funcIns(self.oc.Buf, f)
		self.oc.write("(")
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write("))")
	}

	fn panicCall(mut &self, mut m: &sema::BuiltinPanicCallExprModel) {
		self.oc.write("__jule_panic_s(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(` + jule::Str("\nlocation: `)
		self.oc.locInfo(m.Token)
		self.oc.write("\"));")
	}

	fn errorCall(mut &self, mut m: &sema::BuiltinErrorCallExprModel) {
		self.oc.write("return ")
		if m.Func.Decl.IsVoid() {
			match type m.Err.Model {
			| &sema::Var:
				v := (&sema::Var)(m.Err.Model)
				if v.Ident == token::Kind.Error {
					self.oc.write("jule::VoidExceptional{.error=std::move(except.error)}")
					ret
				}
			}
			self.oc.write("jule::VoidExceptional{.error=" + typeCoder.Any + "(")
		} else {
			self.oc.write("jule::Exceptional<")
			self.oc.tc.rc.codeMut1(self.oc.Buf, m.Func.Result)
			match type m.Err.Model {
			| &sema::Var:
				v := (&sema::Var)(m.Err.Model)
				if v.Ident == token::Kind.Error {
					self.oc.write(">{.error=except.error}")
					ret
				}
			}
			self.oc.write(">{.error=" + typeCoder.Any + "(")
		}
		self.possibleRefExpr(m.Err.Model)
		i := self.oc.pushAnyType(m.Err.Kind)
		self.oc.write(", &" + anyTypeIdent)
		self.oc.write(conv::Itoa(i))
		self.oc.write(")}")
	}

	fn copyCall(mut &self, mut m: &sema::BuiltinCopyCallExprModel) {
		self.oc.write("jule::copy(")
		self.possibleRefExpr(m.Dest.Model)
		self.oc.write(", ")
		self.possibleRefExpr(m.Src.Model)
		self.oc.write(")")
	}

	fn lenCall(mut &self, mut m: &sema::BuiltinLenCallExprModel) {
		mut _map := m.Expr.Kind.Map()
		if _map != nil {
			mut s := obj::RuntimeFindStruct(self.oc.ir.Runtime, obj::RuntimeStruct._Map)
			mut ins := obj::FindStructGenericInstance(s, _map.Key, _map.Val)
			const Static = false
			mut f := ins.FindMethod("len", Static).Instances[0]
			identCoder.funcIns(self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Expr.Model)
			self.oc.write(")")
			ret
		}
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".len()")
	}

	fn capCall(mut &self, mut m: &sema::BuiltinCapCallExprModel) {
		self.possibleRefExpr(m.Expr.Model)
		self.oc.write(".cap()")
	}

	fn deleteCall(mut &self, mut m: &sema::BuiltinDeleteCallExprModel) {
		mut _map := m.Dest.Kind.Map()
		if _map == nil {
			panic("cxx: deleteCall: destination is not map")
		}
		mut s := obj::RuntimeFindStruct(self.oc.ir.Runtime, obj::RuntimeStruct._Map)
		mut ins := obj::FindStructGenericInstance(s, _map.Key, _map.Val)
		const Static = false
		if m.Key != nil {
			mut f := ins.FindMethod("del", Static).Instances[0]
			identCoder.funcIns(self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Dest.Model)
			self.oc.write(", ")
			self.possibleRefExpr(m.Key.Model)
			self.oc.write(")")
		} else {
			mut f := ins.FindMethod("clear", Static).Instances[0]
			identCoder.funcIns(self.oc.Buf, f)
			self.oc.write("(")
			self.possibleRefExpr(m.Dest.Model)
			self.oc.write(")")
		}
	}

	fn makeCallSlice(mut &self, mut &m: &sema::BuiltinMakeCallExprModel) {
		mut slice := m.Kind.Slc()
		init := ableToInit(slice.Elem)
		if init {
			self.oc.write("({ auto " + collectionIdent + " = ")
		}
		self.oc.tc.kind(self.oc.Buf, m.Kind)
		self.oc.write("::alloc(")
		self.possibleRefExpr(m.Len)
		self.oc.write(", ")
		if m.Cap != nil {
			self.possibleRefExpr(m.Cap)
		} else {
			self.possibleRefExpr(m.Len)
		}
		self.oc.write(")")
		if !init {
			ret
		}
		self.oc.write("; ")
		self.initCollection(slice.Elem)
		self.oc.write(" " + collectionIdent + "; })")
	}

	fn makeCallStr(mut &self, mut &m: &sema::BuiltinMakeCallExprModel) {
		self.oc.write(typeCoder.Str)
		self.oc.write("::alloc(")
		self.possibleRefExpr(m.Len)
		if m.Cap != nil {
			self.oc.write(", ")
			self.possibleRefExpr(m.Cap)
		}
		self.oc.write(")")
	}

	fn makeCall(mut &self, mut m: &sema::BuiltinMakeCallExprModel) {
		if m.Kind.Slc() != nil {
			self.makeCallSlice(m)
			ret
		}
		self.makeCallStr(m)
	}

	fn pushToSlice(mut &self, mut m: &opt::PushToSliceExprModel) {
		// Use l-value advantage and define reference variable to destination
		// in the child scope to avoid potential repeated high-cost memory access overhead.
		const destIdent = "__jule_push_dest"

		self.oc.write("{ ")
		self.oc.tc.asSlice(self.oc.Buf, m.Elems.ElemKind)

		mut ptr := false
		match type m.Dest {
		| &sema::UnaryExprModel:
			// Use raw pointer directly if exist.
			mut u := (&sema::UnaryExprModel)(m.Dest)
			if u.Expr.Kind.Ptr() != nil {
				self.oc.write(" *" + destIdent + " = ")
				self.possibleRefExpr(u.Expr.Model)
				self.oc.write("; ")
				ptr = true
				break
			}
			fall
		|:
			self.oc.write(" &" + destIdent + " = ")
			self.possibleRefExpr(m.Dest)
			self.oc.write("; ")
		}
		// Pushed single item.
		if len(m.Elems.Elems) == 1 {
			if ptr {
				self.oc.write(destIdent + "->push(")
			} else {
				self.oc.write(destIdent + ".push(")
			}
			self.possibleRefExpr(m.Elems.Elems[0])
			self.oc.write("); }")
			ret
		}
		// Pushed more than single item.
		// Pre-allocate enough capacity if not exist for appendation.
		if ptr {
			self.oc.write(destIdent + "->alloc_for_append(")
		} else {
			self.oc.write(destIdent + ".alloc_for_append(")
		}
		self.oc.write(conv::Itoa(len(m.Elems.Elems)))
		self.oc.write("); ")
		for (_, mut e) in m.Elems.Elems {
			self.oc.write(destIdent)
			// Use the "__push" method to skip allocation boundary checking.
			if ptr {
				self.oc.write("->__push(")
			} else {
				self.oc.write(".__push(")
			}
			self.possibleRefExpr(e)
			self.oc.write("); ")
		}
		self.oc.write("}")
	}

	fn appendToSlice(mut &self, mut m: &opt::AppendToSliceExprModel) {
		self.oc.write("(")
		self.possibleRefExpr(m.Dest)
		self.oc.write(").append(")
		self.possibleRefExpr(m.Slice)
		self.oc.write(");")
	}

	fn appendCall(mut &self, mut m: &sema::BuiltinAppendCallExprModel) {
		self.oc.write("jule::append(")
		self.possibleRefExpr(m.Dest)
		self.oc.write(",")
		self.possibleRefExpr(m.Elements)
		self.oc.write(")")
	}

	fn sizeof(mut &self, mut m: &sema::SizeofExprModel) {
		self.oc.write("sizeof(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(")")
	}

	fn alignof(mut &self, mut m: &sema::AlignofExprModel) {
		self.oc.write("alignof(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(")")
	}

	fn runeLit(mut &self, m: &sema::RuneExprModel) {
		if m.Code <= 127 { // ASCII.
			self.oc.Buf.WriteByte('\'')!
			mut b := sbtoa(byte(m.Code))
			if b == "'" {
				self.oc.Buf.WriteByte('\\')!
			}
			self.oc.Buf.WriteStr(b)!
			self.oc.Buf.WriteByte('\'')!
			ret
		}
		itoa(self.oc.Buf, i64(m.Code))
	}

	fn structureStatic(mut &self, mut m: &sema::StructStaticIdentExprModel) {
		identCoder.funcIns(self.oc.Buf, m.Method)
	}

	fn backendEmit(mut &self, mut m: &sema::BackendEmitExprModel) {
		if len(m.Exprs) == 0 {
			self.oc.write(m.Code)
			ret
		}
		n := self.oc.Buf.Len()
		mut args := make([]any, len(m.Exprs))
		for (i, mut expr) in m.Exprs {
			self.possibleRefExpr(expr)
			mut buf := unsafe { self.oc.Buf.Buf() }
			args[i] = str(buf[n:])
			unsafe { self.oc.Buf.SetBuf(buf[:n]) }
		}
		self.oc.write(fmt::Format(m.Code, args...))
	}

	fn free(mut &self, mut m: &sema::FreeExprModel) {
		self.possibleRefExpr(m.Expr)
		if env::RC {
			self.oc.write(".dealloc()")
			ret
		}
		self.oc.write(".__free()")
	}

	fn strComp(mut &self, mut m: &opt::StrCompExprModel) {
		if m.NotEq {
			self.oc.write("(!")
		}
		s := m.Right.ReadStr()
		self.possibleRefExpr(m.Left)
		self.oc.write(".equal(")
		cstrLit(self.oc.Buf, s)
		self.oc.write(", ")
		self.oc.write(conv::Itoa(len(s)))
		self.oc.write(")")
		if m.NotEq {
			self.oc.write(")")
		}
	}

	fn emptyCompare(mut &self, mut m: &opt::EmptyCompareExprModel) {
		if m.Neg {
			self.oc.write("!")
		}
		self.oc.write("(")
		self.possibleRefExpr(m.Expr)
		self.oc.write(").empty()")
	}

	fn unsafeDeref(mut &self, mut m: &opt::UnsafeDerefExprModel) {
		match {
		| m.Base.Expr.Kind.Sptr() != nil:
			self.oc.write("(*")
			self.possibleRefExpr(m.Base.Expr.Model)
			self.oc.write(".alloc)")
		|:
			panic("cxx: implementation mistake, this panic call should be unreachable")
		}
	}

	fn unsafeCasting(mut &self, mut m: &opt::UnsafeCastingExprModel) {
		match {
		| obj::IsAny(m.Base.ExprKind):
			self.possibleRefExpr(m.Base.Expr.Model)
			if m.Base.Kind.Sptr() != nil {
				self.oc.write(".unsafe_cast_ptr<")
				self.oc.tc.kind(self.oc.Buf, m.Base.Kind.Sptr().Elem)
			} else {
				self.oc.write(".unsafe_cast<")
				self.oc.tc.kind(self.oc.Buf, m.Base.Kind)
			}
			self.oc.write(">()")
		|:
			panic("cxx: implementation mistake, this panic call should be unreachable")
		}
	}

	fn model(mut &self, mut m: compExprModel) {
		match type m {
		| str:
			self.oc.write(str(m))
		| &str:
			self.oc.write(*(&str)(m))
		| &sema::Type:
			self.oc.tc.kind(self.oc.Buf, (&sema::Type)(m))
		| &constant::Const:
			self.constant((&constant::Const)(m))
		| &sema::Var:
			self.var((&sema::Var)(m))
		| &sema::StructIns:
			self.structureIns((&sema::StructIns)(m))
		| &sema::FnIns:
			self.funcInsCommon((&sema::FnIns)(m))
		| &opt::UnsafeBinaryExprModel:
			self.unsafeBinary((&opt::UnsafeBinaryExprModel)(m).Node)
		| &sema::BinaryExprModel:
			self.binary((&sema::BinaryExprModel)(m))
		| &sema::UnaryExprModel:
			self.unary((&sema::UnaryExprModel)(m))
		| &sema::StructLitExprModel:
			self.structureLit((&sema::StructLitExprModel)(m))
		| &sema::AllocStructLitExprModel:
			self.allocStructure((&sema::AllocStructLitExprModel)(m))
		| &sema::CastingExprModel:
			self.casting((&sema::CastingExprModel)(m))
		| &sema::FnCallExprModel:
			self.funcCall((&sema::FnCallExprModel)(m))
		| &sema::SliceExprModel:
			self.slice((&sema::SliceExprModel)(m))
		| &sema::ArrayExprModel:
			self.array((&sema::ArrayExprModel)(m))
		| &opt::UnsafeIndexingExprModel:
			self.unsafeIndexing((&opt::UnsafeIndexingExprModel)(m))
		| &sema::IndexingExprModel:
			self.indexing((&sema::IndexingExprModel)(m))
		| &sema::AnonFnExprModel:
			self.anonFunc((&sema::AnonFnExprModel)(m))
		| &sema::MapExprModel:
			self.mapExpr((&sema::MapExprModel)(m))
		| &sema::SlicingExprModel:
			self.slicing((&sema::SlicingExprModel)(m))
		| &sema::TraitSubIdentExprModel:
			self.traitSub((&sema::TraitSubIdentExprModel)(m))
		| &sema::StructSubIdentExprModel:
			self.structureSub((&sema::StructSubIdentExprModel)(m))
		| &sema::TupleExprModel:
			self.tuple((&sema::TupleExprModel)(m))
		| &sema::BuiltinPrintCallExprModel:
			self.printCall((&sema::BuiltinPrintCallExprModel)(m))
		| &sema::BuiltinPrintlnCallExprModel:
			self.printlnCall((&sema::BuiltinPrintlnCallExprModel)(m))
		| &sema::BuiltinNewCallExprModel:
			self.newCall((&sema::BuiltinNewCallExprModel)(m))
		| &sema::BuiltinPanicCallExprModel:
			self.panicCall((&sema::BuiltinPanicCallExprModel)(m))
		| &sema::BuiltinErrorCallExprModel:
			self.errorCall((&sema::BuiltinErrorCallExprModel)(m))
		| &sema::BuiltinMakeCallExprModel:
			self.makeCall((&sema::BuiltinMakeCallExprModel)(m))
		| &sema::BuiltinAppendCallExprModel:
			self.appendCall((&sema::BuiltinAppendCallExprModel)(m))
		| &sema::BuiltinCopyCallExprModel:
			self.copyCall((&sema::BuiltinCopyCallExprModel)(m))
		| &sema::BuiltinLenCallExprModel:
			self.lenCall((&sema::BuiltinLenCallExprModel)(m))
		| &sema::BuiltinCapCallExprModel:
			self.capCall((&sema::BuiltinCapCallExprModel)(m))
		| &sema::BuiltinDeleteCallExprModel:
			self.deleteCall((&sema::BuiltinDeleteCallExprModel)(m))
		| &sema::SizeofExprModel:
			self.sizeof((&sema::SizeofExprModel)(m))
		| &sema::AlignofExprModel:
			self.alignof((&sema::AlignofExprModel)(m))
		| &sema::RuneExprModel:
			self.runeLit((&sema::RuneExprModel)(m))
		| &sema::StructStaticIdentExprModel:
			self.structureStatic((&sema::StructStaticIdentExprModel)(m))
		| &sema::BackendEmitExprModel:
			self.backendEmit((&sema::BackendEmitExprModel)(m))
		| &sema::FreeExprModel:
			self.free((&sema::FreeExprModel)(m))
		| &opt::StrCompExprModel:
			self.strComp((&opt::StrCompExprModel)(m))
		| &opt::RefExprModel:
			self.var((&opt::RefExprModel)(m).Var)
		| &opt::EmptyCompareExprModel:
			self.emptyCompare((&opt::EmptyCompareExprModel)(m))
		| &opt::UnsafeDerefExprModel:
			self.unsafeDeref((&opt::UnsafeDerefExprModel)(m))
		| &opt::UnsafeCastingExprModel:
			self.unsafeCasting((&opt::UnsafeCastingExprModel)(m))
		|:
			self.oc.write("<unimplemented_expression_model>")
		}
	}

	// Writes default initialization of struct field.
	fn handleFieldByDefault(mut &self, mut &f: &sema::FieldIns): (inited: bool) {
		// If field have default expression, initialize with it.
		// Otherwise, initialize it by default expression.
		if f.Default != nil {
			self.oc.write(".")
			identCoder.field(self.oc.Buf, f.Decl)
			self.oc.write("=")
			self.possibleRefExpr(f.Default.Model)
			ret true
		}
		if !ableToInit(f.Kind) {
			ret false
		}
		self.oc.write(".")
		identCoder.field(self.oc.Buf, f.Decl)
		self.oc.write("=")
		self.initExpr(f.Kind)
		ret true
	}

	// Writes default struct literal expression to initialize it by default.
	fn initStructLit(mut &self, mut &s: &sema::StructIns) {
		if s.Decl.Binded {
			self.oc.write("(")
			self.oc.tc.structureIns(self.oc.Buf, s)
			self.oc.write("){}")
			ret
		}
		self.oc.tc.structureIns(self.oc.Buf, s)
		self.oc.write("{")
		mut inited := false
		for (_, mut f) in s.Fields {
			if inited {
				self.oc.write(", ")
			}
			inited = self.handleFieldByDefault(f)
		}
		self.oc.write("}")
	}

	// Writes iteration to initialize collection elements by default.
	// Assumes collectionItIdent and collectionIdent + "_end" is already defined.
	// Assumes collection element kind able to init.
	fn fillCollectionByDefault(mut &self, mut &elem: &sema::Type) {
		self.oc.write("for (; ")
		self.oc.write(collectionItIdent)
		self.oc.write(" < ")
		self.oc.write(collectionIdent)
		self.oc.write("_end; ++")
		self.oc.write(collectionItIdent)
		self.oc.write(") *")
		self.oc.write(collectionItIdent)
		self.oc.write(" = ")
		self.initExpr(elem)
		self.oc.write(";")
	}

	// Assumes collection element kind able to init.
	fn initCollection(mut &self, mut &elem: &sema::Type) {
		self.oc.write("auto ")
		self.oc.write(collectionItIdent)
		self.oc.write(" = ")
		self.oc.write(collectionIdent)
		self.oc.write(".begin(); const auto ")
		self.oc.write(collectionIdent)
		self.oc.write("_end = ")
		self.oc.write(collectionIdent)
		self.oc.write(".end(); ")
		self.fillCollectionByDefault(elem)
	}

	// Writes default array literal expression to initialize it by default.
	fn initArray(mut &self, mut &arr: &sema::Arr) {
		// Plain initialization if array is zero-length.
		if arr.N == 0 {
			self.oc.tc.array(self.oc.Buf, arr)
			self.oc.write("()")
			ret
		}
		self.oc.write("({ auto " + collectionIdent + " = ")
		self.oc.tc.array(self.oc.Buf, arr)
		self.oc.write("(); ")
		self.initCollection(arr.Elem)
		self.oc.write(" " + collectionIdent + "; })")
	}

	fn initExpr(mut &self, mut t: &sema::Type) {
		if t.NilCompatible() {
			if t.Map() != nil {
				self.oc.tc.kind(self.oc.Buf, t)
				self.oc.write("{}")
				ret
			}
			if t.Ptr() != nil {
				self.oc.write("nullptr")
			} else {
				self.oc.tc.kind(self.oc.Buf, t)
				self.oc.write("(nullptr)")
			}
			ret
		}
		mut tup := t.Tup()
		if tup != nil {
			self.oc.tc.rc.tup(self.oc.Buf, tup)
			self.oc.write("{")
			for (i, mut tt) in tup.Types {
				if !shouldInitialized(tt) {
					continue
				}
				self.oc.write("." + resultArgName)
				self.oc.write(conv::Itoa(i))
				self.oc.write("=")
				self.initExpr(tt)
				if len(tup.Types)-i > 1 {
					self.oc.write(", ")
				}
			}
			self.oc.write("}")
			ret
		}
		mut enm := t.Enum()
		if enm != nil {
			self.model(enm.Items[0].Value.Data.Model)
			ret
		}
		prim := t.Prim()
		if prim != nil {
			if types::IsNum(prim.Kind) {
				self.oc.write("0")
			} else if prim.IsBool() {
				self.oc.write("false")
			} else if prim.IsStr() {
				self.oc.write(typeCoder.Str + "()")
			}
			ret
		}
		if t.Arr() != nil {
			mut arr := t.Arr()
			self.initArray(arr)
			ret
		}
		mut s := t.Struct()
		if s != nil {
			self.initStructLit(s)
			ret
		}
		self.oc.tc.kind(self.oc.Buf, t)
		self.oc.write("()")
	}
}

fn decomposeCommonEsq(b: byte): str {
	match b {
	| '\\':
		ret "\\\\"
	| '\'':
		ret "'"
	| '"':
		ret `\"`
	| '\a':
		ret `\a`
	| '\b':
		ret `\b`
	| '\f':
		ret `\f`
	| '\n':
		ret `\n`
	| '\r':
		ret `\r`
	| '\t':
		ret `\t`
	| '\v':
		ret `\v`
	|:
		ret ""
	}
}

fn sbtoa(b: byte): str {
	if b == 0 {
		ret "\\x00"
	}
	if b < utf8::RuneSelf { // ASCII, fast way.
		seq := decomposeCommonEsq(b)
		if seq != "" {
			ret seq
		}
		if 32 <= b && b <= 126 {
			ret str(b)
		}
	}
	seq := conv::FmtUint(u64(b), 8)
	if len(seq) == 2 {
		ret "\\0" + seq
	}
	ret "\\" + seq
}

fn cstrBytes(mut &s: strings::Builder, ctx: str) {
	for _, b in ctx {
		s.WriteStr(sbtoa(b))!
	}
}

fn cstrLit(mut &s: strings::Builder, ctx: str) {
	s.WriteByte('"')!
	cstrBytes(s, ctx)
	s.WriteByte('"')!
}

fn ftoa(mut &s: strings::Builder, f: f64, bitsize: int) {
	if bitsize != 32 {
		if f == f64(i64(f)) {
			itoa(s, i64(f))
			ret
		}
		if f == f64(u64(f)) {
			utoa(s, u64(f))
			ret
		}
	}
	m := conv::FmtFloat(f, 'f', -1, bitsize)
	s.WriteStr(m)!
	if !strings::Contains(m, ".") {
		s.WriteStr(".0")!
	}
}

fn itoa(mut &s: strings::Builder, x: i64) {
	match {
	| x == types::MaxI64:
		s.WriteStr("jule::MAX_I64")!
		ret
	| x == types::MinI64:
		s.WriteStr("jule::MIN_I64")!
		ret
	}

	s.WriteStr(conv::FmtInt(x, 10))!
	if build::Is64Bit(runtime::Arch) {
		s.WriteByte('L')!
	}
	s.WriteByte('L')!
}

fn utoa(mut &s: strings::Builder, x: u64) {
	match {
	| x == types::MaxU64:
		s.WriteStr("jule::MAX_U64")!
		ret
	}

	s.WriteStr(conv::FmtUint(x, 10))!
	if build::Is64Bit(runtime::Arch) {
		s.WriteByte('L')!
	}
	s.WriteStr("LU")!
}

fn operatorOverloadingBinary(mut &buf: strings::Builder, mut &s: &sema::StructIns, &l: str,
	&r: str, op: token::Id, kind: str) {
	const Unary = false
	mut f := (&sema::FnIns)(nil)
	if op == token::Id.NotEq {
		f = obj::FindOperator(s, token::Id.Eqs, Unary)
		buf.WriteByte('!')!
	} else {
		f = obj::FindOperator(s, op, Unary)
	}
	if f == nil {
		if op == token::Id.Eqs || op == token::Id.NotEq {
			// Equal method not exist. Compiler will create, use default method.
			identCoder.structureIns(buf, s)
			buf.WriteStr(structDefaultEqMethodSuffix)!
			goto common
		}
		panic("cxx: binary operator overloading is not exist, this is an implementation mistake")
	}
	identCoder.funcIns(buf, f)
common:
	buf.WriteStr("(&")!
	buf.WriteStr(l)!
	buf.WriteStr(", ")!
	buf.WriteStr(r)!
	buf.WriteByte(')')!
}