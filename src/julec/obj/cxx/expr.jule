// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use env
use optimizing::{
    UnsafeBinopExprModel,
    UnsafeIndexingExprModel,
    PushToSliceExprModel,
    MutSlicingExprModel,
    StrInsertBeginExprModel,
}
use conv for std::conv
use std::env::{ARCH}
use fmt for std::fmt
use std::jule::build::{Directive, is_64bit}
use std::jule::constant::{Const}
use std::jule::lex::{Token, TokenKind}
use std::jule::sema::{
    Var,
    Struct,
    FnIns,
    Trait,
    StructIns,
    TypeKind,
    Data,
    Value,
    ExprModel,
    BinopExprModel,
    UnaryExprModel,
    StructLitExprModel,
    AllocStructLitExprModel,
    CastingExprModel,
    FnCallExprModel,
    SliceExprModel,
    IndexingExprModel,
    AnonFnExprModel,
    MapExprModel,
    SlicingExprModel,
    TraitSubIdentExprModel,
    StructSubIdentExprModel,
    ArrayExprModel,
    CommonIdentExprModel,
    CommonSubIdentExprModel,
    TupleExprModel,
    BuiltinOutCallExprModel,
    BuiltinOutlnCallExprModel,
    BuiltinCloneCallExprModel,
    BuiltinNewCallExprModel,
    BuiltinPanicCallExprModel,
    BuiltinAssertCallExprModel,
    BuiltinMakeCallExprModel,
    BuiltinAppendCallExprModel,
    BuiltinErrorCallExprModel,
    BuiltinCopyCallExprModel,
    SizeofExprModel,
    AlignofExprModel,
    RuneExprModel,
    StructStaticIdentExprModel,
    IntegratedToStrExprModel,
    BackendEmitExprModel,
    FreeExprModel,
    OperandExprModel,
    Scope,
}
use types for std::jule::types::{
    MAX_F32,
    MAX_F64,
    MIN_F32,
    MIN_F64,
    MAX_I64,
    MIN_I64,
    MAX_U64,
}
use math for std::math
use strings for std::strings
use utf8 for std::unicode::utf8

// Ignore expression for std::tie function.
const CPP_IGNORE = "std::ignore"

// Represents default expression for type.
const CPP_DEFAULT_EXPR = "{}"

struct ExprCoder {
    oc: &ObjectCoder
}

impl ExprCoder {
    static fn new(mut &oc: &ObjectCoder): &ExprCoder {
        ret &ExprCoder{
            oc: oc,
        }
    }

    fn string(mut &self, &c: &Const) {
        let content = c.read_str()
        if content.len == 0 { // Empty.
            self.oc.write(TypeCoder.Str + "()")
            ret
        }
        let bytes = []byte(content)
        let len = conv::fmt_int(i64(bytes.len), 10)
        let lit = cstr_lit(bytes)
        self.oc.write(TypeCoder.Str)
        self.oc.write("(")
        self.oc.write(lit)
        self.oc.write(", ")
        self.oc.write(len)
        self.oc.write(")")
    }

    fn boolean(mut &self, &c: &Const) {
        if c.read_bool() {
            self.oc.write("true")
            ret
        }
        self.oc.write("false")
    }

    fn nil_lit(mut &self) {
        self.oc.write("nullptr")
    }

    fn ftoa_special_cases(mut &self, &x: f64): bool {
        match {
        | math::is_nan(x):
            self.oc.write("NAN")
        | math::is_inf(x, 1):
            self.oc.write("INFINITY")
        | math::is_inf(x, -1):
            self.oc.write("-INFINITY")
        |:
            ret false
        }
        ret true
    }

    fn float32(mut &self, &c: &Const) {
        let x = c.as_f64()

        // Special cases.
        if self.ftoa_special_cases(x) {
            ret
        }

        match {
        | x == MAX_F32:
            self.oc.write("jule::MAX_F32")
        | x == MIN_F32:
            self.oc.write("jule::MIN_F32")
        |:
            self.oc.write(ftoa(x, 1 << 5))
            self.oc.write("f")
        }
    }

    fn float64(mut &self, &c: &Const) {
        let x = c.as_f64()

        // Special cases.
        if self.ftoa_special_cases(x) {
            ret
        }

        match {
        | x == MAX_F64:
            self.oc.write("jule::MAX_F64")
        | x == MIN_F64:
            self.oc.write("jule::MIN_F64")
        |:
            self.oc.write(ftoa(x, 1 << 6))
        }
    }

    // fx32: 32-bit floating-point
    fn constant(mut &self, mut c: &Const, fx32: bool) {
        match {
        | c.is_str():
            self.string(c)
        | c.is_bool():
            self.boolean(c)
        | c.is_f64():
            match {
            | fx32:
                self.float32(c)
            |:
                self.float64(c)
            }
        | c.is_i64():
            self.oc.write(itoa(c.read_i64()))
        | c.is_u64():
            self.oc.write(utoa(c.read_u64()))
        | c.is_nil():
            self.nil_lit()
        |:
            self.oc.write("<unimplemented_constant_expression>")
        }
    }

    fn div_by_zero_binary(mut &self, &op: &Token, mut &l: &OperandExprModel, mut &r: &OperandExprModel) {
        self.oc.write("jule::")
        match op.kind {
        | TokenKind.Solidus
        | TokenKind.SolidusEq:
            self.oc.write("div(")
        | TokenKind.Percent
        | TokenKind.PercentEq:
            self.oc.write("mod(")
        }

        if !env::PRODUCTION {
            self.oc.write("\"")
            self.oc.loc_info(op)
            self.oc.write("\",")
        }
        self.expr(l.model)
        self.oc.write(",")
        self.expr(r.model)
        self.oc.write(")")
    }

    fn unsafe_binary(mut &self, mut m: &BinopExprModel) {
        self.oc.write("(")
        self.model(m.left.model)
        self.oc.write(" ")
        self.oc.write(m.op.kind)
        self.oc.write(" ")
        self.model(m.right.model)
        self.oc.write(")")
    }

    fn binary(mut &self, mut m: &BinopExprModel) {
        match m.op.kind {
        | TokenKind.Solidus | TokenKind.Percent:
            // Do not check division of structures safety.
            if m.left.kind.strct() == nil {
                self.div_by_zero_binary(m.op, m.left, m.right)
                ret
            }
        }
        self.unsafe_binary(m)
    }

    fn var(mut &self, mut m: &Var) {
        if m.cpp_linked {
            let d = find_directive(m.directives, Directive.Namespace)
            if d != nil {
                self.oc.write(concat_all_parts(d.args...))
                self.oc.write("::")
            }
        }
        self.oc.write(IdentCoder.var(m))
    }

    fn structure(mut &self, m: &Struct) {
        self.oc.write(TypeCoder.structure(m))
    }

    fn structure_ins(mut &self, mut m: &StructIns) {
        self.oc.write(TypeCoder.structure_ins(m))
    }

    fn unary(mut &self, mut m: &UnaryExprModel) {
        match m.op.kind {
        | TokenKind.Caret:
            self.oc.write("(~(")
            self.expr(m.expr.model)
            self.oc.write("))")
            ret
        | TokenKind.Star:
            if env::PRODUCTION || m.expr.kind.sptr() == nil {
                break
            }
            self.expr(m.expr.model)
            self.oc.write(".get(\"")
            self.oc.loc_info(m.op)
            self.oc.write("\")")
            ret
        }
        self.oc.write("(")
        self.oc.write(m.op.kind)
        self.oc.write("(")
        self.expr(m.expr.model)
        self.oc.write("))")
    }

    fn structure_lit(mut &self, mut m: &StructLitExprModel) {
        if m.strct.decl.cpp_linked {
            self.oc.write("(")
        }
        self.oc.write(IdentCoder.structure_ins(m.strct))
        if m.strct.decl.cpp_linked {
            self.oc.write(")")
        }
        self.oc.write("{")
        if m.args.len > 1 {
        iter:
            for i, f in m.strct.decl.fields {
                for (_, mut arg) in m.args {
                    if arg.field.decl == f {
                        self.oc.write(".")
                        self.oc.write(IdentCoder.field(arg.field.decl))
                        self.oc.write("=")
                        self.expr(arg.expr)
                        if m.strct.decl.fields.len-i > 1 {
                            self.oc.write(", ")
                        }
                        continue iter
                    }
                }
            }
        }
        self.oc.write("}")
    }

    fn alloc_structure(mut &self, mut m: &AllocStructLitExprModel) {
        self.oc.write("jule::new_ptr<")
        self.oc.write(IdentCoder.structure_ins(m.lit.strct))
        self.oc.write(">(")
        self.structure_lit(m.lit)
        self.oc.write(")")
    }

    fn casting(mut &self, mut m: &CastingExprModel) {
        match {
        | m.kind.prim() != nil && m.kind.prim().is_any():
            self.oc.write(TypeCoder.kind(m.kind))
            self.oc.write("(")
            self.model(m.expr)
            self.oc.write(")")
        | m.expr_kind.ptr() != nil
        | m.kind.ptr() != nil:
            self.oc.write("((")
            self.oc.write(TypeCoder.kind(m.kind))
            self.oc.write(")(")
            self.expr(m.expr)
            self.oc.write("))")
        | m.expr_kind.trt() != nil
        | m.expr_kind.prim() != nil && m.expr_kind.prim().is_any():
            self.model(m.expr)
            self.oc.write(".")
            if env::PRODUCTION {
                self.oc.write("operator ")
                self.oc.write(TypeCoder.kind(m.kind))
                self.oc.write("()")
            } else {
                if m.expr_kind.trt() != nil && m.kind.sptr() != nil {
                    self.oc.write("cast_ptr<")
                    self.oc.write(TypeCoder.kind(m.kind.sptr().elem))
                } else {
                    self.oc.write("cast<")
                    self.oc.write(TypeCoder.kind(m.kind))
                }
                self.oc.write(">(\"")
                self.oc.loc_info(m.token)
                self.oc.write("\")")
            }
        | m.kind.trt() != nil:
            self.oc.write(TypeCoder.kind(m.kind))
            self.oc.write("(")
            self.expr(m.expr)
            self.oc.write(", ")
            self.oc.write(conv::itoa(self.oc.find_type_offset(m.kind.trt(), m.expr_kind)))
            self.oc.write(")")
        |:
            self.oc.write("static_cast<")
            self.oc.write(TypeCoder.kind(m.kind))
            self.oc.write(">(")
            self.expr(m.expr)
            self.oc.write(")")
        }
    }

    fn args(mut &self, mut args: []ExprModel) {
        if args.len == 0 {
            ret
        }
        for (i, mut a) in args {
            self.expr(a)
            if args.len-i > 1 {
                self.oc.write(",")
            }
        }
    }

    fn model_for_call(mut &self, mut expr: ExprModel) {
        match type expr {
        | &FnIns:
            self.func_ins((&FnIns)(expr))
            ret
        | &StructSubIdentExprModel:
            let mut ssie = (&StructSubIdentExprModel)(expr)
            if ssie.method != nil {
                self.func_ins(ssie.method)
                ret
            }
        }
        self.model(expr)
    }

    fn push_call_inf(mut &self, &m: &FnCallExprModel) {
        if env::PRODUCTION || (!m.func.anon && !is_builtin_call_has_debuginf(m)) {
            self.oc.write("(")
            ret
        }
        if m.func.anon {
            match type m.expr {
            | &StructSubIdentExprModel:
                if (&StructSubIdentExprModel)(m.expr).field.decl.owner.cpp_linked {
                    self.oc.write("(")
                    ret
                }
                fall
            |:
                self.oc.write(".call")
            }
        }
        self.oc.write("(\"")
        self.oc.loc_info(m.token)
        self.oc.write("\"")
        if m.args.len != 0 {
            self.oc.write(",")
        }
    }

    fn is_wrapped(mut &self, mut &m: &FnCallExprModel): bool {
        if !m.func.is_builtin() && m.func.decl.params.len > 0 && m.func.decl.params[0].is_self() {
            match type m.expr {
            | &StructSubIdentExprModel:
                let mut ssie = (&StructSubIdentExprModel)(m.expr)
                match {
                | m.func.decl.params[0].is_ref()
                | ssie.expr_kind.sptr() != nil:
                    break
                |:
                    if ssie.expr.kind.strct() != nil {
                        if !ssie.expr.lvalue {
                            self.oc.write("({ auto _wrap_copy = ")
                            self.model(ssie.expr)
                            self.oc.write("; ")
                            ret true
                        }
                    }
                }
            }
        }
        ret false
    }

    fn pure_func_call(mut &self, mut &m: &FnCallExprModel) {
        let wrapped = self.is_wrapped(m)
        if m.is_co {
            self.oc.write("__JULE_CO(")
        }
        self.model_for_call(m.expr)
        if !m.func.is_builtin() {
            if m.func.decl.cpp_linked && m.func.generics.len > 0 {
                if !has_directive(m.func.decl.directives, Directive.Cdef) {
                    self.oc.write("<")
                    for (i, mut g) in m.func.generics {
                        self.oc.write(TypeCoder.kind(g))
                        if m.func.generics.len-i > 1 {
                            self.oc.write(",")
                        }
                    }
                    self.oc.write(">")
                }
            }
        }
        self.push_call_inf(m)
        let mut locinfo = false
        if !m.func.is_builtin() && m.func.decl.params.len > 0 && m.func.decl.params[0].is_self() {
            match type m.expr {
            | &StructSubIdentExprModel:
                let mut ssie = (&StructSubIdentExprModel)(m.expr)
                match {
                | m.func.decl.params[0].is_ref():
                    self.model(ssie.expr)
                | ssie.expr_kind.sptr() != nil:
                    self.model(ssie.expr)
                    self.oc.write(".ptr(")
                    if !env::PRODUCTION {
                        self.oc.write("\"")
                        self.oc.loc_info(m.token)
                        self.oc.write("\"")
                    }
                    self.oc.write(")")
                |:
                    if ssie.expr.kind.strct() != nil {
                        // Add address taking operation for non-pointers.
                        self.oc.write("&")
                    }
                    if wrapped {
                        self.oc.write("_wrap_copy")
                    } else {
                        self.model(ssie.expr)
                    }
                }
                if m.args.len > 0 {
                    self.oc.write(", ")
                }
            | &TraitSubIdentExprModel:
                self.model((&TraitSubIdentExprModel)(m.expr).expr)
                if !env::PRODUCTION {
                    locinfo = true
                }
                if m.args.len > 0 {
                    self.oc.write(", ")
                }
            }
        }
        self.args(m.args)
        if locinfo {
            self.oc.write(", \"")
            self.oc.loc_info(m.token)
            self.oc.write("\"")
        }
        self.oc.write(")")

        if wrapped {
            self.oc.write("; })")
        }

        if m.is_co {
            self.oc.write(")")
        }
    }

    fn func_call(mut &self, mut m: &FnCallExprModel) {
        if m.func.is_builtin() ||
            !m.func.decl.exceptional ||
            m.except != nil && m.except.stmts.len == 0 {
            self.pure_func_call(m)
            ret
        }

        // Generate code for exceptional.
        self.oc.write("({\n")
        self.oc.add_indent()
        self.oc.indent()
        self.oc.write("auto except = ")
        self.pure_func_call(m)
        self.oc.write(";\n")
        self.oc.indent()
        if m.except != nil {
            if m.func.result == nil || !m.assigned {
                self.oc.write("if (!except.ok()) ")
                self.oc.sc.scope(m.except)
                self.oc.write("\n")
            } else {
                let forwarded = is_forwarded(m.except)
                self.oc.write("(except.ok()) ? (except.result) : (")
                if forwarded {
                    self.oc.write("{")
                }
                self.oc.sc.scope(m.except)
                if forwarded {
                    self.oc.write(" ")
                    self.init_expr(m.func.result)
                    self.oc.write(";}")
                }
                self.oc.write(");\n")
            }
            self.oc.done_indent()
        } else {
            self.oc.write(`if (!except.ok()) jule::panic(jule::Str("unhandled exceptional: ") + except.error.type->to_str(except.error.data) + jule::Str("\nlocation: `)
            self.oc.loc_info(m.token)
            self.oc.write("\"));\n")
            if !m.func.decl.is_void() {
                self.oc.indent()
                self.oc.write("(except.result);\n")
            }
            self.oc.done_indent()
        }

        self.oc.indent()
        self.oc.write("})")
    }

    fn slice(mut &self, mut m: &SliceExprModel) {
        if m.elems.len == 0 {
            self.oc.write(TypeCoder.as_slice(m.elem_kind))
            self.oc.write("()")
            ret
        }
        self.oc.write(TypeCoder.as_slice(m.elem_kind))
        self.oc.write("::make({")
        self.args(m.elems)
        self.oc.write("})")
    }

    fn indexing(mut &self, mut m: &IndexingExprModel) {
        self.model(m.expr.model)
        // Index access with safety measures.
        match {
        | env::PRODUCTION
        | m.expr.kind.ptr() != nil
        | m.expr.kind.map() != nil:
            self.oc.write("[")
            self.expr(m.index.model)
            self.oc.write("]")
        |:
            self.oc.write(".at(\"")
            self.oc.loc_info(m.token)
            self.oc.write("\",")
            self.expr(m.index.model)
            self.oc.write(")")
        }
    }

    fn unsafe_indexing(mut &self, mut m: &UnsafeIndexingExprModel) {
        self.model(m.node.expr.model)
        // Index access with safety measures.
        match {
        | env::PRODUCTION
        | m.node.expr.kind.ptr() != nil
        | m.node.expr.kind.map() != nil:
            self.oc.write("[")
            self.expr(m.node.index.model)
            self.oc.write("]")
        |:
            self.oc.write("__at(")
            self.expr(m.node.index.model)
            self.oc.write(")")
        }
    }

    fn anon_func(mut &self, mut m: &AnonFnExprModel) {
        self.oc.write(TypeCoder.func(m.func))
        self.oc.write("([=]")
        self.oc.params_ins(m.func.params)
        self.oc.write(" mutable -> ")
        self.oc.write(TypeCoder.func_ins_result(m.func))
        self.oc.write(" ")
        self.oc.sc.func_scope(m.func)
        self.oc.write(")")
    }

    fn map(mut &self, mut m: &MapExprModel) {
        self.oc.write(TypeCoder.Map + "<")
        self.oc.write(TypeCoder.kind(m.key_kind))
        self.oc.write(",")
        self.oc.write(TypeCoder.kind(m.val_kind))
        self.oc.write(">({")
        if m.entries.len > 0 {
            for (i, mut pair) in m.entries {
                self.oc.write("{")
                self.expr(pair.key)
                self.oc.write(",")
                self.expr(pair.val)
                self.oc.write("}")
                if m.entries.len-i > 1 {
                    self.oc.write(",")
                }
            }
        }
        self.oc.write("})")
    }

    fn slicing(mut &self, mut m: &SlicingExprModel) {
        self.model(m.expr)
        self.oc.write(".slice(")
        if !env::PRODUCTION {
            self.oc.write("\"")
            self.oc.loc_info(m.token)
            self.oc.write("\",")
        }
        self.expr(m.left)
        if m.right != nil {
            self.oc.write(",")
            self.expr(m.right)
        }
        self.oc.write(")")
    }

    fn trait_sub(mut &self, mut m: &TraitSubIdentExprModel) {
        self.oc.write(IdentCoder.trait_decl(m.trt))
        self.oc.write("_mptr_data")
        self.oc.write("[(")
        self.model(m.expr)
        self.oc.write(").type_offset].")
        self.oc.write(IdentCoder.func(m.method))
    }

    fn structure_sub(mut &self, mut m: &StructSubIdentExprModel) {
        self.model(m.expr)
        if m.field != nil {
            if m.expr_kind.ptr() != nil {
                self.oc.write("->")
            } else if m.expr_kind.sptr() != nil {
                self.oc.write(".get(")
                if !env::PRODUCTION {
                    self.oc.write("\"")
                    self.oc.loc_info(m.token)
                    self.oc.write("\"")
                }
                self.oc.write(").")
            } else {
                self.oc.write(".")
            }
            self.oc.write(IdentCoder.field(m.field.decl))
        }
    }

    fn common_ident(mut &self, m: &CommonIdentExprModel) {
        self.oc.write(m.ident)
    }

    fn common_sub(mut &self, mut m: &CommonSubIdentExprModel) {
        self.model(m.expr)
        match {
        | m.expr_kind.ptr() != nil:
            self.oc.write("->")
        | m.expr_kind.sptr() != nil:
            self.oc.write(".get(")
            if !env::PRODUCTION {
                self.oc.write("\"")
                self.oc.loc_info(m.token)
                self.oc.write("\"")
            }
            self.oc.write(").")
        |:
            self.oc.write(".")
        }
        self.oc.write(m.ident)
    }

    fn array(mut &self, mut m: &ArrayExprModel) {
        self.oc.write(TypeCoder.array(m.kind))
        if m.elems.len == 0 {
            self.oc.write("()")
            ret
        }

        // Filled.
        if m.elems.len == 2 && m.elems[1] == nil {
            self.oc.write("(")
            self.expr(m.elems[0])
            self.oc.write(")")
            ret
        }

        self.oc.write("({")
        self.args(m.elems)
        self.oc.write("})")
        ret
    }

    // Writes complete expression model of function instance.
    // Usefull for strict type safety.
    fn func_ins_common(mut &self, mut m: &FnIns) {
        self.oc.write(TypeCoder.func(m))
        self.oc.write("(")
        self.func_ins(m)
        self.oc.write(")")
    }

    fn func_ins(mut &self, mut m: &FnIns) {
        if m.decl != nil && m.decl.cpp_linked {
            let d = find_directive(m.decl.directives, Directive.Namespace)
            if d != nil {
                self.oc.write(concat_all_parts(d.args...))
                self.oc.write("::")
            }
        }
        self.oc.write(IdentCoder.func_ins(m))
    }

    fn tuple(mut &self, mut m: &TupleExprModel) {
        self.oc.write("std::make_tuple(")
        for (i, mut d) in m.datas {
            self.expr(d.model)
            if m.datas.len-i > 1 {
                self.oc.write(",")
            }
        }
        self.oc.write(")")
    }

    fn new_call(mut &self, mut m: &BuiltinNewCallExprModel) {
        self.oc.write("jule::new_ptr<")
        self.oc.write(TypeCoder.kind(m.kind))
        self.oc.write(">(")
        if m.init != nil {
            self.expr(m.init)
        }
        self.oc.write(")")
    }

    fn out_call(mut &self, mut m: &BuiltinOutCallExprModel) {
        if m.debug && env::PRODUCTION {
            ret
        }
        self.oc.write("jule::out(")
        self.expr(m.expr)
        self.oc.write(")")
    }

    fn outln_call(mut &self, mut m: &BuiltinOutlnCallExprModel) {
        if m.debug && env::PRODUCTION {
            ret
        }
        self.oc.write("jule::outln(")
        self.expr(m.expr)
        self.oc.write(")")
    }

    fn panic_call(mut &self, mut m: &BuiltinPanicCallExprModel) {
        self.oc.write("jule::panic(")
        self.expr(m.expr)
        self.oc.write(` + jule::Str("\nlocation: `)
        self.oc.loc_info(m.token)
        self.oc.write("\"));")
    }

    fn assert_call(mut &self, mut m: &BuiltinAssertCallExprModel) {
        if env::PRODUCTION {
            ret
        }
        self.oc.write("if (!(")
        self.expr(m.expr)
        self.oc.write(")) jule::panic(jule::Str(")
        self.oc.write(cstr_lit([]byte(m.log)))
        self.oc.write(`) + jule::Str("\nlocation: `)
        self.oc.loc_info(m.token)
        self.oc.write("\"));")
    }

    fn error_call(mut &self, mut m: &BuiltinErrorCallExprModel) {
        self.oc.write("return ")
        if m.func.decl.is_void() {
            self.oc.write("jule::VoidExceptional(")
        } else {
            self.oc.write("jule::Exceptional<")
            self.oc.write(TypeCoder.kind(m.func.result))
            self.oc.write(">(")
        }
        self.expr(m.err)
        self.oc.write(")")
    }

    fn copy_call(mut &self, mut m: &BuiltinCopyCallExprModel) {
        self.oc.write("jule::copy((")
        self.model(m.dest.model)
        self.oc.write(")")
        if m.dest.kind.prim() != nil { // String destination.
            self.oc.write(".fake_slice()")
        }
        self.oc.write(", (")
        self.model(m.src.model)
        self.oc.write(")")
        if m.src.kind.prim() != nil { // String source.
            self.oc.write(".fake_slice()")
        }
        self.oc.write(")")
    }

    fn make_call(mut &self, mut m: &BuiltinMakeCallExprModel) {
        self.oc.write(TypeCoder.kind(m.kind))
        if m.kind.slc().elem.enm() != nil {
            if m.cap != nil {
                self.oc.write("::alloc(")
            } else {
                self.oc.write("::alloc_def(")
            }
        } else {
            self.oc.write("::alloc(")
        }

        if m.len != nil {
            self.expr(m.len)
        } else {
            self.oc.write("0")
        }
        if m.cap != nil {
            self.oc.write(",")
            self.expr(m.cap)
        }

        if m.kind.slc().elem.enm() != nil {
            self.oc.write(",")
            self.init_expr(m.kind.slc().elem)
        }
        self.oc.write(")")
    }

    fn push_to_slice(mut &self, mut m: &PushToSliceExprModel) {
        let n = self.oc.obj.len
        self.model(m.dest)
        let dest = self.oc.obj[n:]

        self.oc.write(" = jule::alloc_for_append(")
        self.oc.write(dest)
        self.oc.write(",")
        self.oc.write(conv::itoa(m.elems.elems.len))
        self.oc.write(");")
        for (_, mut e) in m.elems.elems {
            self.oc.write(dest)
            // Use the "__push" method to skip allocation boundary checking.
            self.oc.write(".__push(")
            self.model(e)
            self.oc.write(");")
        }
    }

    fn append_call(mut &self, mut m: &BuiltinAppendCallExprModel) {
        self.oc.write("jule::append(")
        self.model(m.dest)
        self.oc.write(",")
        self.model(m.elements)
        self.oc.write(")")
    }

    fn clone_call(mut &self, mut m: &BuiltinCloneCallExprModel) {
        self.oc.write("jule::clone(")
        self.model(m.expr)
        self.oc.write(")")
    }

    fn sizeof(mut &self, mut m: &SizeofExprModel) {
        self.oc.write("sizeof(")
        self.model(m.expr)
        self.oc.write(")")
    }

    fn alignof(mut &self, mut m: &AlignofExprModel) {
        self.oc.write("alignof(")
        self.model(m.expr)
        self.oc.write(")")
    }

    fn rune_lit(mut &self, m: &RuneExprModel): str {
        if m.code <= 127 { // ASCII
            let mut b = sbtoa(byte(m.code))
            if b == "'" {
                b = "\\'"
            }
            ret "'" + b + "'"
        }
        ret itoa(i64(m.code))
    }

    fn structure_static(mut &self, mut m: &StructStaticIdentExprModel) {
        self.oc.write(IdentCoder.func_ins(m.method))
    }

    fn integrated_to_str(mut &self, mut m: &IntegratedToStrExprModel) {
        self.oc.write("jule::to_str(")
        self.model(m.expr)
        self.oc.write(")")
    }

    fn backend_emit(mut &self, mut m: &BackendEmitExprModel) {
        if m.exprs.len == 0 {
            self.oc.write(m.code)
            ret
        }
        let n = self.oc.obj.len
        for (i, mut expr) in m.exprs {
            self.expr(expr)
            let obj = self.oc.obj[n:]
            m.exprs[i] = obj
            self.oc.obj = self.oc.obj[:n]
        }
        self.oc.write(fmt::format(m.code, m.exprs...))
    }

    fn free(mut &self, mut m: &FreeExprModel) {
        self.expr(m.expr)
        if env::RC {
            self.oc.write(".dealloc()")
            ret
        }
        self.oc.write(".__free()")
    }

    fn mut_slicing(mut &self, mut m: &MutSlicingExprModel) {
        self.oc.write("(")
        self.model(m.expr)
        self.oc.write(").mut_slice(")
        if !env::PRODUCTION {
            self.oc.write("\"")
            self.oc.loc_info(m.token)
            self.oc.write("\",")
        }
        self.expr(m.left)
        if m.right != nil {
            self.oc.write(",")
            self.expr(m.right)
        }
        self.oc.write(");")
    }

    fn str_insert_begin(mut &self, mut m: &StrInsertBeginExprModel) {
        self.oc.write("(")
        self.model(m.dest)
        self.oc.write(").buffer.insert(0, (")
        self.model(m.expr)
        self.oc.write("));")
    }

    fn model(mut &self, mut m: ExprModel) {
        match type m {
        | &Data:
            self.model((&Data)(m).model)
        | &TypeKind:
            self.oc.write(TypeCoder.kind((&TypeKind)(m)))
        | &Const:
            self.constant((&Const)(m), false)
        | &Var:
            self.var((&Var)(m))
        | &Trait:
            IdentCoder.trait_decl((&Trait)(m))
        | &Struct:
            self.structure((&Struct)(m))
        | &StructIns:
            self.structure_ins((&StructIns)(m))
        | &FnIns:
            self.func_ins_common((&FnIns)(m))
        | &UnsafeBinopExprModel:
            self.unsafe_binary((&UnsafeBinopExprModel)(m).node)
        | &BinopExprModel:
            self.binary((&BinopExprModel)(m))
        | &UnaryExprModel:
            self.unary((&UnaryExprModel)(m))
        | &StructLitExprModel:
            self.structure_lit((&StructLitExprModel)(m))
        | &AllocStructLitExprModel:
            self.alloc_structure((&AllocStructLitExprModel)(m))
        | &CastingExprModel:
            self.casting((&CastingExprModel)(m))
        | &FnCallExprModel:
            self.func_call((&FnCallExprModel)(m))
        | &SliceExprModel:
            self.slice((&SliceExprModel)(m))
        | &ArrayExprModel:
            self.array((&ArrayExprModel)(m))
        | &UnsafeIndexingExprModel:
            self.unsafe_indexing((&UnsafeIndexingExprModel)(m))
        | &IndexingExprModel:
            self.indexing((&IndexingExprModel)(m))
        | &AnonFnExprModel:
            self.anon_func((&AnonFnExprModel)(m))
        | &MapExprModel:
            self.map((&MapExprModel)(m))
        | &SlicingExprModel:
            self.slicing((&SlicingExprModel)(m))
        | &TraitSubIdentExprModel:
            self.trait_sub((&TraitSubIdentExprModel)(m))
        | &StructSubIdentExprModel:
            self.structure_sub((&StructSubIdentExprModel)(m))
        | &CommonIdentExprModel:
            self.common_ident((&CommonIdentExprModel)(m))
        | &CommonSubIdentExprModel:
            self.common_sub((&CommonSubIdentExprModel)(m))
        | &TupleExprModel:
            self.tuple((&TupleExprModel)(m))
        | &BuiltinOutCallExprModel:
            self.out_call((&BuiltinOutCallExprModel)(m))
        | &BuiltinOutlnCallExprModel:
            self.outln_call((&BuiltinOutlnCallExprModel)(m))
        | &BuiltinNewCallExprModel:
            self.new_call((&BuiltinNewCallExprModel)(m))
        | &BuiltinPanicCallExprModel:
            self.panic_call((&BuiltinPanicCallExprModel)(m))
        | &BuiltinAssertCallExprModel:
            self.assert_call((&BuiltinAssertCallExprModel)(m))
        | &BuiltinErrorCallExprModel:
            self.error_call((&BuiltinErrorCallExprModel)(m))
        | &BuiltinMakeCallExprModel:
            self.make_call((&BuiltinMakeCallExprModel)(m))
        | &BuiltinAppendCallExprModel:
            self.append_call((&BuiltinAppendCallExprModel)(m))
        | &BuiltinCloneCallExprModel:
            self.clone_call((&BuiltinCloneCallExprModel)(m))
        | &BuiltinCopyCallExprModel:
            self.copy_call((&BuiltinCopyCallExprModel)(m))
        | &SizeofExprModel:
            self.sizeof((&SizeofExprModel)(m))
        | &AlignofExprModel:
            self.alignof((&AlignofExprModel)(m))
        | &RuneExprModel:
            self.oc.write(self.rune_lit((&RuneExprModel)(m)))
        | &StructStaticIdentExprModel:
            self.structure_static((&StructStaticIdentExprModel)(m))
        | &IntegratedToStrExprModel:
            self.integrated_to_str((&IntegratedToStrExprModel)(m))
        | &BackendEmitExprModel:
            self.backend_emit((&BackendEmitExprModel)(m))
        | &FreeExprModel:
            self.free((&FreeExprModel)(m))
        | &MutSlicingExprModel:
            self.mut_slicing((&MutSlicingExprModel)(m))
        | &StrInsertBeginExprModel:
            self.str_insert_begin((&StrInsertBeginExprModel)(m))
        |:
            self.oc.write("<unimplemented_expression_model>")
        }
    }

    fn expr(mut &self, mut e: ExprModel) {
        self.model(e)
    }

    fn val(mut &self, mut v: &Value) {
        if v.data.is_const() {
            self.constant(v.data.constant, v.data.kind != nil && v.data.kind.prim().is_f32())
            ret
        }
        self.expr(v.data.model)
    }

    fn init_expr(mut &self, mut t: &TypeKind) {
        if t.ptr() != nil {
            self.oc.write("nullptr")
            ret
        }
        let mut enm = t.enm()
        if enm != nil {
            self.val(enm.items[0].value)
            ret
        }
        self.oc.write(TypeCoder.kind(t))
        self.oc.write("()")
    }
}

fn decompose_common_esq(b: byte): str {
    match b {
    | '\\':
        ret "\\\\"
    | '\'':
        ret "'"
    | '"':
        ret `\"`
    | '\a':
        ret `\a`
    | '\b':
        ret `\b`
    | '\f':
        ret `\f`
    | '\n':
        ret `\n`
    | '\r':
        ret `\r`
    | '\t':
        ret `\t`
    | '\v':
        ret `\v`
    |:
        ret ""
    }
}

fn sbtoa(b: byte): str {
    if b == 0 {
        ret "\\x00"
    }
    if b < utf8::RUNE_SELF { // ASCII, fast way.
        let seq = decompose_common_esq(b)
        if seq != "" {
            ret seq
        }
        if 32 <= b && b <= 126 {
            ret str(b)
        }
    }
    let seq = conv::fmt_uint(u64(b), 8)
    if seq.len == 2 {
        ret "\\0" + seq
    }
    ret "\\" + seq
}

fn cstr_bytes(bytes: []byte): str {
    let mut lit = ""
    for _, b in bytes {
        lit += sbtoa(b)
    }
    ret lit
}

fn cstr_lit(bytes: []byte): str {
    ret `"` + cstr_bytes(bytes) + `"`
}

fn ftoa(f: f64, bitsize: int): str {
    if bitsize != 32 {
        if f == f64(i64(f)) {
            ret itoa(i64(f))
        }
        if f == f64(u64(f)) {
            ret utoa(u64(f))
        }
    }
    let mut m = conv::fmt_float(f, 'f', -1, bitsize)
    if !strings::contains(m, ".") {
        m += ".0"
    }
    ret m
}

fn itoa(x: i64): str {
    match {
    | x == MAX_I64:
        ret "jule::MAX_I64"
    | x == MIN_I64:
        ret "jule::MIN_I64"
    }

    let fmt = conv::fmt_int(x, 10)
    if is_64bit(ARCH) {
        ret fmt + "LL"
    }
    ret fmt + "L"
}

fn utoa(x: u64): str {
    match {
    | x == MAX_U64:
        ret "jule::MAX_U64"
    }

    let fmt = conv::fmt_uint(x, 10)
    if is_64bit(ARCH) {
        ret fmt + "LLU"
    }
    ret fmt + "LU"
}

fn is_forwarded(&s: &Scope): bool {
    let last = s.stmts[s.stmts.len-1]
    match type last {
    | &Data:
        match type (&Data)(last).model {
        | &BuiltinErrorCallExprModel:
            ret true
        |:
            ret false
        }
    |:
        ret true
    }
}

fn is_builtin_call_has_debuginf(&m: &FnCallExprModel): bool {
    if !m.func.is_builtin() {
        ret false
    }
    match type m.expr {
    | &CommonSubIdentExprModel:
        let csie = (&CommonSubIdentExprModel)(m.expr)
        ret csie.ident == "swap"
    |:
        ret false
    }
}