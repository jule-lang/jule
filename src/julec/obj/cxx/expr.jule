// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use env
use opt::{
    UnsafeBinopExprModel,
    UnsafeIndexingExprModel,
    PushToSliceExprModel,
    MutSlicingExprModel,
    StrInsertBeginExprModel,
}
use conv for std::conv
use std::env::{Arch}
use fmt for std::fmt
use std::jule::build::{Directive, Is64Bit}
use std::jule::constant::{Const}
use std::jule::lex::{Token, TokenKind}
use std::jule::sema::{
    Var,
    FnIns,
    StructIns,
    TypeKind,
    Data,
    Value,
    ExprModel,
    BinopExprModel,
    UnaryExprModel,
    StructLitExprModel,
    AllocStructLitExprModel,
    CastingExprModel,
    FnCallExprModel,
    SliceExprModel,
    IndexingExprModel,
    AnonFnExprModel,
    MapExprModel,
    SlicingExprModel,
    TraitSubIdentExprModel,
    StructSubIdentExprModel,
    ArrayExprModel,
    CommonIdentExprModel,
    CommonSubIdentExprModel,
    TupleExprModel,
    BuiltinOutCallExprModel,
    BuiltinOutlnCallExprModel,
    BuiltinCloneCallExprModel,
    BuiltinNewCallExprModel,
    BuiltinPanicCallExprModel,
    BuiltinAssertCallExprModel,
    BuiltinMakeCallExprModel,
    BuiltinAppendCallExprModel,
    BuiltinErrorCallExprModel,
    BuiltinCopyCallExprModel,
    BuiltinLenCallExprModel,
    BuiltinCapCallExprModel,
    BuiltinDeleteCallExprModel,
    SizeofExprModel,
    AlignofExprModel,
    RuneExprModel,
    StructStaticIdentExprModel,
    IntegratedToStrExprModel,
    BackendEmitExprModel,
    FreeExprModel,
    OperandExprModel,
    Scope,
}
use types for std::jule::types::{
    MaxF32,
    MaxF64,
    MinF32,
    MinF64,
    MaxI64,
    MinI64,
    MaxU64,
}
use math for std::math
use strings for std::strings
use utf8 for std::unicode::utf8

// Ignore expression for std::tie function.
const cppIgnore = "std::ignore"

// Represents default expression for type.
const cPpDefaultExpr = "{}"

type PrimKind: types::TypeKind

// Common group of semantic analysis expression model types and optimizer specific types.
enum compExprModel: type {
    ExprModel: ExprModel,
    str, // For built-in expressions.
    &UnsafeBinopExprModel,
    &UnsafeIndexingExprModel,
    &MutSlicingExprModel,
    &StrInsertBeginExprModel,
}

struct exprCoder {
    oc: &ObjectCoder
}

impl exprCoder {
    static fn new(mut &oc: &ObjectCoder): &exprCoder {
        ret &exprCoder{
            oc: oc,
        }
    }

    fn string(mut &self, &c: &Const) {
        let content = c.ReadStr()
        if len(content) == 0 { // Empty.
            self.oc.write(typeCoder.Str + "()")
            ret
        }
        let bytes = []byte(content)
        let len = conv::FmtInt(i64(len(bytes)), 10)
        let lit = cstrLit(bytes)
        self.oc.write(typeCoder.Str)
        self.oc.write("(")
        self.oc.write(lit)
        self.oc.write(", ")
        self.oc.write(len)
        self.oc.write(")")
    }

    fn boolean(mut &self, &c: &Const) {
        if c.ReadBool() {
            self.oc.write("true")
            ret
        }
        self.oc.write("false")
    }

    fn nilLit(mut &self) {
        self.oc.write("nullptr")
    }

    fn ftoaSpecialCases(mut &self, &x: f64): bool {
        match {
        | math::IsNaN(x):
            self.oc.write("NAN")
        | math::IsInf(x, 1):
            self.oc.write("INFINITY")
        | math::IsInf(x, -1):
            self.oc.write("-INFINITY")
        |:
            ret false
        }
        ret true
    }

    fn float32(mut &self, &c: &Const) {
        let x = c.AsF64()

        // Special cases.
        if self.ftoaSpecialCases(x) {
            ret
        }

        match {
        | x == MaxF32:
            self.oc.write("jule::MAX_F32")
        | x == MinF32:
            self.oc.write("jule::MIN_F32")
        |:
            self.oc.write(ftoa(x, 1 << 5))
            self.oc.write("f")
        }
    }

    fn float64(mut &self, &c: &Const) {
        let x = c.AsF64()

        // Special cases.
        if self.ftoaSpecialCases(x) {
            ret
        }

        match {
        | x == MaxF64:
            self.oc.write("jule::MAX_F64")
        | x == MinF64:
            self.oc.write("jule::MIN_F64")
        |:
            self.oc.write(ftoa(x, 1 << 6))
        }
    }

    fn constant(mut &self, mut c: &Const) {
        match {
        | c.IsStr():
            self.string(c)
        | c.IsBool():
            self.boolean(c)
        | c.IsF64():
            match {
            | c.Kind == PrimKind.F32:
                self.float32(c)
            |:
                self.float64(c)
            }
        | c.IsI64():
            self.oc.write(itoa(c.ReadI64()))
        | c.IsU64():
            self.oc.write(utoa(c.ReadU64()))
        | c.IsNil():
            self.nilLit()
        |:
            self.oc.write("<unimplemented_constant_expression>")
        }
    }

    fn divByZeroBinary(mut &self, &op: &Token, mut &l: &OperandExprModel, mut &r: &OperandExprModel) {
        self.oc.write("jule::")
        match op.Kind {
        | TokenKind.Solidus
        | TokenKind.SolidusEq:
            self.oc.write("div(")
        | TokenKind.Percent
        | TokenKind.PercentEq:
            self.oc.write("mod(")
        }

        if !env::Production {
            self.oc.write("\"")
            self.oc.locInfo(op)
            self.oc.write("\",")
        }
        self.expr(l.Model)
        self.oc.write(",")
        self.expr(r.Model)
        self.oc.write(")")
    }

    fn unsafeBinary(mut &self, mut m: &BinopExprModel) {
        self.oc.write("(")
        self.model(m.Left.Model)
        self.oc.write(" ")
        self.oc.write(m.Op.Kind)
        self.oc.write(" ")
        self.model(m.Right.Model)
        self.oc.write(")")
    }

    fn binary(mut &self, mut m: &BinopExprModel) {
        match m.Op.Kind {
        | TokenKind.Solidus | TokenKind.Percent:
            // Do not check division of structures safety.
            if m.Left.Kind.Struct() == nil {
                self.divByZeroBinary(m.Op, m.Left, m.Right)
                ret
            }
        }
        self.unsafeBinary(m)
    }

    fn var(mut &self, mut m: &Var) {
        if m.CppLinked {
            let d = findDirective(m.Directives, Directive.Namespace)
            if d != nil {
                self.oc.write(concatAllParts(d.Args...))
                self.oc.write("::")
            }
        }
        self.oc.write(identCoder.var(m))
    }

    fn structureIns(mut &self, mut m: &StructIns) {
        self.oc.write(typeCoder.structureIns(m))
    }

    fn unary(mut &self, mut m: &UnaryExprModel) {
        match m.Op.Kind {
        | TokenKind.Caret:
            self.oc.write("(~(")
            self.expr(m.Expr.Model)
            self.oc.write("))")
            ret
        | TokenKind.Star:
            if env::Production || m.Expr.Kind.Sptr() == nil {
                break
            }
            self.expr(m.Expr.Model)
            self.oc.write(".get(\"")
            self.oc.locInfo(m.Op)
            self.oc.write("\")")
            ret
        }
        self.oc.write("(")
        self.oc.write(m.Op.Kind)
        self.oc.write("(")
        self.expr(m.Expr.Model)
        self.oc.write("))")
    }

    fn structureLit(mut &self, mut m: &StructLitExprModel) {
        if m.Strct.Decl.CppLinked {
            self.oc.write("(")
        }
        self.oc.write(identCoder.structureIns(m.Strct))
        if m.Strct.Decl.CppLinked {
            self.oc.write(")")
        }
        self.oc.write("{")
        if len(m.Args) > 0 {
            // Fields are should be in order.
            // In other words, GCC will produce error(s).
        iter:
            for i, f in m.Strct.Fields {
                for (_, mut arg) in m.Args {
                    if arg.Field == f {
                        self.oc.write(".")
                        self.oc.write(identCoder.field(arg.Field.Decl))
                        self.oc.write("=")
                        self.expr(arg.Expr)
                        if len(m.Strct.Fields)-i > 1 {
                            self.oc.write(", ")
                        }
                        continue iter
                    }
                }
            }
        }
        self.oc.write("}")
    }

    fn allocStructure(mut &self, mut m: &AllocStructLitExprModel) {
        self.oc.write("jule::new_ptr<")
        self.oc.write(identCoder.structureIns(m.Lit.Strct))
        self.oc.write(">(")
        self.structureLit(m.Lit)
        self.oc.write(")")
    }

    fn casting(mut &self, mut m: &CastingExprModel) {
        match {
        | m.Kind.Prim() != nil && m.Kind.Prim().IsAny():
            self.oc.write(typeCoder.kind(m.Kind))
            self.oc.write("(")
            self.model(m.Expr)
            self.oc.write(")")
        | m.ExprKind.Ptr() != nil
        | m.Kind.Ptr() != nil:
            self.oc.write("((")
            self.oc.write(typeCoder.kind(m.Kind))
            self.oc.write(")(")
            self.expr(m.Expr)
            self.oc.write("))")
        | m.ExprKind.Trait() != nil
        | m.ExprKind.Prim() != nil && m.ExprKind.Prim().IsAny()
        | m.ExprKind.TypeEnum() != nil:
            self.model(m.Expr)
            self.oc.write(".")
            if env::Production {
                self.oc.write("operator ")
                self.oc.write(typeCoder.kind(m.Kind))
                self.oc.write("()")
            } else {
                if m.Kind.Sptr() != nil {
                    self.oc.write("cast_ptr<")
                    self.oc.write(typeCoder.kind(m.Kind.Sptr().Elem))
                } else {
                    self.oc.write("cast<")
                    self.oc.write(typeCoder.kind(m.Kind))
                }
                self.oc.write(">(\"")
                self.oc.locInfo(m.Token)
                self.oc.write("\")")
            }
        | m.Kind.Trait() != nil:
            self.oc.write(typeCoder.kind(m.Kind))
            self.oc.write("(")
            self.expr(m.Expr)
            self.oc.write(", ")
            self.oc.write(conv::Itoa(self.oc.findTypeOffset(m.Kind.Trait(), m.ExprKind)))
            self.oc.write(")")
        |:
            self.oc.write("static_cast<")
            self.oc.write(typeCoder.kind(m.Kind))
            self.oc.write(">(")
            self.expr(m.Expr)
            self.oc.write(")")
        }
    }

    fn args(mut &self, mut args: []ExprModel) {
        if len(args) == 0 {
            ret
        }
        for (i, mut a) in args {
            self.expr(a)
            if len(args)-i > 1 {
                self.oc.write(",")
            }
        }
    }

    fn modelForCall(mut &self, mut expr: compExprModel) {
        match type expr {
        | &FnIns:
            self.funcIns((&FnIns)(expr))
            ret
        | &StructSubIdentExprModel:
            let mut ssie = (&StructSubIdentExprModel)(expr)
            if ssie.Method != nil {
                self.funcIns(ssie.Method)
                ret
            }
        }
        self.model(expr)
    }

    fn pushCallInf(mut &self, &m: &FnCallExprModel) {
        if env::Production || (!m.Func.Anon && !isBuiltinCallHasDebuginf(m)) {
            self.oc.write("(")
            ret
        }
        if m.Func.Anon {
            match type m.Expr {
            | &StructSubIdentExprModel:
                if (&StructSubIdentExprModel)(m.Expr).Field.Decl.Owner.CppLinked {
                    self.oc.write("(")
                    ret
                }
                fall
            |:
                self.oc.write(".call")
            }
        }
        self.oc.write("(\"")
        self.oc.locInfo(m.Token)
        self.oc.write("\"")
        if len(m.Args) != 0 {
            self.oc.write(",")
        }
    }

    fn isWrapped(mut &self, mut &m: &FnCallExprModel): bool {
        if !m.Func.IsBuiltin() && len(m.Func.Decl.Params) > 0 && m.Func.Decl.Params[0].IsSelf() {
            match type m.Expr {
            | &StructSubIdentExprModel:
                let mut ssie = (&StructSubIdentExprModel)(m.Expr)
                match {
                | m.Func.Decl.Params[0].IsRef()
                | ssie.ExprKind.Sptr() != nil:
                    break
                |:
                    if ssie.Expr.Kind.Struct() != nil {
                        if !ssie.Expr.Lvalue {
                            self.oc.write("({ auto _wrap_copy = ")
                            self.model(ssie.Expr.Model)
                            self.oc.write("; ")
                            ret true
                        }
                    }
                }
            }
        }
        ret false
    }

    fn pureFuncCall(mut &self, mut &m: &FnCallExprModel) {
        let wrapped = self.isWrapped(m)
        self.modelForCall(m.Expr)
        if !m.Func.IsBuiltin() {
            if m.Func.Decl.CppLinked && len(m.Func.Generics) > 0 {
                if !hasDirective(m.Func.Decl.Directives, Directive.Cdef) {
                    self.oc.write("<")
                    for (i, mut g) in m.Func.Generics {
                        self.oc.write(typeCoder.kind(g.Kind))
                        if len(m.Func.Generics)-i > 1 {
                            self.oc.write(",")
                        }
                    }
                    self.oc.write(">")
                }
            }
        }
        self.pushCallInf(m)
        let mut locinfo = false
        if !m.Func.IsBuiltin() && len(m.Func.Decl.Params) > 0 && m.Func.Decl.Params[0].IsSelf() {
            match type m.Expr {
            | &StructSubIdentExprModel:
                let mut ssie = (&StructSubIdentExprModel)(m.Expr)
                match {
                | m.Func.Decl.Params[0].IsRef():
                    self.model(ssie.Expr.Model)
                | ssie.ExprKind.Sptr() != nil:
                    self.model(ssie.Expr.Model)
                    self.oc.write(".ptr(")
                    if !env::Production {
                        self.oc.write("\"")
                        self.oc.locInfo(m.Token)
                        self.oc.write("\"")
                    }
                    self.oc.write(")")
                |:
                    if ssie.Expr.Kind.Struct() != nil {
                        // Add address taking operation for non-pointers.
                        self.oc.write("&")
                    }
                    if wrapped {
                        self.oc.write("_wrap_copy")
                    } else {
                        self.model(ssie.Expr.Model)
                    }
                }
                if len(m.Args) > 0 {
                    self.oc.write(", ")
                }
            | &TraitSubIdentExprModel:
                self.model((&TraitSubIdentExprModel)(m.Expr).Expr)
                if !env::Production {
                    locinfo = true
                }
                if len(m.Args) > 0 {
                    self.oc.write(", ")
                }
            }
        }
        self.args(m.Args)
        if locinfo {
            self.oc.write(", \"")
            self.oc.locInfo(m.Token)
            self.oc.write("\"")
        }
        self.oc.write(")")

        if wrapped {
            self.oc.write("; })")
        }
    }

    fn coFuncCall(mut &self, mut &m: &FnCallExprModel) {
        self.oc.write("{\n")
        self.oc.addIndent()
        let mut head = "std::thread(["
        if m.Func.Owner != nil {
            head += identCoder.Self
            if len(m.Args) > 0 {
                head += ", "
            }
        }
        for i, arg in m.Args {
            if i > 0 {
                head += ", "
            }
            match type arg {
            | &Var:
                let mut v = (&Var)(arg)
                head += identCoder.var(v)
                continue
            }
            let name = "_co_arg_" + conv::Itoa(i)
            head += name
            self.oc.indent()
            self.oc.write(typeCoder.kind(m.Func.Params[i].Kind))
            self.oc.write(" ")
            if m.Func.Params[i].Decl.Reference {
                self.oc.write("&")
            }
            self.oc.write(name)
            self.oc.write(" = ")
            self.expr(arg)
            self.oc.write(";\n")
            let argS: any = name
            m.Args[i] = unsafe { *(*ExprModel)(&argS) }
        }
        self.oc.indent()
        self.oc.write(head)
        self.oc.write("](void) mutable -> void {\n")
        self.oc.addIndent()
        self.oc.indent()
        self.pureFuncCall(m)
        self.oc.write(";\n")
        self.oc.doneIndent()
        self.oc.indent()
        self.oc.write("}).detach();\n")
        self.oc.doneIndent()
        self.oc.indent()
        self.oc.write("}")
    }

    fn funcCall(mut &self, mut m: &FnCallExprModel) {
        if m.IsCo {
            self.coFuncCall(m)
            ret
        }
        if m.Func.IsBuiltin() ||
            !m.Func.Decl.Exceptional ||
            m.Except != nil && len(m.Except.Stmts) == 0 {
            self.pureFuncCall(m)
            ret
        }

        // Generate code for exceptional.
        self.oc.write("({\n")
        self.oc.addIndent()
        self.oc.indent()
        self.oc.write("auto except = ")
        self.pureFuncCall(m)
        self.oc.write(";\n")
        self.oc.indent()
        if m.Except != nil {
            if m.Func.Result == nil || !m.Assigned {
                self.oc.write("if (!except.ok()) ")
                self.oc.sc.scope(m.Except)
                self.oc.write("\n")
            } else {
                let forwarded = isForwarded(m.Except)
                self.oc.write("(except.ok()) ? (except.result) : (")
                if forwarded {
                    self.oc.write("{")
                }
                self.oc.sc.scope(m.Except)
                if forwarded {
                    self.oc.write(" ")
                    self.initExpr(m.Func.Result)
                    self.oc.write(";}")
                }
                self.oc.write(");\n")
            }
            self.oc.doneIndent()
        } else {
            self.oc.write(`if (!except.ok()) jule::panic(jule::Str("unhandled exceptional: ") + except.error.type->to_str(except.error.data) + jule::Str("\nlocation: `)
            self.oc.locInfo(m.Token)
            self.oc.write("\"));\n")
            if !m.Func.Decl.IsVoid() {
                self.oc.indent()
                self.oc.write("(except.result);\n")
            }
            self.oc.doneIndent()
        }

        self.oc.indent()
        self.oc.write("})")
    }

    fn slice(mut &self, mut m: &SliceExprModel) {
        if len(m.Elems) == 0 {
            self.oc.write(typeCoder.asSlice(m.ElemKind))
            self.oc.write("()")
            ret
        }
        self.oc.write(typeCoder.asSlice(m.ElemKind))
        self.oc.write("::make({")
        self.args(m.Elems)
        self.oc.write("})")
    }

    fn indexing(mut &self, mut m: &IndexingExprModel) {
        self.model(m.Expr.Model)
        // Index access with safety measures.
        match {
        | env::Production
        | m.Expr.Kind.Ptr() != nil
        | m.Expr.Kind.Map() != nil
        | isExprComesFromBind(m.Expr):
            self.oc.write("[")
            self.expr(m.Index.Model)
            self.oc.write("]")
        |:
            self.oc.write(".at(\"")
            self.oc.locInfo(m.Token)
            self.oc.write("\",")
            self.expr(m.Index.Model)
            self.oc.write(")")
        }
    }

    fn unsafeIndexing(mut &self, mut m: &UnsafeIndexingExprModel) {
        self.model(m.Node.Expr.Model)
        // Index access with safety measures.
        match {
        | env::Production
        | m.Node.Expr.Kind.Ptr() != nil
        | m.Node.Expr.Kind.Map() != nil:
            self.oc.write("[")
            self.expr(m.Node.Index.Model)
            self.oc.write("]")
        |:
            self.oc.write(".__at(")
            self.expr(m.Node.Index.Model)
            self.oc.write(")")
        }
    }

    fn anonFunc(mut &self, mut m: &AnonFnExprModel) {
        self.oc.write(typeCoder.func(m.Func))
        self.oc.write("([=]")
        self.oc.paramsIns(m.Func.Params)
        self.oc.write(" mutable -> ")
        self.oc.write(typeCoder.funcInsResult(m.Func))
        self.oc.write(" ")
        self.oc.sc.funcScope(m.Func)
        self.oc.write(")")
    }

    fn mapExpr(mut &self, mut m: &MapExprModel) {
        self.oc.write(typeCoder.Map + "<")
        self.oc.write(typeCoder.kind(m.KeyKind))
        self.oc.write(",")
        self.oc.write(typeCoder.kind(m.ValKind))
        self.oc.write(">({")
        if len(m.Entries) > 0 {
            for (i, mut pair) in m.Entries {
                self.oc.write("{")
                self.expr(pair.Key)
                self.oc.write(",")
                self.expr(pair.Val)
                self.oc.write("}")
                if len(m.Entries)-i > 1 {
                    self.oc.write(",")
                }
            }
        }
        self.oc.write("})")
    }

    fn slicing(mut &self, mut m: &SlicingExprModel) {
        self.model(m.Expr)
        self.oc.write(".slice(")
        if !env::Production {
            self.oc.write("\"")
            self.oc.locInfo(m.Token)
            self.oc.write("\",")
        }
        self.expr(m.Left)
        if m.Right != nil {
            self.oc.write(",")
            self.expr(m.Right)
        }
        self.oc.write(")")
    }

    fn traitSub(mut &self, mut m: &TraitSubIdentExprModel) {
        self.oc.write(identCoder.traitDecl(m.Trt))
        self.oc.write("_mptr_data")
        self.oc.write("[(")
        self.model(m.Expr)
        self.oc.write(").type_offset].")
        self.oc.write(identCoder.func(m.Method))
    }

    fn structureSub(mut &self, mut m: &StructSubIdentExprModel) {
        self.model(m.Expr.Model)
        if m.Field != nil {
            if m.ExprKind.Ptr() != nil {
                self.oc.write("->")
            } else if m.ExprKind.Sptr() != nil {
                self.oc.write(".get(")
                if !env::Production {
                    self.oc.write("\"")
                    self.oc.locInfo(m.Token)
                    self.oc.write("\"")
                }
                self.oc.write(").")
            } else {
                self.oc.write(".")
            }
            self.oc.write(identCoder.field(m.Field.Decl))
        }
    }

    fn commonIdent(mut &self, m: &CommonIdentExprModel) {
        self.oc.write(m.Ident)
    }

    fn commonSub(mut &self, mut m: &CommonSubIdentExprModel) {
        self.model(m.Expr)
        match {
        | m.ExprKind.Ptr() != nil:
            self.oc.write("->")
        | m.ExprKind.Sptr() != nil:
            self.oc.write(".get(")
            if !env::Production {
                self.oc.write("\"")
                self.oc.locInfo(m.Token)
                self.oc.write("\"")
            }
            self.oc.write(").")
        |:
            self.oc.write(".")
        }
        self.oc.write(m.Ident)
    }

    fn array(mut &self, mut m: &ArrayExprModel) {
        self.oc.write(typeCoder.array(m.Kind))
        if len(m.Elems) == 0 {
            self.oc.write("()")
            ret
        }

        // Filled.
        if len(m.Elems) == 2 && m.Elems[1] == nil {
            self.oc.write("(")
            self.expr(m.Elems[0])
            self.oc.write(")")
            ret
        }

        self.oc.write("({")
        self.args(m.Elems)
        self.oc.write("})")
        ret
    }

    // Writes complete expression model of function instance.
    // Usefull for strict type safety.
    fn funcInsCommon(mut &self, mut m: &FnIns) {
        self.oc.write(typeCoder.func(m))
        self.oc.write("(")
        self.funcIns(m)
        self.oc.write(")")
    }

    fn funcIns(mut &self, mut m: &FnIns) {
        if m.Decl != nil && m.Decl.CppLinked {
            let d = findDirective(m.Decl.Directives, Directive.Namespace)
            if d != nil {
                self.oc.write(concatAllParts(d.Args...))
                self.oc.write("::")
            }
        }
        self.oc.write(identCoder.funcIns(m))
    }

    fn tuple(mut &self, mut m: &TupleExprModel) {
        self.oc.write("std::make_tuple(")
        for (i, mut d) in m.Datas {
            self.expr(d.Model)
            if len(m.Datas)-i > 1 {
                self.oc.write(",")
            }
        }
        self.oc.write(")")
    }

    fn newCall(mut &self, mut m: &BuiltinNewCallExprModel) {
        self.oc.write("jule::new_ptr<")
        self.oc.write(typeCoder.kind(m.Kind))
        self.oc.write(">(")
        if m.Init != nil {
            self.expr(m.Init)
        }
        self.oc.write(")")
    }

    fn outCall(mut &self, mut m: &BuiltinOutCallExprModel) {
        if m.Debug && env::Production {
            ret
        }
        self.oc.write("jule::out(")
        self.expr(m.Expr)
        self.oc.write(")")
    }

    fn outlnCall(mut &self, mut m: &BuiltinOutlnCallExprModel) {
        if m.Debug && env::Production {
            ret
        }
        self.oc.write("jule::outln(")
        self.expr(m.Expr)
        self.oc.write(")")
    }

    fn panicCall(mut &self, mut m: &BuiltinPanicCallExprModel) {
        self.oc.write("jule::panic(")
        self.expr(m.Expr)
        self.oc.write(` + jule::Str("\nlocation: `)
        self.oc.locInfo(m.Token)
        self.oc.write("\"));")
    }

    fn assertCall(mut &self, mut m: &BuiltinAssertCallExprModel) {
        if env::Production {
            ret
        }
        self.oc.write("if (!(")
        self.expr(m.Expr)
        self.oc.write(")) jule::panic(jule::Str(")
        self.oc.write(cstrLit([]byte(m.Log)))
        self.oc.write(`) + jule::Str("\nlocation: `)
        self.oc.locInfo(m.Token)
        self.oc.write("\"));")
    }

    fn errorCall(mut &self, mut m: &BuiltinErrorCallExprModel) {
        self.oc.write("return ")
        if m.Func.Decl.IsVoid() {
            self.oc.write("jule::VoidExceptional(")
        } else {
            self.oc.write("jule::Exceptional<")
            self.oc.write(typeCoder.kind(m.Func.Result))
            self.oc.write(">(")
        }
        self.expr(m.Err)
        self.oc.write(")")
    }

    fn copyCall(mut &self, mut m: &BuiltinCopyCallExprModel) {
        self.oc.write("jule::copy((")
        self.model(m.Dest.Model)
        self.oc.write(")")
        if m.Dest.Kind.Prim() != nil { // String destination.
            self.oc.write(".fake_slice()")
        }
        self.oc.write(", (")
        self.model(m.Src.Model)
        self.oc.write(")")
        if m.Src.Kind.Prim() != nil { // String source.
            self.oc.write(".fake_slice()")
        }
        self.oc.write(")")
    }

    fn lenCall(mut &self, mut m: &BuiltinLenCallExprModel) {
        self.model(m.Expr.Model)
        self.oc.write(".len()")
    }

    fn capCall(mut &self, mut m: &BuiltinCapCallExprModel) {
        self.model(m.Expr.Model)
        self.oc.write(".cap()")
    }

    fn deleteCall(mut &self, mut m: &BuiltinDeleteCallExprModel) {
        self.model(m.Dest.Model)
        if m.Key != nil {
            self.oc.write(".del(")
            self.model(m.Key.Model)
            self.oc.write(")")
        } else {
            self.oc.write(".clear()")
        }
    }

    fn makeCallSlice(mut &self, mut &m: &BuiltinMakeCallExprModel) {
        let mut slice = m.Kind.Slc()
        self.oc.write(typeCoder.kind(m.Kind))
        if slice.Elem.Enum() != nil {
            if m.Cap != nil {
                self.oc.write("::alloc(")
            } else {
                self.oc.write("::alloc_def(")
            }
        } else {
            self.oc.write("::alloc(")
        }

        self.expr(m.Len)
        if m.Cap != nil {
            self.oc.write(",")
            self.expr(m.Cap)
        }

        if slice.Elem.Enum() != nil {
            self.oc.write(",")
            self.initExpr(slice.Elem)
        }
        self.oc.write(")")
    }

    fn makeCallStr(mut &self, mut &m: &BuiltinMakeCallExprModel) {
        self.oc.write(typeCoder.Str)
        self.oc.write("::alloc(")
        self.expr(m.Len)
        if m.Cap != nil {
            self.oc.write(", ")
            self.expr(m.Cap)
        }
        self.oc.write(")")
    }

    fn makeCall(mut &self, mut m: &BuiltinMakeCallExprModel) {
        if m.Kind.Slc() != nil {
            self.makeCallSlice(m)
            ret
        }
        self.makeCallStr(m)
    }

    fn pushToSlice(mut &self, mut m: &PushToSliceExprModel) {
        let n = len(self.oc.Obj)
        self.model(m.Dest)
        let dest = self.oc.Obj[n:]

        self.oc.write(" = jule::alloc_for_append(")
        self.oc.write(dest)
        self.oc.write(",")
        self.oc.write(conv::Itoa(len(m.Elems.Elems)))
        self.oc.write(");")
        for (_, mut e) in m.Elems.Elems {
            self.oc.write(dest)
            // Use the "__push" method to skip allocation boundary checking.
            self.oc.write(".__push(")
            self.model(e)
            self.oc.write(");")
        }
    }

    fn appendCall(mut &self, mut m: &BuiltinAppendCallExprModel) {
        self.oc.write("jule::append(")
        self.model(m.Dest)
        self.oc.write(",")
        self.model(m.Elements)
        self.oc.write(")")
    }

    fn cloneCall(mut &self, mut m: &BuiltinCloneCallExprModel) {
        self.oc.write("jule::clone(")
        self.model(m.Expr)
        self.oc.write(")")
    }

    fn sizeof(mut &self, mut m: &SizeofExprModel) {
        self.oc.write("sizeof(")
        self.model(m.Expr)
        self.oc.write(")")
    }

    fn alignof(mut &self, mut m: &AlignofExprModel) {
        self.oc.write("alignof(")
        self.model(m.Expr)
        self.oc.write(")")
    }

    fn runeLit(mut &self, m: &RuneExprModel): str {
        if m.Code <= 127 { // ASCII
            let mut b = sbtoa(byte(m.Code))
            if b == "'" {
                b = "\\'"
            }
            ret "'" + b + "'"
        }
        ret itoa(i64(m.Code))
    }

    fn structureStatic(mut &self, mut m: &StructStaticIdentExprModel) {
        self.oc.write(identCoder.funcIns(m.Method))
    }

    fn integratedToStr(mut &self, mut m: &IntegratedToStrExprModel) {
        self.oc.write("jule::to_str(")
        self.model(m.Expr)
        self.oc.write(")")
    }

    fn backendEmit(mut &self, mut m: &BackendEmitExprModel) {
        if len(m.Exprs) == 0 {
            self.oc.write(m.Code)
            ret
        }
        let n = len(self.oc.Obj)
        let mut args = make([]any, len(m.Exprs))
        for (i, mut expr) in m.Exprs {
            self.expr(expr)
            args[i] = self.oc.Obj[n:]
            self.oc.Obj = self.oc.Obj[:n]
        }
        self.oc.write(fmt::Format(m.Code, args...))
    }

    fn free(mut &self, mut m: &FreeExprModel) {
        self.expr(m.Expr)
        if env::RC {
            self.oc.write(".dealloc()")
            ret
        }
        self.oc.write(".__free()")
    }

    fn mutSlicing(mut &self, mut m: &MutSlicingExprModel) {
        self.oc.write("(")
        self.model(m.Expr)
        self.oc.write(").mut_slice(")
        if !env::Production {
            self.oc.write("\"")
            self.oc.locInfo(m.Token)
            self.oc.write("\",")
        }
        self.expr(m.Left)
        if m.Right != nil {
            self.oc.write(",")
            self.expr(m.Right)
        }
        self.oc.write(");")
    }

    fn strInsertBegin(mut &self, mut m: &StrInsertBeginExprModel) {
        self.oc.write("(")
        self.model(m.Dest)
        self.oc.write(").buffer.insert(0, (")
        self.model(m.Expr)
        self.oc.write("));")
    }

    fn model(mut &self, mut m: compExprModel) {
        match type m {
        | str:
            self.oc.write(str(m))
        | &TypeKind:
            self.oc.write(typeCoder.kind((&TypeKind)(m)))
        | &Const:
            self.constant((&Const)(m))
        | &Var:
            self.var((&Var)(m))
        | &StructIns:
            self.structureIns((&StructIns)(m))
        | &FnIns:
            self.funcInsCommon((&FnIns)(m))
        | &UnsafeBinopExprModel:
            self.unsafeBinary((&UnsafeBinopExprModel)(m).Node)
        | &BinopExprModel:
            self.binary((&BinopExprModel)(m))
        | &UnaryExprModel:
            self.unary((&UnaryExprModel)(m))
        | &StructLitExprModel:
            self.structureLit((&StructLitExprModel)(m))
        | &AllocStructLitExprModel:
            self.allocStructure((&AllocStructLitExprModel)(m))
        | &CastingExprModel:
            self.casting((&CastingExprModel)(m))
        | &FnCallExprModel:
            self.funcCall((&FnCallExprModel)(m))
        | &SliceExprModel:
            self.slice((&SliceExprModel)(m))
        | &ArrayExprModel:
            self.array((&ArrayExprModel)(m))
        | &UnsafeIndexingExprModel:
            self.unsafeIndexing((&UnsafeIndexingExprModel)(m))
        | &IndexingExprModel:
            self.indexing((&IndexingExprModel)(m))
        | &AnonFnExprModel:
            self.anonFunc((&AnonFnExprModel)(m))
        | &MapExprModel:
            self.mapExpr((&MapExprModel)(m))
        | &SlicingExprModel:
            self.slicing((&SlicingExprModel)(m))
        | &TraitSubIdentExprModel:
            self.traitSub((&TraitSubIdentExprModel)(m))
        | &StructSubIdentExprModel:
            self.structureSub((&StructSubIdentExprModel)(m))
        | &CommonIdentExprModel:
            self.commonIdent((&CommonIdentExprModel)(m))
        | &CommonSubIdentExprModel:
            self.commonSub((&CommonSubIdentExprModel)(m))
        | &TupleExprModel:
            self.tuple((&TupleExprModel)(m))
        | &BuiltinOutCallExprModel:
            self.outCall((&BuiltinOutCallExprModel)(m))
        | &BuiltinOutlnCallExprModel:
            self.outlnCall((&BuiltinOutlnCallExprModel)(m))
        | &BuiltinNewCallExprModel:
            self.newCall((&BuiltinNewCallExprModel)(m))
        | &BuiltinPanicCallExprModel:
            self.panicCall((&BuiltinPanicCallExprModel)(m))
        | &BuiltinAssertCallExprModel:
            self.assertCall((&BuiltinAssertCallExprModel)(m))
        | &BuiltinErrorCallExprModel:
            self.errorCall((&BuiltinErrorCallExprModel)(m))
        | &BuiltinMakeCallExprModel:
            self.makeCall((&BuiltinMakeCallExprModel)(m))
        | &BuiltinAppendCallExprModel:
            self.appendCall((&BuiltinAppendCallExprModel)(m))
        | &BuiltinCloneCallExprModel:
            self.cloneCall((&BuiltinCloneCallExprModel)(m))
        | &BuiltinCopyCallExprModel:
            self.copyCall((&BuiltinCopyCallExprModel)(m))
        | &BuiltinLenCallExprModel:
            self.lenCall((&BuiltinLenCallExprModel)(m))
        | &BuiltinCapCallExprModel:
            self.capCall((&BuiltinCapCallExprModel)(m))
        | &BuiltinDeleteCallExprModel:
            self.deleteCall((&BuiltinDeleteCallExprModel)(m))
        | &SizeofExprModel:
            self.sizeof((&SizeofExprModel)(m))
        | &AlignofExprModel:
            self.alignof((&AlignofExprModel)(m))
        | &RuneExprModel:
            self.oc.write(self.runeLit((&RuneExprModel)(m)))
        | &StructStaticIdentExprModel:
            self.structureStatic((&StructStaticIdentExprModel)(m))
        | &IntegratedToStrExprModel:
            self.integratedToStr((&IntegratedToStrExprModel)(m))
        | &BackendEmitExprModel:
            self.backendEmit((&BackendEmitExprModel)(m))
        | &FreeExprModel:
            self.free((&FreeExprModel)(m))
        | &MutSlicingExprModel:
            self.mutSlicing((&MutSlicingExprModel)(m))
        | &StrInsertBeginExprModel:
            self.strInsertBegin((&StrInsertBeginExprModel)(m))
        |:
            self.oc.write("<unimplemented_expression_model>")
        }
    }

    fn expr(mut &self, mut e: compExprModel) {
        self.model(e)
    }

    fn val(mut &self, mut v: &Value) {
        if v.Data.IsConst() {
            self.constant(v.Data.Constant)
            ret
        }
        self.expr(v.Data.Model)
    }

    fn initExpr(mut &self, mut t: &TypeKind) {
        if t.Ptr() != nil {
            self.oc.write("nullptr")
            ret
        }
        let mut enm = t.Enum()
        if enm != nil {
            self.val(enm.Items[0].Value)
            ret
        }
        let s = t.Struct()
        if s != nil && s.Decl.CppLinked {
            self.oc.write("(")
            self.oc.write(typeCoder.kind(t))
            self.oc.write("){}")
            ret
        }
        self.oc.write(typeCoder.kind(t))
        self.oc.write("()")
    }
}

fn decomposeCommonEsq(b: byte): str {
    match b {
    | '\\':
        ret "\\\\"
    | '\'':
        ret "'"
    | '"':
        ret `\"`
    | '\a':
        ret `\a`
    | '\b':
        ret `\b`
    | '\f':
        ret `\f`
    | '\n':
        ret `\n`
    | '\r':
        ret `\r`
    | '\t':
        ret `\t`
    | '\v':
        ret `\v`
    |:
        ret ""
    }
}

fn sbtoa(b: byte): str {
    if b == 0 {
        ret "\\x00"
    }
    if b < utf8::RuneSelf { // ASCII, fast way.
        let seq = decomposeCommonEsq(b)
        if seq != "" {
            ret seq
        }
        if 32 <= b && b <= 126 {
            ret str(b)
        }
    }
    let seq = conv::FmtUint(u64(b), 8)
    if len(seq) == 2 {
        ret "\\0" + seq
    }
    ret "\\" + seq
}

fn cstrBytes(bytes: []byte): str {
    let mut lit = make(str, 0, len(bytes))
    for _, b in bytes {
        lit += sbtoa(b)
    }
    ret lit
}

fn cstrLit(bytes: []byte): str {
    ret `"` + cstrBytes(bytes) + `"`
}

fn ftoa(f: f64, bitsize: int): str {
    if bitsize != 32 {
        if f == f64(i64(f)) {
            ret itoa(i64(f))
        }
        if f == f64(u64(f)) {
            ret utoa(u64(f))
        }
    }
    let mut m = conv::FmtFloat(f, 'f', -1, bitsize)
    if !strings::Contains(m, ".") {
        m += ".0"
    }
    ret m
}

fn itoa(x: i64): str {
    match {
    | x == MaxI64:
        ret "jule::MAX_I64"
    | x == MinI64:
        ret "jule::MIN_I64"
    }

    let fmt = conv::FmtInt(x, 10)
    if Is64Bit(Arch) {
        ret fmt + "LL"
    }
    ret fmt + "L"
}

fn utoa(x: u64): str {
    match {
    | x == MaxU64:
        ret "jule::MAX_U64"
    }

    let fmt = conv::FmtUint(x, 10)
    if Is64Bit(Arch) {
        ret fmt + "LLU"
    }
    ret fmt + "LU"
}

fn isForwarded(&s: &Scope): bool {
    let last = s.Stmts[len(s.Stmts)-1]
    match type last {
    | &Data:
        match type (&Data)(last).Model {
        | &BuiltinErrorCallExprModel:
            ret true
        |:
            ret false
        }
    |:
        ret true
    }
}

fn isBuiltinCallHasDebuginf(&m: &FnCallExprModel): bool {
    if !m.Func.IsBuiltin() {
        ret false
    }
    match type m.Expr {
    | &CommonSubIdentExprModel:
        let csie = (&CommonSubIdentExprModel)(m.Expr)
        ret csie.Ident == "swap"
    |:
        ret false
    }
}

fn isExprComesFromBind(&d: &Data): bool {
    match type d.Model {
    | &Var:
        ret (&Var)(d.Model).CppLinked
    | &StructSubIdentExprModel:
        ret (&StructSubIdentExprModel)(d.Model).Owner.Decl.CppLinked
    |:
        ret false
    }
}