// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use opt::{
    self,
    PushToSliceExprModel,
    MutSlicingExprModel,
    StrInsertBeginExprModel,
}
use lex for std::jule::lex::{TokenKind}
use std::jule::sema::{
    Data,
    Stmt,
    FnIns,
    Var,
    Scope,
    If,
    Conditional,
    InfIter,
    WhileIter,
    RangeIter,
    ContSt,
    BreakSt,
    Label,
    GotoSt,
    Postfix,
    Assign,
    MultiAssign,
    Match,
    Case,
    FallSt,
    RetSt,
    TupleExprModel,
    TypeKind,
    BuiltinAppendCallExprModel,
    SlicingExprModel,
}

const MATCH_EXPR = "_match_expr"

struct ScopeCoder {
    oc: &ObjectCoder
}

impl ScopeCoder {
    static fn new(mut &oc: &ObjectCoder): &ScopeCoder {
        ret &ScopeCoder{
            oc: oc,
        }
    }

    fn range_index_iter(mut &self, mut &it: &RangeIter) {
        let begin = IdentCoder.iter_begin(uintptr(it))
        let next = IdentCoder.iter_next(uintptr(it))

        self.oc.write("{\n")
        self.oc.add_indent()
        self.oc.indent()
        self.oc.write("auto ")
        if opt::COPY && is_copy_optimizable(it.expr) {
            self.oc.write("&")
        }
        self.oc.write("expr = ")
        self.oc.ec.model(it.expr.model)
        self.oc.write(";\n")
        self.oc.indent()
        self.oc.write("auto it = expr.begin();\n")
        self.oc.indent()
        self.oc.write(begin)
        self.oc.write(":;\n")
        self.oc.indent()
        self.oc.write("if (it != expr.end()) {\n")
        self.oc.add_indent()
        self.oc.indent()
        if it.key_a != nil {
            self.oc.var_init_expr(it.key_a, fn() { self.oc.write("it - expr.begin()") })
            self.oc.write("\n")
            self.oc.indent()
        }
        if it.key_b != nil {
            if opt::COPY {
                it.key_b.reference = is_iter_copy_optimizable(it.expr, it.key_b)
            }
            self.oc.var_init_expr(it.key_b, fn() { self.oc.write("*it") })
            self.oc.write("\n")
            self.oc.indent()
        }
        self.scope(it.scope)
        self.oc.write("\n")
        self.oc.indent()
        self.oc.write(next)
        self.oc.write(":;\n")
        self.oc.indent()
        self.oc.write("++it;\n")
        self.oc.indent()
        if it.key_a != nil {
            self.oc.write(IdentCoder.var(it.key_a))
            self.oc.write("++;\n")
            self.oc.indent()
        }
        self.oc.write("goto ")
        self.oc.write(begin)
        self.oc.write(";\n")

        // Close if.
        self.oc.done_indent()
        self.oc.indent()
        self.oc.write("}\n")

        self.oc.indent()
        self.oc.write(IdentCoder.iter_end(uintptr(it)))
        self.oc.write(":;\n")

        // Close scope.
        self.oc.done_indent()
        self.oc.indent()
        self.oc.write("}")
    }

    fn range_hashmap_iter(mut &self, mut &it: &RangeIter) {
        let begin = IdentCoder.iter_begin(uintptr(it))
        let next = IdentCoder.iter_next(uintptr(it))

        self.oc.write("{\n")
        self.oc.add_indent()
        self.oc.indent()
        self.oc.write("auto ")
        if opt::COPY && is_copy_optimizable(it.expr) {
            self.oc.write("&")
        }
        self.oc.write("expr = ")
        self.oc.ec.model(it.expr.model)
        self.oc.write(";\n")
        self.oc.indent()
        self.oc.write("auto it = expr.begin();\n")
        self.oc.indent()
        self.oc.write(begin)
        self.oc.write(":;\n")
        self.oc.indent()
        self.oc.write("if (it != expr.end()) {\n")
        self.oc.add_indent()
        self.oc.indent()
        if it.key_a != nil {
            if opt::COPY {
                it.key_a.reference = is_iter_copy_optimizable(it.expr, it.key_a)
            }
            self.oc.var_init_expr(it.key_a, fn() { self.oc.write("it->first") })
            self.oc.write("\n")
            self.oc.indent()
        }
        if it.key_b != nil {
            if opt::COPY {
                it.key_b.reference = is_iter_copy_optimizable(it.expr, it.key_b)
            }
            self.oc.var_init_expr(it.key_b, fn() { self.oc.write("it->second") })
            self.oc.write("\n")
            self.oc.indent()
        }
        self.scope(it.scope)
        self.oc.write("\n")
        self.oc.indent()
        self.oc.write(next)
        self.oc.write(":;\n")
        self.oc.indent()
        self.oc.write("++it;\n")
        self.oc.indent()
        self.oc.write("goto ")
        self.oc.write(begin)
        self.oc.write(";\n")

        // Close if.
        self.oc.done_indent()
        self.oc.indent()
        self.oc.write("}\n")

        self.oc.indent()
        self.oc.write(IdentCoder.iter_end(uintptr(it)))
        self.oc.write(":;\n")

        // Close scope.
        self.oc.done_indent()
        self.oc.indent()
        self.oc.write("}")
    }

    fn if_case(mut &self, mut i: &If) {
        if i.expr != nil {
            self.oc.write("if (")
            self.oc.ec.expr(i.expr)
            self.oc.write(") ")
        }
        self.scope(i.scope)
    }

    fn conditional(mut &self, mut c: &Conditional) {
        let mut writed = false
        for (_, mut elif) in c.elifs {
            if elif == nil {
                continue
            }
            if writed {
                self.oc.write(" else ")
            }
            writed = true
            self.if_case(elif)
        }
        if c.default != nil {
            if writed {
                self.oc.write(" else ")
            }
            self.scope(c.default.scope)
        }
    }

    fn inf_iter(mut &self, mut it: &InfIter) {
        self.oc.write("for (;;) {\n")
        self.oc.add_indent() // Indent scope.
        self.oc.indent()
        self.scope(it.scope)
        self.oc.done_indent()
        self.oc.write("\n")
        self.oc.indent()
        self.oc.write(IdentCoder.iter_next(uintptr(it)))
        self.oc.write(":;\n")
        self.oc.indent()
        self.oc.write("}\n")
        self.oc.indent()
        self.oc.write(IdentCoder.iter_end(uintptr(it)))
        self.oc.write(":;")
    }

    fn while_iter(mut &self, mut it: &WhileIter) {
        if it.expr != nil && it.next == nil {
            self.oc.write("while (")
            self.oc.ec.expr(it.expr)
            self.oc.write(") {\n")
        } else {
            self.oc.write("for (; ")
            if it.expr != nil {
                self.oc.ec.expr(it.expr)
            }
            self.oc.write("; ")
            if it.next != nil {
                self.st(it.next)
            }
            self.oc.write(") {\n")
        }

        self.oc.add_indent()
        self.oc.indent()
        self.scope(it.scope)
        self.oc.write("\n")
        self.oc.done_indent()
        self.oc.indent()

        self.oc.write(IdentCoder.iter_next(uintptr(it)))
        self.oc.write(":;\n")
        self.oc.indent()
        self.oc.write("}\n")
        self.oc.indent()
        self.oc.write(IdentCoder.iter_end(uintptr(it)))
        self.oc.write(":;")
    }

    fn range_iter(mut &self, mut it: &RangeIter) {
        match {
        | it.expr.kind.slc() != nil:
            self.range_index_iter(it)
        | it.expr.kind.arr() != nil:
            self.range_index_iter(it)
        | it.expr.kind.map() != nil:
            self.range_hashmap_iter(it)
        |:
            self.range_index_iter(it) // Str
        }
    }

    fn cont(mut &self, c: &ContSt) {
        self.oc.write("goto ")
        self.oc.write(IdentCoder.iter_next(c.it))
    }

    fn label(mut &self, l: &Label) {
        self.oc.write(IdentCoder.label(l.ident))
        self.oc.write(":")
    }

    fn goto_st(mut &self, gt: &GotoSt) {
        self.oc.write("goto ")
        self.oc.write(IdentCoder.label(gt.ident))
    }

    fn postfix(mut &self, mut p: &Postfix) {
        self.oc.write("(")
        self.oc.ec.expr(p.expr)
        self.oc.write(")")
        self.oc.write(p.op)
    }

    fn assign(mut &self, mut a: &Assign) {
        self.oc.ec.expr(a.l.model)
        self.oc.write(a.op.kind)
        self.oc.ec.expr(a.r.model)
    }

    fn multi_assign(mut &self, mut a: &MultiAssign) {
        self.oc.write("std::tie(")
        for (i, mut l) in a.l {
            if l == nil {
                self.oc.write(CPP_IGNORE)
            } else {
                self.oc.ec.expr(l)
            }
            if a.l.len-i > 1 {
                self.oc.write(",")
            }
        }
        self.oc.write(") = ")
        self.oc.ec.expr(a.r)
    }

    fn match_expr(mut &self, mut m: &Match): fn() {
        if !m.expr.is_const() {
            ret fn() { self.oc.write(MATCH_EXPR) }
        }
        if !m.expr.constant.is_bool() || !m.expr.constant.read_bool() {
            ret fn() { self.oc.ec.model(m.expr.model) }
        }
        ret nil
    }

    fn case(mut &self, mut m: &Match, mut c: &Case) {
        if c.exprs.len != 0 && !m.is_generic_type_match() {
            if m.cases.len > 0 && m.cases[0] == c {
                self.oc.write("if (")
            } else {
                self.oc.write("else if (")
            }
            for (i, mut expr) in c.exprs {
                match {
                | !m.type_match:
                    let case_expr = self.match_expr(m)
                    if m.expr.good_operand(expr) {
                        if case_expr != nil {
                            case_expr()
                            self.oc.write(" == ")
                        }
                        self.oc.ec.expr(expr.model)
                    } else {
                        self.oc.ec.expr(expr.model)
                        if case_expr != nil {
                            self.oc.write(" == ")
                            case_expr()
                        }
                    }
                |:
                    self.oc.write(MATCH_EXPR)
                    self.oc.write(".type_is<")
                    self.oc.ec.expr(expr.model)
                    self.oc.write(">()")
                }

                if c.exprs.len-i > 1 {
                    self.oc.write(" || ")
                }
            }
            self.oc.write(") ")
        } else if m.default == c && m.cases.len != 0 {
            self.oc.indent()
            self.oc.write("else ")
        }

        self.oc.add_indent()

        self.oc.write("{\n")
        self.oc.indent()
        self.oc.write(IdentCoder.case_begin(uintptr(c)))
        self.oc.write(":;\n")
        if c.scope.stmts.len > 0 {
            self.oc.indent()
            self.scope(c.scope)
            self.oc.write("\n")
        }

        self.oc.done_indent()

        self.oc.indent()
        self.oc.write("}")
    }

    fn match_st(mut &self, mut m: &Match) {
        if m.cases.len == 0 && m.default == nil {
            ret
        }

        let generic_type_match = m.is_generic_type_match()
        if generic_type_match && (m.default == nil || m.default.scope.stmts.len == 0) {
            ret
        }

        self.oc.write("{\n")

        self.oc.add_indent()

        self.oc.indent()

        // Constant expressions generated as literals in conditions.
        if !generic_type_match && !m.expr.is_const() {
            if opt::COPY && is_copy_optimizable(m.expr) {
                self.oc.write("auto &_match_expr{ ")
            } else {
                self.oc.write("auto _match_expr{ ")
            }
            self.oc.ec.expr(m.expr.model)
            self.oc.write(" };\n")
            self.oc.indent()
        }

        if m.cases.len > 0 {
            for (_, mut c) in m.cases {
                if c == nil {
                    continue
                }
                self.oc.write("\n")
                self.oc.indent()
                self.case(m, c)
            }
        }

        if m.default != nil {
            self.oc.write("\n")
            self.case(m, m.default)
        }

        self.oc.write("\n")
        self.oc.indent()
        self.oc.write(IdentCoder.match_end(uintptr(m)))
        self.oc.write(":;")
        self.oc.write("\n")

        self.oc.done_indent()

        self.oc.indent()
        self.oc.write("}")
    }

    fn fall_st(mut &self, f: &FallSt) {
        self.oc.write("goto ")
        self.oc.write(IdentCoder.case_begin(f.dest_case))
    }

    fn break_st(mut &self, b: &BreakSt) {
        self.oc.write("goto ")
        if b.it != 0 {
            self.oc.write(IdentCoder.iter_end(b.it))
        } else {
            self.oc.write(IdentCoder.match_end(b.mtch))
        }
    }

    fn ret_with_vars(mut &self, mut r: &RetSt) {
        self.oc.write("return ")
        if r.func.decl.exceptional {
            self.oc.write("jule::Exceptional<")
            self.oc.write(TypeCoder.kind(r.func.result))
            self.oc.write(">(jule::Any(), ")
        }
        if r.vars.len > 1 {
            self.oc.write("std::make_tuple(")
        }
        for (i, mut v) in r.vars {
            if lex::is_ignore_ident(v.ident) {
                self.oc.ec.init_expr(v.kind.kind)
            } else {
                self.oc.write(IdentCoder.var(v))
            }
            if r.vars.len-i > 1 {
                self.oc.write(",")
            }
        }

        if r.vars.len > 1 {
            self.oc.write(")")
        }

        if r.func.decl.exceptional {
            self.oc.write(")")
        }
    }

    fn ret_tuple(mut &self, mut r: &RetSt) {
        let mut datas = (&TupleExprModel)(r.expr).datas
        for (i, mut v) in r.vars {
            if lex::is_ignore_ident(v.ident) {
                continue
            }
            let mut model = datas[i].model
            // Ignore self assignment.
            if model == v {
                continue
            }
            self.oc.write(IdentCoder.var(v))
            self.oc.write(" = ")
            self.oc.ec.expr(model)
            self.oc.write(";\n")
            self.oc.indent()
        }

        if r.func.decl.exceptional {
            self.oc.write("return jule::Exceptional<")
            self.oc.write(TypeCoder.kind(r.func.result))
            self.oc.write(">(jule::Any(),")
        } else {
            self.oc.write("return ")
        }

        self.oc.write("std::make_tuple(")
        for (i, mut d) in datas {
            let mut v = r.vars[i]
            if lex::is_ignore_ident(v.ident) {
                self.oc.ec.expr(d.model)
            } else {
                self.oc.write(IdentCoder.var(v))
            }
            if datas.len-i > 1 {
                self.oc.write(",")
            }
        }
        self.oc.write(")")

        if r.func.decl.exceptional {
            self.oc.write(")")
        }
    }

    fn ret_with_exprs(mut &self, mut r: &RetSt) {
        if r.vars.len > 1 {
            self.ret_tuple(r)
            ret
        }

        // Ignore self assignments and ignored variables.
        if r.vars.len > 0 {
            let mut v = r.vars[0]
            if !lex::is_ignore_ident(v.ident) && r.expr != v {
                let ident = IdentCoder.var(v)
                self.oc.write(ident)
                self.oc.write(" = ")
                self.oc.ec.expr(r.expr)
                self.oc.write(";\n")
                self.oc.indent()
                if r.func.decl.exceptional {
                    self.oc.write("return jule::Exceptional<")
                    self.oc.write(TypeCoder.kind(r.func.result))
                    self.oc.write(">(jule::Any(),")
                    self.oc.write(ident)
                    self.oc.write(")")
                } else {
                    self.oc.write("return ")
                    self.oc.write(ident)
                }
                ret
            }
        }

        if r.func.decl.exceptional {
            self.oc.write("return jule::Exceptional<")
            self.oc.write(TypeCoder.kind(r.func.result))
            self.oc.write(">(jule::Any(),")
            self.oc.ec.expr(r.expr)
            self.oc.write(")")
            ret
        }

        self.oc.write("return ")
        self.oc.ec.expr(r.expr)
        ret
    }

    fn ret_st(mut &self, mut r: &RetSt) {
        // Void.
        if r.expr == nil && r.vars.len == 0 {
            if r.func.decl.exceptional {
                self.oc.write("return jule::VoidExceptional();")
                ret
            }
            self.oc.write("return;")
            ret
        }

        if r.expr == nil {
            self.ret_with_vars(r)
            ret
        }
        self.ret_with_exprs(r)
    }

    fn ret_with_defaults(mut &self, mut result: &TypeKind) {
        self.oc.write("return ")
        if result.tup() != nil {
            self.oc.write("std::make_tuple(")
            let mut types = result.tup().types
            for (i, mut t) in types {
                self.oc.ec.init_expr(t)
                if types.len-i > 1 {
                    self.oc.write(",")
                }
            }
            self.oc.write(")")
        } else {
            self.oc.ec.init_expr(result)
        }
    }

    fn var(mut &self, mut v: &Var) {
        if !v.constant {
            self.oc.var(v)
        }
    }

    // Generates C++ code of statement.
    fn st(mut &self, mut st: any) {
        if st == nil {
            ret
        }
        match type st {
        | &Scope:
            self.scope((&Scope)(st))
        | &Var:
            self.var((&Var)(st))
        | &Data:
            self.oc.ec.expr((&Data)(st))
        | &Conditional:
            self.conditional((&Conditional)(st))
        | &InfIter:
            self.inf_iter((&InfIter)(st))
        | &WhileIter:
            self.while_iter((&WhileIter)(st))
        | &RangeIter:
            self.range_iter((&RangeIter)(st))
        | &ContSt:
            self.cont((&ContSt)(st))
        | &Label:
            self.label((&Label)(st))
        | &GotoSt:
            self.goto_st((&GotoSt)(st))
        | &Postfix:
            self.postfix((&Postfix)(st))
        | &Assign:
            self.assign((&Assign)(st))
        | &MultiAssign:
            self.multi_assign((&MultiAssign)(st))
        | &Match:
            self.match_st((&Match)(st))
        | &FallSt:
            self.fall_st((&FallSt)(st))
        | &BreakSt:
            self.break_st((&BreakSt)(st))
        | &RetSt:
            self.ret_st((&RetSt)(st))
        | &PushToSliceExprModel:
            self.oc.ec.push_to_slice((&PushToSliceExprModel)(st))
        | &MutSlicingExprModel:
            self.oc.ec.mut_slicing((&MutSlicingExprModel)(st))
        | &StrInsertBeginExprModel:
            self.oc.ec.str_insert_begin((&StrInsertBeginExprModel)(st))
        |:
            self.oc.write("<unimplemented_stmt>")
        }
    }

    fn scope_stmts(mut &self, mut &s: &Scope) {
        for (_, mut st) in s.stmts {
            self.oc.indent()
            self.st(st)
            self.oc.write(";\n")
        }
    }

    // Generates C++ code of scope.
    fn scope(mut &self, mut s: &Scope) {
        self.oc.add_indent()
        if s.deferred {
            self.oc.write("__JULE_DEFER(")
        }
        self.oc.write("{\n")
        self.scope_stmts(s)
        self.oc.done_indent()
        self.oc.indent()
        self.oc.write("}")
        if s.deferred {
            self.oc.write(");")
        }
    }

    // Generates C++ code of function's scope.
    fn func_scope(mut &self, mut f: &FnIns) {
        if f.scope == nil {
            ret
        }
        self.oc.write("{\n")
        self.oc.add_indent()
        if !f.decl.is_void() {
            let mut types = f.types()
            for i, ident in f.decl.result.idents {
                if lex::is_ignore_ident(ident.kind) ||
                    lex::is_anon_ident(ident.kind) {
                    continue
                }
                self.oc.indent()
                self.oc.write(TypeCoder.kind(types[i]))
                self.oc.write(" ")
                self.oc.write(IdentCoder.to_local(ident.row, ident.column, ident.kind))
                self.oc.write(" = ")
                self.oc.ec.init_expr(types[i])
                self.oc.write(";\n")
            }
        }
        self.scope_stmts(f.scope)
        if f.decl.exceptional && f.decl.is_void() {
            // Just for void exceptionals.
            // Other cases checked by semantic analsis and disallowed
            // if they are not returns.
            self.oc.write(" return jule::VoidExceptional();\n")
        }
        self.oc.done_indent()
        self.oc.indent()
        self.oc.write("}")
    }
}

fn is_copy_optimizable(&expr: &Data): bool {
    if !expr.lvalue {
        ret false
    }
    match type expr.model {
    | &SlicingExprModel:
        ret false
    }
    ret true
}

fn is_iter_copy_optimizable(&expr: &Data, &v: &Var): bool {
    if !expr.lvalue && !expr.kind.mutable() {
        ret true
    }
    ret !v.mutable && !expr.mutable
}