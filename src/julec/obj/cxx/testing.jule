// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

/*

use std::jule::sema::{
    ImportInfo,
}

struct TestCoder {
    objc: &ObjectCoder
}

impl TestCoder {
    static fn new(mut &objc: &ObjectCoder): &TestCoder {
        ret &TestCoder{
            objc: objc,
        }
    }

    fn find_testing_package(mut self): &ImportInfo {
        for (_, mut imp) in self.ir.used {
            if imp.link_path == "std::testing" {
                ret imp
            }
        }
        ret nil
    }

    fn append_test(mut self, mut &obj: str, mut f: &FnIns) {
        obj += self.objc.indent()
        obj += "_t->_method_reset();\n"
        obj += self.objc.indent()
        obj += "std::cout << \">>> TEST RUNNING: \";\n"
        obj += self.objc.indent()
        obj += "jule::outln("
        obj += get_cstr_model([]byte(f.decl.ident))
        obj += ");\n"
        obj += self.objc.indent()
        obj += IdentCoder.from_fn_ins(f)
        obj += "(_t);\n"
        obj += self.objc.indent()
        obj += "post_test();\n"
    }
}

/*

pub fn append_package_tests(mut &obj: str, mut &p: &Package) {
    for (_, mut file) in p.files {
        for (_, mut f) in file.funcs {
            if has_directive(f.directives, Directive.Test) {
                append_test(obj, f.instances[0])
            }
        }
    }
}

pub fn append_test_point(mut &obj: str, mut &ir: &IR) {
    obj += "\nvoid test_point(void) {\n"
    add_indent()
    obj += indent()

    let mut p = find_testing_package(ir)
    if p == nil {
        // std::testing is not used.
        // So, developers cannot write valid test function.
        // Append empty test point and return.
        obj += "}"
        done_indent()
        ret
    }

    let mut t = p.find_struct("T", false).instances[0]

    obj += as_sptr_kind(gen_struct_kind_ins(t))
    obj += " _t = jule::new_struct<"
    obj += gen_struct_kind_ins(t)
    obj += ">("
    if !env::PRODUCTION {
        obj += `"/jule/init", `
    }
    obj += "new(std::nothrow) "
    obj += gen_struct_kind_ins(t)
    obj += ");\n"

    obj += indent()
    obj += "jule::Uint total = 0, failed = 0, skipped = 0;\n"
    obj += indent()

    obj += "auto post_test = [&](void) {\n"
    add_indent()
    obj += indent()
    obj += "++total;\n"
    obj += indent()
    obj += "if (_t->_method_failed()) { ++failed; std::cout << \"    [*] FAILED\" << std::endl; }\n"
    obj += indent()
    obj += "else if (_t->_method_skipped()) { ++skipped; std::cout << \"    [*] SKIPPED\" << std::endl; }\n"
    obj += indent()
    obj += "else { std::cout << \"    [*] PASSED\" << std::endl; }\n"
    done_indent()
    obj += indent()
    obj += "};\n"

    append_package_tests(obj, ir.main)

    obj += "\n\n"
    obj += indent()
    obj += "std::cout << std::endl << std::endl << \"total tests: \" << total << \" skipped: \" << skipped << \" failed: \" << failed << \" pass: \" << total-failed-skipped << std::endl;\n"

    done_indent()
    obj += indent()
    obj += "}\n"
}
*/
