// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/jule/constant"
use "std/jule/sema"

struct anyData {
	dataPtr: &uint
	typePtr: *unsafe
}

// Returns data pointer address in uintptr of Expr.
fn TypeData(&m: sema::Expr): uintptr {
	ret uintptr(unsafe { (*anyData)(&m).typePtr })
}

fn equalConst(l: &constant::Const, r: &constant::Const): bool {
	match {
	| l.IsI64():
		ret r.IsI64() && l.ReadI64() == r.ReadI64()
	| l.IsU64():
		ret r.IsU64() && l.ReadU64() == r.ReadU64()
	| l.IsF64():
		ret r.IsF64() && l.ReadF64() == r.ReadF64()
	| l.IsStr():
		ret r.IsStr() && l.ReadStr() == r.ReadStr()
	| l.IsBool():
		ret r.IsBool() && l.ReadBool() == r.ReadBool()
	| l.IsNil():
		ret r.IsNil()
	|:
		ret false
	}
}

fn equalCasting(l: &sema::CastingExpr, r: &sema::CastingExpr): bool {
	if !l.Type.Equal(r.Type) {
		ret false
	}
	ret EqualModels(l.Expr.Model, r.Expr.Model)
}

fn equalUnary(l: &sema::UnaryExpr, r: &sema::UnaryExpr): bool {
	if l.Op.Id != r.Op.Id || l.Op.Kind != r.Op.Kind {
		ret false
	}
	ret EqualModels(l.Expr.Model, r.Expr.Model)
}

fn equalIndexing(l: &sema::IndexingExpr, r: &sema::IndexingExpr): bool {
	ret EqualModels(l.Expr.Model, r.Expr.Model) &&
		EqualModels(l.Index.Model, r.Index.Model)
}

fn equalBinary(l: &sema::BinaryExpr, r: &sema::BinaryExpr): bool {
	if l.Op.Id != r.Op.Id || l.Op.Kind != r.Op.Kind {
		ret false
	}
	ret EqualModels(l.Left.Model, r.Left.Model) &&
		EqualModels(l.Right.Model, r.Right.Model)
}

// Reports whether expressions are equal.
// Designed lvalue equality comparison oriented,
// such as swap statement value comparisons.
fn EqualModels(l: sema::Expr, r: sema::Expr): bool {
	if TypeData(l) != TypeData(r) {
		ret false
	}
	match type l {
	| &sema::Var:
		ret (&sema::Var)(l) == (&sema::Var)(r)
	| &sema::StructSubIdentExpr:
		li := (&sema::StructSubIdentExpr)(l)
		ri := (&sema::StructSubIdentExpr)(r)
		ret li.Field == ri.Field && EqualModels(li.Expr.Model, ri.Expr.Model)
	| &constant::Const:
		ret equalConst((&constant::Const)(l), (&constant::Const)(r))
	| &sema::CastingExpr:
		ret equalCasting((&sema::CastingExpr)(l), (&sema::CastingExpr)(r))
	| &sema::UnaryExpr:
		ret equalUnary((&sema::UnaryExpr)(l), (&sema::UnaryExpr)(r))
	| &sema::IndexingExpr:
		ret equalIndexing((&sema::IndexingExpr)(l), (&sema::IndexingExpr)(r))
	| &sema::BinaryExpr:
		ret equalBinary((&sema::BinaryExpr)(l), (&sema::BinaryExpr)(r))
	|:
		ret false
	}
}