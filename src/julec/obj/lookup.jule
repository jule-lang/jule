// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use comptime for std::comptime
use ast for std::jule::ast
use lex for std::jule::lex
use sema for std::jule::sema

// Returns directive if exist.
fn FindDirective(mut &directives: []&ast::Directive, tag: str): &ast::Directive {
	for (_, mut dr) in directives {
		if dr.Tag.Kind == tag {
			ret dr
		}
	}
	ret nil
}

// Reports whether directive is exist.
fn HasDirective(&directives: []&ast::Directive, tag: str): bool {
	ret FindDirective(unsafe { *(&directives) }, tag) != nil
}

// Reports whether trait have method in this identifier.
fn ContainsTraitMethod(mut &t: &sema::Trait, &ident: str): bool {
	for _, m in t.Methods {
		if m.Ident == ident {
			ret true
		}
	}
	ret false
}

// Data offset of empty trait.
const emptyTraitOffset = 0

// Returns index of structu ins by trait implements.
fn FindTraitTypeOffsetS(t: &sema::Trait, mut s: &sema::StructIns): int {
	if len(t.Implemented) == 0 {
		ret emptyTraitOffset
	}
	mut i := 0
	for _, si in t.Implemented {
		if s.Decl == si {
			for _, ins in si.Instances {
				if ins == s {
					ret i
				}
				i++
			}
			break
		} else {
			i += len(si.Instances)
		}
	}
	ret -1
}

// Same as [FindTraitTypeOffsetS] but designed for TypeKind based lookup.
// It checks structure instances even used with smart pointer.
fn FindTraitTypeOffset(t: &sema::Trait, mut k: &sema::TypeKind): int {
	if len(t.Implemented) == 0 {
		ret emptyTraitOffset
	}
	let mut s: &sema::StructIns = nil
	if k.Sptr() != nil {
		k = k.Sptr().Elem
	}
	s = k.Struct()
	if s == nil {
		ret -1
	}
	ret FindTraitTypeOffsetS(t, s)
}

// Returns overloaded operator method by operator id.
fn FindOperator(mut &s: &sema::StructIns, op: lex::TokenId, unary: bool): &sema::FnIns {
	match op {
	| lex::TokenId.Eqs:
		ret s.Operators.Eq
	| lex::TokenId.Gt:
		ret s.Operators.Gt
	| lex::TokenId.GtEq:
		ret s.Operators.GtEq
	| lex::TokenId.Lt:
		ret s.Operators.Lt
	| lex::TokenId.LtEq:
		ret s.Operators.LtEq
	| lex::TokenId.Shl:
		ret s.Operators.Shl
	| lex::TokenId.Shr:
		ret s.Operators.Shr
	| lex::TokenId.Plus:
		if unary {
			ret s.Operators.Pos
		}
		ret s.Operators.Add
	| lex::TokenId.Minus:
		if unary {
			ret s.Operators.Neg
		}
		ret s.Operators.Sub
	| lex::TokenId.Solidus:
		ret s.Operators.Div
	| lex::TokenId.Star:
		ret s.Operators.Mul
	| lex::TokenId.Percent:
		ret s.Operators.Mod
	| lex::TokenId.Amper:
		ret s.Operators.BitAnd
	| lex::TokenId.Vline:
		ret s.Operators.BitOr
	| lex::TokenId.Caret:
		if unary {
			ret s.Operators.BitNot
		}
		ret s.Operators.BitXor
	| lex::TokenId.PlusEq:
		ret s.Operators.AddAssign
	| lex::TokenId.MinusEq:
		ret s.Operators.SubAssign
	| lex::TokenId.SolidusEq:
		ret s.Operators.DivAssign
	| lex::TokenId.StarEq:
		ret s.Operators.MulAssign
	| lex::TokenId.PercentEq:
		ret s.Operators.ModAssign
	| lex::TokenId.ShlEq:
		ret s.Operators.ShlAssign
	| lex::TokenId.ShrEq:
		ret s.Operators.ShrAssign
	| lex::TokenId.VlineEq:
		ret s.Operators.BitOrAssign
	| lex::TokenId.AmperEq:
		ret s.Operators.BitAndAssign
	| lex::TokenId.CaretEq:
		ret s.Operators.BitXorAssign
	|:
		ret nil
	}
}

// Returns function instance by generics.
// Assumes generics parameter have enough and same size with generic count of f.
// Panics if not exist any instance.
fn FindFnGenericInstance(mut &f: &sema::Fn, generics: ...&sema::TypeKind): &sema::FnIns {
lookup:
	for (_, mut ins) in f.Instances {
		for i in ins.Generics {
			if !ins.Generics[i].Kind.Equal(generics[i]) {
				continue lookup
			}
		}
		ret ins
	}
	panic("generic instance lookup failed, this is an implementation mistake")
}

// Returns struct instance by generics.
// Assumes generics parameter have enough and same size with generic count of s.
// Panics if not exist any instance.
fn FindStructGenericInstance(mut &s: &sema::Struct, generics: ...&sema::TypeKind): &sema::StructIns {
lookup:
	for (_, mut ins) in s.Instances {
		for i in ins.Generics {
			if !ins.Generics[i].Kind.Equal(generics[i]) {
				continue lookup
			}
		}
		ret ins
	}
	panic("generic instance lookup failed, this is an implementation mistake")
}