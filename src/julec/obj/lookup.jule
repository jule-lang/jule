// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use ast for std::jule::ast
use std::jule::sema::{Trait, StructIns, TypeKind}

// Returns directive if exist.
fn FindDirective(mut &directives: []&ast::Directive, tag: str): &ast::Directive {
    for (_, mut dr) in directives {
        if dr.Tag.Kind == tag {
            ret dr
        }
    }
    ret nil
}

// Reports whether directive is exist.
fn HasDirective(&directives: []&ast::Directive, tag: str): bool {
    ret FindDirective(unsafe { *(&directives) }, tag) != nil
}

// Reports whether trait have method in this identifier.
fn ContainsTraitMethod(mut &t: &Trait, &ident: str): bool {
    for _, m in t.Methods {
        if m.Ident == ident {
            ret true
        }
    }
    ret false
}

// Data offset of empty trait.
const emptyTraitOffset = 0

// Returns index of structu ins by trait implements.
fn FindTraitTypeOffsetS(t: &Trait, mut s: &StructIns): int {
    if len(t.Implemented) == 0 {
        ret emptyTraitOffset
    }
    mut i := 0
    for _, si in t.Implemented {
        if s.Decl == si {
            for _, ins in si.Instances {
                if ins == s {
                    ret i
                }
                i++
            }
            break
        } else {
            i += len(si.Instances)
        }
    }
    ret -1
}

// Same as [FindTraitTypeOffsetS] but designed for TypeKind based lookup.
// It checks structure instances even used with smart pointer.
fn FindTraitTypeOffset(t: &Trait, mut k: &TypeKind): int {
    if len(t.Implemented) == 0 {
        ret emptyTraitOffset
    }
    let mut s: &StructIns = nil
    if k.Sptr() != nil {
        k = k.Sptr().Elem
    }
    s = k.Struct()
    if s == nil {
        ret -1
    }
    ret FindTraitTypeOffsetS(t, s)
}