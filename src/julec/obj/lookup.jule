// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use comptime for std::comptime
use ast for std::jule::ast
use std::jule::lex::{TokenId}
use std::jule::sema::{Trait, StructIns, TypeKind, Fn, FnIns}

// Returns directive if exist.
fn FindDirective(mut &directives: []&ast::Directive, tag: str): &ast::Directive {
	for (_, mut dr) in directives {
		if dr.Tag.Kind == tag {
			ret dr
		}
	}
	ret nil
}

// Reports whether directive is exist.
fn HasDirective(&directives: []&ast::Directive, tag: str): bool {
	ret FindDirective(unsafe { *(&directives) }, tag) != nil
}

// Reports whether trait have method in this identifier.
fn ContainsTraitMethod(mut &t: &Trait, &ident: str): bool {
	for _, m in t.Methods {
		if m.Ident == ident {
			ret true
		}
	}
	ret false
}

// Data offset of empty trait.
const emptyTraitOffset = 0

// Returns index of structu ins by trait implements.
fn FindTraitTypeOffsetS(t: &Trait, mut s: &StructIns): int {
	if len(t.Implemented) == 0 {
		ret emptyTraitOffset
	}
	mut i := 0
	for _, si in t.Implemented {
		if s.Decl == si {
			for _, ins in si.Instances {
				if ins == s {
					ret i
				}
				i++
			}
			break
		} else {
			i += len(si.Instances)
		}
	}
	ret -1
}

// Same as [FindTraitTypeOffsetS] but designed for TypeKind based lookup.
// It checks structure instances even used with smart pointer.
fn FindTraitTypeOffset(t: &Trait, mut k: &TypeKind): int {
	if len(t.Implemented) == 0 {
		ret emptyTraitOffset
	}
	let mut s: &StructIns = nil
	if k.Sptr() != nil {
		k = k.Sptr().Elem
	}
	s = k.Struct()
	if s == nil {
		ret -1
	}
	ret FindTraitTypeOffsetS(t, s)
}

// Returns overloaded operator method by operator id.
fn FindOperator(mut &s: &StructIns, op: TokenId, unary: bool): &FnIns {
	match op {
	| TokenId.Eqs:
		ret s.Operators.Eq
	| TokenId.Gt:
		ret s.Operators.Gt
	| TokenId.GtEq:
		ret s.Operators.GtEq
	| TokenId.Lt:
		ret s.Operators.Lt
	| TokenId.LtEq:
		ret s.Operators.LtEq
	| TokenId.Shl:
		ret s.Operators.Shl
	| TokenId.Shr:
		ret s.Operators.Shr
	| TokenId.Plus:
		if unary {
			ret s.Operators.Pos
		}
		ret s.Operators.Add
	| TokenId.Minus:
		if unary {
			ret s.Operators.Neg
		}
		ret s.Operators.Sub
	| TokenId.Solidus:
		ret s.Operators.Div
	| TokenId.Star:
		ret s.Operators.Mul
	| TokenId.Percent:
		ret s.Operators.Mod
	| TokenId.Amper:
		ret s.Operators.BitAnd
	| TokenId.Vline:
		ret s.Operators.BitOr
	| TokenId.Caret:
		if unary {
			ret s.Operators.BitNot
		}
		ret s.Operators.BitXor
	| TokenId.PlusEq:
		ret s.Operators.AddAssign
	| TokenId.MinusEq:
		ret s.Operators.SubAssign
	| TokenId.SolidusEq:
		ret s.Operators.DivAssign
	| TokenId.StarEq:
		ret s.Operators.MulAssign
	| TokenId.PercentEq:
		ret s.Operators.ModAssign
	| TokenId.ShlEq:
		ret s.Operators.ShlAssign
	| TokenId.ShrEq:
		ret s.Operators.ShrAssign
	| TokenId.VlineEq:
		ret s.Operators.BitOrAssign
	| TokenId.AmperEq:
		ret s.Operators.BitAndAssign
	| TokenId.CaretEq:
		ret s.Operators.BitXorAssign
	|:
		ret nil
	}
}

// Returns function instance by generics.
// Assumes generics parameter have enough and same size with generic count of f.
// Panics if not exist any instance.
fn FindGenericInstance(mut &f: &Fn, generics: ...&TypeKind): &FnIns {
lookup:
	for (_, mut ins) in f.Instances {
		for i in ins.Generics {
			if !ins.Generics[i].Kind.Equal(generics[i]) {
				continue lookup
			}
		}
		ret ins
	}
	panic("generic instance lookup failed, this is an implementation mistake")
}