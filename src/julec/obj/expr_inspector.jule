// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::jule::sema::{
	Data,
	ExprModel,
	BinaryExprModel,
	OperandExprModel,
	UnaryExprModel,
	StructLitExprModel,
	AllocStructLitExprModel,
	CastingExprModel,
	FnCallExprModel,
	SliceExprModel,
	ArrayExprModel,
	IndexingExprModel,
	AnonFnExprModel,
	MapExprModel,
	SlicingExprModel,
	TraitSubIdentExprModel,
	StructSubIdentExprModel,
	TupleExprModel,
	BuiltinNewCallExprModel,
	BuiltinOutCallExprModel,
	BuiltinOutlnCallExprModel,
	BuiltinPanicCallExprModel,
	BuiltinAssertCallExprModel,
	BuiltinErrorCallExprModel,
	BuiltinMakeCallExprModel,
	BuiltinAppendCallExprModel,
	BuiltinLenCallExprModel,
	BuiltinCapCallExprModel,
	BuiltinDeleteCallExprModel,
	SizeofExprModel,
	AlignofExprModel,
	IntegratedToStrExprModel,
	FreeExprModel,
	BackendEmitExprModel,
}

// Expression model inspector.
struct ExprInspector {
	// If it is true, skips child expression models of current handled model if exist.
	// For exmaple, after handling binary expression, walker skips left and right operands.
	SkipChild: bool

	handler: fn(mut &m: ExprModel)
}

impl ExprInspector {
	// Returns new inspector.
	static fn New(): &ExprInspector {
		ret new(ExprInspector)
	}

	fn args(mut self, mut args: []ExprModel) {
		for (_, mut arg) in args {
			self.inspect(arg)
		}
	}

	fn inspect(mut self, mut &m: ExprModel) {
		self.SkipChild = false
		self.handler(m)
		if self.SkipChild {
			ret
		}
		match type m {
		| &BinaryExprModel:
			mut b := (&BinaryExprModel)(m)
			self.inspect(b.Left.Model)
			self.inspect(b.Right.Model)
		| &UnaryExprModel:
			mut u := (&UnaryExprModel)(m)
			self.inspect(u.Expr.Model)
		| &StructLitExprModel:
			mut lit := (&StructLitExprModel)(m)
			for (_, mut arg) in lit.Args {
				self.inspect(arg.Expr.Model)
			}
		| &AllocStructLitExprModel:
			mut lit := (&AllocStructLitExprModel)(m).Lit
			for (_, mut arg) in lit.Args {
				self.inspect(arg.Expr.Model)
			}
		| &CastingExprModel:
			mut c := (&CastingExprModel)(m)
			self.inspect(c.Expr.Model)
		| &FnCallExprModel:
			mut fc := (&FnCallExprModel)(m)
			self.inspect(fc.Expr)
			self.args(fc.Args)
		| &SliceExprModel:
			mut s := (&SliceExprModel)(m)
			self.args(s.Elems)
		| &ArrayExprModel:
			mut a := (&ArrayExprModel)(m)
			self.args(a.Elems)
		| &IndexingExprModel:
			mut i := (&IndexingExprModel)(m)
			self.inspect(i.Expr.Model)
			self.inspect(i.Index.Model)
		| &MapExprModel:
			mut mp := (&MapExprModel)(m)
			for (_, mut entry) in mp.Entries {
				self.inspect(entry.Key)
				self.inspect(entry.Val)
			}
		| &SlicingExprModel:
			mut s := (&SlicingExprModel)(m)
			self.inspect(s.Expr)
			self.inspect(s.Left)
			if s.Right != nil {
				self.inspect(s.Right)
			}
		| &TraitSubIdentExprModel:
			mut t := (&TraitSubIdentExprModel)(m)
			self.inspect(t.Expr.Model)
		| &StructSubIdentExprModel:
			mut s := (&StructSubIdentExprModel)(m)
			self.inspect(s.Expr.Model)
		| &TupleExprModel:
			mut t := (&TupleExprModel)(m)
			for (_, mut d) in t.Datas {
				self.inspect(d.Model)
			}
		| &BuiltinNewCallExprModel:
			mut b := (&BuiltinNewCallExprModel)(m)
			if b.Init != nil {
				self.inspect(b.Init)
			}
		| &BuiltinOutCallExprModel:
			mut c := (&BuiltinOutCallExprModel)(m)
			self.inspect(c.Expr)
		| &BuiltinOutlnCallExprModel:
			mut c := (&BuiltinOutlnCallExprModel)(m)
			self.inspect(c.Expr)
		| &BuiltinPanicCallExprModel:
			mut c := (&BuiltinPanicCallExprModel)(m)
			self.inspect(c.Expr)
		| &BuiltinAssertCallExprModel:
			mut c := (&BuiltinAssertCallExprModel)(m)
			self.inspect(c.Expr)
		| &BuiltinErrorCallExprModel:
			mut c := (&BuiltinErrorCallExprModel)(m)
			self.inspect(c.Err.Model)
		| &BuiltinMakeCallExprModel:
			mut b := (&BuiltinMakeCallExprModel)(m)
			if b.Len != nil {
				self.inspect(b.Len)
			}
			if b.Cap != nil {
				self.inspect(b.Cap)
			}
		| &BuiltinAppendCallExprModel:
			mut b := (&BuiltinAppendCallExprModel)(m)
			self.inspect(b.Dest)
			self.inspect(b.Elements)
		| &BuiltinLenCallExprModel:
			mut l := (&BuiltinLenCallExprModel)(m)
			self.inspect(l.Expr.Model)
		| &BuiltinCapCallExprModel:
			mut c := (&BuiltinCapCallExprModel)(m)
			self.inspect(c.Expr.Model)
		| &BuiltinDeleteCallExprModel:
			mut b := (&BuiltinDeleteCallExprModel)(m)
			self.inspect(b.Dest.Model)
			if b.Key != nil {
				self.inspect(b.Key.Model)
			}
		| &SizeofExprModel:
			mut s := (&SizeofExprModel)(m)
			self.inspect(s.Expr)
		| &AlignofExprModel:
			mut a := (&AlignofExprModel)(m)
			self.inspect(a.Expr)
		| &IntegratedToStrExprModel:
			mut i := (&IntegratedToStrExprModel)(m)
			self.inspect(i.Expr)
		| &FreeExprModel:
			mut f := (&FreeExprModel)(m)
			self.inspect(f.Expr)
		| &BackendEmitExprModel:
			mut e := (&BackendEmitExprModel)(m)
			self.args(e.Exprs)
		}
	}

	// Inspect expression model.
	// Resets [SkipChild] to default.
	// Inspector guarantees the parameter m will always point to original model.
	fn Inspect(mut self, mut &m: ExprModel, f: fn(mut &m: ExprModel)) {
		self.handler = f
		self.inspect(m)
	}
}