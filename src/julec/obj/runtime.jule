// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use sema for std::jule::sema::{ImportInfo, Fn}

enum RuntimeFunc: str {
	arrayCmp: "arrayCmp",
	shiftLeft: "shiftLeft",
	shiftRight: "shiftRight",
}

fn RuntimeFindFn(mut &runtime: &ImportInfo, ident: RuntimeFunc): &Fn {
	const Binded = false
	mut f := runtime.FindFn(ident, Binded)
	if f == nil {
		outln(ident)
		panic("runtime function is not exist, this is an implementation mistake, this panic call should be unreachable")
	}
	ret f
}

struct dropChecker {
	root:  &sema::TypeKind
	child: bool
}

impl dropChecker {
	fn haveSpecialDrop(mut self, mut k: &sema::TypeKind): bool {
		if k.Binded() {
			ret false
		}
		if k.GC() {
			ret true
		}
		if self.child && self.root.Equal(k) {
			// cycle occured
			// return false for itself
			ret false
		}
		self.child = true
		match {
		| k.Arr() != nil:
			ret self.haveSpecialDrop(k.Arr().Elem)
		| k.Map() != nil:
			mut m := k.Map()
			ret self.haveSpecialDrop(m.Key) || self.haveSpecialDrop(m.Val)
		| k.Struct() != nil:
			mut s := k.Struct()
			for (_, mut f) in s.Fields {
				if self.haveSpecialDrop(f.Kind) {
					ret true
				}
			}
			const Binded = false
			ret sema::FuncPattern.Dispose(s.FindMethod("Dispose", Binded))
		}
		ret false
	}
}

// Reports whether type have special drop call for drop semantics.
// For example, GC-collected types or structures with destructor.
fn TypeHaveSpecialDrop(mut k: &sema::TypeKind): bool {
	mut dc := dropChecker{root: k}
	ret dc.haveSpecialDrop(k)
}

struct copyChecker {
	root:  &sema::TypeKind
	child: bool
}

impl copyChecker {
	fn haveSpecialCopy(mut self, mut k: &sema::TypeKind): bool {
		if k.Binded() {
			ret false
		}
		if k.GC() {
			ret true
		}
		if self.child && self.root.Equal(k) {
			// cycle occured
			// return false for itself
			ret false
		}
		self.child = true
		mut arr := k.Arr()
		if arr != nil {
			ret self.haveSpecialCopy(arr.Elem)
		}
		mut mapz := k.Map()
		if mapz != nil {
			ret self.haveSpecialCopy(mapz.Key) || self.haveSpecialCopy(mapz.Val)
		}
		mut s := k.Struct()
		if s != nil {
			for (_, mut f) in s.Fields {
				if self.haveSpecialCopy(f.Kind) {
					ret true
				}
			}
		}
		ret false
	}
}

// Reports whether type have special copy call for copy semantics.
// For example, GC-collected types.
fn TypeHaveSpecialCopy(mut k: &sema::TypeKind): bool {
	mut cc := copyChecker{root: k}
	ret cc.haveSpecialCopy(k)
}