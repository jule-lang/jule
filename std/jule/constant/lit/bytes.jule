// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use conv for std::conv
use utf8 for std::unicode::utf8

// Reports whether rune is byte actually.
// In other words, whether rune is ACII.
fn IsAscii(r: rune): bool {
    const MaxAscii = 1 << 7 - 1
    ret r <= MaxAscii
}

// Returns rune value string from bytes, not includes quotes.
// Bytes are represents rune literal, allows escape sequences.
// Returns empty string if len(bytes) == 0
fn ToRune(bytes: []byte): rune {
    if len(bytes) == 0 {
        ret 0
    }

    let mut r: rune = 0
    if bytes[0] == '\\' && len(bytes) > 1 {
        let mut i = 0
        r = runeFromEsqSeq(bytes, i)
    } else {
        r, _ = utf8::DecodeRune(bytes)
    }

    ret r
}

// Returns raw-string value string from bytes, not includes quotes.
// Bytes are represents string characters.
// Returns empty string if len(bytes) == 0
fn ToRawStr(bytes: []byte): str { ret str(bytes) }

// Returns string value string from bytes, not includes quotes.
// Bytes are represents string characters, allows escape sequences.
// Returns empty string if len(bytes) == 0
fn ToStr(bytes: []byte): str {
    if len(bytes) == 0 {
        ret ""
    }

    let mut s = make([]byte, 0, len(bytes))
    let mut i = 0
    for i < len(bytes) {
        let b = bytes[i]
        if b == '\\' {
            s = append(s, strEsqSeq(bytes, i)...)
        } else {
            let (r, size) = utf8::DecodeRune(bytes[i:])
            i += size
            s = utf8::AppendRune(s, r)
        }
    }
    ret str(s)
}

fn tryBtoaCommonEsq(bytes: []byte): (seq: byte, ok: bool) {
    if len(bytes) < 2 || bytes[0] != '\\' {
        ret
    }
    match bytes[1] {
    | '\\':
        seq = '\\'
    | '\'':
        seq = '\''
    | '"':
        seq = '"'
    | 'a':
        seq = '\a'
    | 'b':
        seq = '\b'
    | 'f':
        seq = '\f'
    | 'n':
        seq = '\n'
    | 'r':
        seq = '\r'
    | 't':
        seq = '\t'
    | 'v':
        seq = '\v'
    }
    ok = seq != 0
    ret
}

fn runeFromEsqSeq(bytes: []byte, mut &i: int): rune {
    let (b, ok) = tryBtoaCommonEsq(bytes[i:])
    i++ // Skip escape sequence solidus.
    if ok {
        i++ // Skip sequence specifier.
        ret rune(b)
    }

    match bytes[i] {
    | 'u':
        const SeqLen = 5
        let r = rune(conv::ParseUint(str(bytes[i+1 : i+SeqLen]), 16, 64)!)
        i += SeqLen
        ret r
    | 'U':
        const SeqLen = 9
        let r = rune(conv::ParseUint(str(bytes[i+1 : i+SeqLen]), 16, 64)!)
        i += SeqLen
        ret r
    | 'x':
        const SeqLen = 3
        let seq = bytes[i+1 : i+SeqLen]
        i += SeqLen
        ret rune(conv::ParseUint(str(seq), 16, 64)!)
    |:
        const SeqLen = 3
        let seq = bytes[i:i+SeqLen]
        i += SeqLen
        ret rune(conv::ParseUint(str(seq[1:]), 8, 64)!)
    }
}

fn strEsqSeq(bytes: []byte, mut &i: int): []byte {
    let r = runeFromEsqSeq(bytes, i)
    if r <= 255 {
        ret [byte(r)]
    }
    ret []byte(str(r))
}