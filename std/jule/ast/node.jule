// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::jule::lex::{Token, TokenId, TokenKind, Ident}

// Type of AST Node's data.
pub enum NodeData: type {
    &EnumDecl,
    &TypeEnumDecl,
    &FnDecl,
    &StructDecl,
    &TraitDecl,
    &TypeAliasDecl,
    &VarDecl,
    &Impl,
}

// AST Node.
pub struct Node {
    pub Token: &Token
    pub Data:  NodeData
}

// Directive.
pub struct Directive {
    pub Tag:  &Token
    pub Args: []&Token
}

// Kind type of type declarations.
pub enum TypeDeclKind: type {
    &IdentTypeDecl,
    &SubIdentTypeDecl,
    &SptrTypeDecl,
    &PtrTypeDecl,
    &SlcTypeDecl,
    &ArrTypeDecl,
    &MapTypeDecl,
    &TupleTypeDecl,
    &FnDecl,
    &NamespaceTypeDecl,
}

// Type declaration.
// Also represents type expression.
//
// For primitive types:
//  - Represented by IdentTypeDecl.
//  - Token's identity is data type.
//  - Primitive type kind is Ident.
//
// For function types:
//  - Function types represented by &FnDecl.
pub struct TypeDecl {
    pub Token: &Token
    pub Kind:  TypeDeclKind
}

// Identifier type.
pub struct IdentTypeDecl {
    pub Token:     &Token
    pub Ident:     str
    pub CppLinked: bool
    pub Generics:  []&TypeDecl
}

impl IdentTypeDecl {
    // Reports whether identifier is primitive type.
    pub fn IsPrim(self): bool {
        ret self.Token.Id == TokenId.Prim
    }
}

// Sub-identifier type.
pub struct SubIdentTypeDecl {
    pub Idents: []&IdentTypeDecl
}

// Namespace chain type.
pub struct NamespaceTypeDecl {
    pub Idents: []&Token  // Namespace chain with identifier tokens.
    pub Kind:   &TypeDecl // Type of identifier.
}

// Smart pointer type.
pub struct SptrTypeDecl {
    pub Elem: &TypeDecl
}

// Slice type.
pub struct SlcTypeDecl {
    pub Elem: &TypeDecl
}

// Tuple type.
pub struct TupleTypeDecl {
    pub Types: []&TypeDecl
}

// Pointer type.
pub struct PtrTypeDecl {
    pub Elem: &TypeDecl
}

impl PtrTypeDecl {
    // Reports whether pointer is unsafe pointer (*unsafe).
    pub fn IsUnsafe(self): bool {
        ret self.Elem == nil
    }
}

// Array type.
// Size epxression is nil for auto-sized array.
pub struct ArrTypeDecl {
    pub Elem: &TypeDecl
    pub Size: &Expr
}

impl ArrTypeDecl {
    // Reports whether array is auto-sized.
    pub fn AutoSized(self): bool {
        ret self.Size == nil
    }
}

// Map type.
pub struct MapTypeDecl {
    pub Key: &TypeDecl
    pub Val: &TypeDecl
}

// Return type.
// Kind and Idents is nil for void type.
pub struct RetTypeDecl {
    pub Kind:   &TypeDecl
    pub Idents: []&Token
}

// Type of Expr's data.
pub enum ExprData: type {
    &RangeExpr,
    &TupleExpr,
    &LitExpr,
    &TypeDecl,
    &IdentExpr,
    &UnaryExpr,
    &SubIdentExpr,
    &NsSelectionExpr,
    &VariadicExpr,
    &CastExpr,
    &FnCallExpr,
    &StructLit,
    &BraceLit,
    &SlicingExpr,
    &SliceExpr,
    &BinopExpr,
    &UnsafeExpr,
    &IndexingExpr,
    &FnDecl,
    &FieldExprPair,
    &KeyValPair,
}

// Expression.
pub struct Expr {
    pub Token: &Token
    pub End:   &Token
    pub Kind:  ExprData
}

// Range expression between parentheses.
pub struct RangeExpr {
    pub Expr: &Expr
}

// Use expression.
pub struct UseExpr {
    pub Token: &Token
    pub Expr:  &Expr
}

// Tuple expression.
pub struct TupleExpr {
    pub Expr: []&Expr
}

// Literal expression.
pub struct LitExpr {
    pub Token: &Token
    pub Value: str
}

impl LitExpr {
    // Reports whether literal is nil value.
    pub fn IsNil(self): bool {
        ret self.Value == TokenKind.Nil
    }
}

// Unsafe expression.
pub struct UnsafeExpr {
    pub Token: &Token // Token of unsafe keyword.
    pub Expr:  &Expr
}

// Co expression.
pub struct CoExpr {
    pub Token: &Token // Token of co keyword.
    pub Expr:  &Expr
}

// Identifier expression.
pub struct IdentExpr {
    pub Token:     &Token // Token of identifier.
    pub Ident:     str
    pub CppLinked: bool
}

impl IdentExpr {
    // Reports whether identifier is self keyword.
    pub fn IsSelf(self): bool {
        ret self.Ident == TokenKind.Self
    }
}

// Unary expression.
pub struct UnaryExpr {
    pub Op:   &Token
    pub Expr: &Expr
}

// Variadiced expression.
pub struct VariadicExpr {
    pub Token: &Token
    pub Expr:  &Expr
}

// Casting expression.
pub struct CastExpr {
    pub Kind: &TypeDecl
    pub Expr: &Expr
}

// Namespace identifier selection expression.
pub struct NsSelectionExpr {
    pub Ns:    []&Token // Tokens of selected namespace identifier chain.
    pub Ident: &Token   // Token of selected identifier.
}

// Object sub identifier selection expression.
pub struct SubIdentExpr {
    pub IsSelf: bool   // True if root selector is "self" keyword.
    pub Expr:   &Expr  // Selected object.
    pub Ident:  &Token // TOken of selected identifier.
}

// Binary operation.
pub struct BinopExpr {
    pub Left:  &Expr
    pub Right: &Expr
    pub Op:    &Token
}

// Function call expression kind.
pub struct FnCallExpr {
    pub Token:     &Token
    pub Expr:      &Expr
    pub Args:      []&Expr
    pub Exception: &ScopeTree // Exception handling scope.
}

impl FnCallExpr {
    // Reports whether exception is not handled.
    pub fn Unhandled(self): bool {
        ret self.Exception == nil
    }

    // Reports whether exception is ignored.
    pub fn Ignored(self): bool {
        // Return true if deferred field is true.
        // Deferred field used mark for exception ignored calls like: x()!
        ret self.Exception != nil && self.Exception.Deferred
    }
}

// Field-Expression pair.
pub struct FieldExprPair {
    pub Field: &Token // Field identifier token.
    pub Expr:  &Expr
}

impl FieldExprPair {
    // Reports whether pair targeted field.
    pub fn IsTargeted(self): bool {
        ret self.Field != nil
    }
}

// Struct literal instiating expression.
pub struct StructLit {
    pub End:   &Token
    pub Kind:  &TypeDecl
    pub Exprs: []&Expr   // Possible types: &FieldExprPair, and other expressions.
}

// Anonymous brace instiating expression.
pub struct BraceLit {
    pub Token: &Token
    pub End:   &Token
    pub Exprs: []&Expr
}

impl BraceLit {
    // Reports whether literal is empty ( {} ).
    pub fn IsEmpty(self): bool {
        ret self.Exprs.len == 0
    }
}

// Key-value pair expression.
pub struct KeyValPair {
    pub Key:   &Expr
    pub Val:   &Expr
    pub Colon: &Token
}

// Slice initiating expression.
// Also represents array initiating expression.
pub struct SliceExpr {
    pub Token: &Token
    pub End:   &Token
    pub Exprs: []&Expr
}

impl SliceExpr {
    // Reports whether slice is empty.
    pub fn IsEmpty(self): bool {
        ret self.Exprs.len == 0
    }
}

// Indexing expression.
pub struct IndexingExpr {
    pub Token: &Token
    pub End:   &Token
    pub Expr:  &Expr  // Value expression to indexing.
    pub Index: &Expr  // Index value expression.
}

// Slicing expression.
pub struct SlicingExpr {
    pub Token: &Token
    pub End:   &Token
    pub Expr:  &Expr  // Value expression to slicing.
    pub Start: &Expr  // Start index value expression.
    pub To:    &Expr  // To index value expression.
}

// Constraint.
pub struct Constraint {
    pub Mask: []&TypeDecl
}

// Generic type declaration.
pub struct GenericDecl {
    pub Token:      &Token
    pub Ident:      str
    pub Constraint: &Constraint
}

// Label statement.
pub struct LabelSt {
    pub Token: &Token
    pub Ident: str
}

// Goto statement.
pub struct GotoSt {
    pub Token: &Token
    pub Label: &Token
}

// Fall statement.
pub struct FallSt {
    pub Token: &Token
}

// Left expression of assign statement.
pub struct AssignLeft {
    pub Token:     &Token
    pub Mutable:   bool
    pub Reference: bool
    pub Ident:     str
    pub Expr:      &Expr
}

// Assign statement.
pub struct AssignSt {
    pub Declarative: bool
    pub Setter:      &Token
    pub Left:        []&AssignLeft
    pub Right:       &Expr
}

// Type of Stmt's data.
pub enum StmtData: type {
    &VarDecl,
    &RetSt,
    &GotoSt,
    &BreakSt,
    &ContSt,
    &Expr,
    &Conditional,
    &MatchCase,
    &Iter,
    &AssignSt,
    &FallSt,
    &LabelSt,
    &ScopeTree,
    &TypeAliasDecl,
    &CoExpr,
    &UseExpr,
}

// Statement.
pub struct Stmt {
    pub Token: &Token
    pub Data:  StmtData
}

// Scope tree.
pub struct ScopeTree {
    pub Parent:   &ScopeTree // Nil if scope is root.
    pub Unsafety: bool
    pub Deferred: bool
    pub Stmts:    []Stmt
    pub End:      &Token
}

// Parameter.
pub struct ParamDecl {
    pub Token:     &Token
    pub Mutable:   bool
    pub Variadic:  bool
    pub Reference: bool
    pub Kind:      &TypeDecl
    pub Ident:     str
}

impl ParamDecl {
    // Reports whether parameter is self (receiver) parameter.
    pub fn IsSelf(self): bool {
        ret self.Ident == "&self" || self.Ident == "self"
    }

    // Reports whether self (receiver) parameter is reference.
    pub fn IsRef(self): bool {
        ret self.Ident != "" && self.Ident[0] == '&'
    }
}

// Function declaration.
// Also represents anonymous function expression.
pub struct FnDecl {
    pub Token:       &Token
    pub Global:      bool
    pub Unsafety:    bool
    pub Public:      bool
    pub CppLinked:   bool
    pub Statically:  bool
    pub Exceptional: bool
    pub Ident:       str
    pub Directives:  []&Directive
    pub Scope:       &ScopeTree
    pub Generics:    []&GenericDecl
    pub Result:      &RetTypeDecl
    pub Params:      []&ParamDecl
}

impl FnDecl {
    // Reports whether function is anonymous.
    pub fn IsAnon(self): bool {
        ret self.Ident == Ident.Anon
    }
}

// Variable declaration.
pub struct VarDecl {
    pub Scope:      &ScopeTree   // nil for global scopes
    pub Token:      &Token
    pub Ident:      str
    pub CppLinked:  bool
    pub Public:     bool
    pub Mutable:    bool
    pub Constant:   bool
    pub Statically: bool
    pub Reference:  bool
    pub Directives: []&Directive
    pub Kind:       &TypeDecl    // nil for type inferred
    pub Expr:       &Expr
}

// Return statement.
pub struct RetSt {
    pub Token: &Token
    pub Expr:  &Expr
}

// Type of Iter's kind.
pub enum IterKind: type {
    &WhileKind,
    &RangeKind,
}

// Iteration.
pub struct Iter {
    pub Token: &Token
    pub Kind:  IterKind
    pub Scope: &ScopeTree
}

impl Iter {
    // Reports whether iteration is infinity.
    pub fn IsInf(self): bool { ret self.Kind == nil }
}

// While iteration kind.
pub struct WhileKind {
    pub Expr:      &Expr
    pub Next:      StmtData // Nil if kind is while-next iteration.
    pub NextToken: &Token
}

impl WhileKind {
    // Reports whether kind is while-next iteration.
    pub fn IsWhileNext(self): bool {
        ret self.Next != nil
    }
}

// Range iteration kind.
pub struct RangeKind {
    pub InToken: &Token   // Token of "in" keyword
    pub Expr:    &Expr
    pub KeyA:    &VarDecl // first key of range
    pub KeyB:    &VarDecl // second key of range
}

// Break statement.
pub struct BreakSt {
    pub Token: &Token
    pub Label: &Token
}

// Continue statement.
pub struct ContSt {
    pub Token: &Token
    pub Label: &Token
}

// If condition.
pub struct If {
    pub Token: &Token
    pub Expr:  &Expr
    pub Scope: &ScopeTree
}

// Else condition.
pub struct Else {
    pub Token: &Token
    pub Scope: &ScopeTree
}

// Condition chain.
pub struct Conditional {
    pub Head:    &If
    pub Tail:    []&If
    pub Default: &Else
}

// Type alias declaration.
pub struct TypeAliasDecl {
    pub Scope:     &ScopeTree
    pub Public:    bool
    pub CppLinked: bool
    pub Token:     &Token
    pub Ident:     str
    pub Kind:      &TypeDecl
}

// Case of match-case.
pub struct Case {
    pub Token: &Token
    pub Scope: &ScopeTree

    // Holds expression.
    // Expressions holds *Type if If type matching.
    pub Exprs: []&Expr
}

// Match-Case.
pub struct MatchCase {
    pub Token:     &Token
    pub End:       &Token
    pub TypeMatch: bool
    pub Expr:      &Expr
    pub Cases:     []&Case
    pub Default:   &Else
}

// Use declaration statement.
pub struct UseDecl {
    pub Token:     &Token
    pub LinkPath:  str      // Use declaration path string.
    pub Alias:     str
    pub Full:      bool     // Full implicit import.
    pub Selected:  []&Token
    pub CppLinked: bool     // Cpp header use declaration.
    pub Std:       bool     // Standard package use declaration.
}

// Enum item.
pub struct EnumItemDecl {
    pub Token: &Token
    pub Ident: str
    pub Expr:  &Expr  // Nil for auto expression.
}

impl EnumItemDecl {
    // Reports whether item has auto expression.
    pub fn AutoExpr(self): bool {
        ret self.Expr == nil
    }
}

// Enum declaration.
pub struct EnumDecl {
    pub Token:  &Token
    pub Public: bool
    pub Ident:  str
    pub Kind:   &TypeDecl
    pub Items:  []&EnumItemDecl
    pub End:    &Token
}

impl EnumDecl {
    // Reports whether enum's type is default.
    pub fn DefaultTyped(self): bool {
        ret self.Kind == nil
    }
}

// TypeEnum item.
pub struct TypeEnumItemDecl {
    pub Token: &Token
    pub Ident: str
    pub Kind:  &TypeDecl
}

// TypeEnum declaration.
pub struct TypeEnumDecl {
    pub Token:  &Token
    pub Public: bool
    pub Ident:  str
    pub Items:  []&TypeEnumItemDecl
    pub End:    &Token
}

// Field declaration.
pub struct FieldDecl {
    pub Token:   &Token
    pub Public:  bool
    pub Mutable: bool      // Interior mutability.
    pub Ident:   str
    pub Kind:    &TypeDecl
    pub Default: &Expr     // Nil if not given.
}

// Structure declaration.
pub struct StructDecl {
    pub Token:      &Token
    pub End:        &Token
    pub Ident:      str
    pub Fields:     []&FieldDecl
    pub Public:     bool
    pub CppLinked:  bool
    pub Directives: []&Directive
    pub Generics:   []&GenericDecl
}

// Trait declaration.
pub struct TraitDecl {
    pub Token:   &Token
    pub End:     &Token
    pub Ident:   str
    pub Public:  bool
    pub Methods: []&FnDecl
}

// Implementation.
pub struct Impl {
    pub End: &Token

    // This token available for these cases:
    //  - Implementation trait to structure, represents trait's type.
    pub Base: &TypeDecl

    // This token available for these cases:
    //  - Implementation trait to structure, represents structure's type.
    //  - Implementation to structure, represents structure's type.
    pub Dest: &TypeDecl

    // Given methods to implement.
    pub Methods: []&FnDecl

    // Static variables to implement.
    pub Statics: []&VarDecl
}

impl Impl {
    // Reports whether implementation type is trait to structure.
    pub fn IsTraitImpl(self): bool {
        ret self.Base != nil
    }

    // Reports whether implementation type is append to destination structure.
    pub fn IsStructImpl(self): bool {
        ret self.Base == nil
    }
}