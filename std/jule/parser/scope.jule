// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/jule/ast"
use "std/jule/build"
use "std/jule/lex"

fn newScope(): &ast::ScopeTree {
	ret new(ast::ScopeTree)
}

// Reports whether token is statement finish point.
fn isSt(current: &lex::Token, prev: &lex::Token): (ok: bool, terminated: bool) {
	ok = current.Id == lex::TokenId.Semicolon || prev.Row < current.Row
	terminated = current.Id == lex::TokenId.Semicolon
	ret
}

fn prevIsIncompleteExpr(&tokens: []&lex::Token, &i: int): bool {
	// Ignore namespaces.
	if i > 1 && tokens[i-2].Id == lex::TokenId.DblColon {
		ret false
	}
	unsafe {
		prev := tokens[i-1]
		ret prev.Id == lex::TokenId.Dot ||
			(lex::IsBinOp(prev.Id) && prev.Row < tokens[i].Row)
	}
}

// Reports position of the next statement if exist, len(toks) if not.
fn nextStPos(&tokens: []&lex::Token, start: int): (int, bool) {
	mut braceN := 0
	mut i := start
	for i < len(tokens); i++ {
		mut ok := false
		mut terminated := false
		tok := tokens[i]
		match tok.Id {
		| lex::TokenId.LBrace
		| lex::TokenId.LBracket
		| lex::TokenId.LParent:
			if braceN == 0 && i > start {
				if !prevIsIncompleteExpr(tokens, i) {
					ok, terminated = isSt(tok, tokens[i-1])
					if ok {
						goto return
					}
				}
			}
			braceN++
			continue
		| lex::TokenId.RBrace
		| lex::TokenId.RBracket
		| lex::TokenId.RParent:
			braceN--
			if braceN == 0 && i+1 < len(tokens) {
				ok, terminated = isSt(tokens[i+1], tok)
				if ok {
					i++
					goto return
				}
			}
			continue
		}

		if braceN != 0 {
			continue
		}

		if i > start {
			if prevIsIncompleteExpr(tokens, i) {
				continue
			}
			ok, terminated = isSt(tok, tokens[i-1])
		} else {
			ok, terminated = isSt(tok, tok)
		}
		if !ok {
			continue
		}

	return:
		if terminated {
			i++
		}
		ret i, terminated
	}
	ret i, false
}

// Returns current statement tokens.
// Starts selection at i.
fn skipSt(mut &i: int, mut tokens: []&lex::Token): ([]&lex::Token, bool) {
	start := i
	mut terminated := false
	i, terminated = nextStPos(tokens, start)
	mut stTokens := tokens[start:i]
	if terminated {
		if len(stTokens) == 1 {
			ret skipSt(i, tokens)
		}
		// -1 for eliminate statement terminator.
		stTokens = stTokens[:len(stTokens)-1]
	}
	ret stTokens, terminated
}

struct stmt {
	tokens:     []&lex::Token
	terminated: bool
}

// Splits all statements.
fn splitStmts(mut &tokens: []&lex::Token): []&stmt {
	mut stmts := make([]&stmt, 0, 20)
	mut pos := 0
	for pos < len(tokens) {
		mut stmt, terminated := skipSt(pos, tokens)
		stmts = append(stmts, &stmt{
			tokens: stmt,
			terminated: terminated,
		})
	}
	ret stmts
}

struct scopeParser {
	p:     &parser
	s:     &ast::ScopeTree
	stmts: []&stmt
	pos:   int
}

impl scopeParser {
	fn stop(mut self) {
		self.pos = -1
	}

	fn stopped(self): bool {
		ret self.pos == -1
	}

	fn finished(self): bool {
		ret self.pos >= len(self.stmts)
	}

	fn isLastSt(self): bool {
		ret self.pos+1 >= len(self.stmts)
	}

	fn pushErr(mut self, token: &lex::Token, fmt: build::LogMsg) {
		self.p.pushErr(token, fmt)
	}

	// Push suggestion to last log.
	fn pushSuggestion(mut self, fmt: build::LogMsg, args: ...any) {
		self.p.pushSuggestion(fmt, args...)
	}

	fn insertAsNext(mut self, mut &tokens: []&lex::Token) {
		self.stmts = append(self.stmts[:self.pos+1], self.stmts[self.pos:]...)
		self.stmts[self.pos+1] = &stmt{tokens: tokens}
	}

	fn next(mut self): &stmt {
		self.pos++
		ret self.stmts[self.pos]
	}

	fn buildScope(mut self, mut &tokens: []&lex::Token, mut end: &lex::Token): &ast::ScopeTree {
		mut s := newScope()
		s.Parent = self.s
		s.End = end
		mut ssp := scopeParser{
			p: self.p,
		}
		ssp.build(tokens, s)
		ret s
	}

	fn buildVarSt(mut self, mut &tokens: []&lex::Token): &ast::VarDecl {
		mut v := self.p.buildVar(tokens)
		if v != nil {
			v.Scope = self.s
		}
		ret v
	}

	fn buildRetSt(mut self, mut tokens: []&lex::Token): &ast::RetSt {
		mut st := &ast::RetSt{
			Token: tokens[0],
		}
		if len(tokens) > 1 {
			tokens = tokens[1:] // Remove ret keyword.
			st.Expr = self.p.buildExpr(tokens)
		}
		ret st
	}

	fn buildWhileNextIter(mut self, mut &s: &stmt): &ast::Iter {
		mut it := &ast::Iter{
			Token: s.tokens[0],
		}
		mut tokens := s.tokens[1:] // Skip "iter" keyword.
		mut kind := new(ast::WhileKind)

		if len(tokens) > 0 {
			kind.Expr = self.p.buildExpr(tokens)
		}

		if self.isLastSt() {
			self.pushErr(it.Token, build::LogMsg.InvalidSyntax)
			ret nil
		}

		tokens = self.next().tokens
		mut stTokens := getBlockExpr(tokens)
		if len(stTokens) > 0 {
			mut stmt := &stmt{
				terminated: s.terminated,
				tokens: stTokens,
			}
			kind.NextToken = stTokens[0]
			kind.Next = self.buildSt(stmt)
		}

		mut i := len(stTokens)
		mut blockTokens := range(i, lex::TokenId.LBrace, lex::TokenId.RBrace, tokens)
		if blockTokens == nil {
			self.stop()
			self.pushErr(it.Token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}

		it.Scope = self.buildScope(blockTokens, tokens[i-1])
		it.Kind = kind

		ret it
	}

	fn buildWhileIterKind(mut self, mut &tokens: []&lex::Token): &ast::WhileKind {
		ret &ast::WhileKind{
			Expr: self.p.buildExpr(tokens),
		}
	}

	fn getRangeKindKeysTokens(mut self, mut &toks: []&lex::Token): [][]&lex::Token {
		mut vars, errs := parts(toks, lex::TokenId.Comma, true)
		self.p.errors = append(self.p.errors, errs...)
		ret vars
	}

	fn buildRangeKindKey(mut self, mut &tokens: []&lex::Token): &ast::VarDecl {
		if len(tokens) == 0 {
			ret nil
		}
		mut key := &ast::VarDecl{
			Token: tokens[0],
			Setter: tokens[0],
		}
		if key.Token.Id == lex::TokenId.Mut {
			key.Mutable = true
			if len(tokens) == 1 {
				self.pushErr(key.Token, build::LogMsg.InvalidSyntax)
			}
			key.Token = tokens[1]
		} else if len(tokens) > 1 {
			self.pushErr(tokens[1], build::LogMsg.InvalidSyntax)
		}
		if key.Token.Id != lex::TokenId.Ident {
			self.pushErr(key.Token, build::LogMsg.InvalidSyntax)
			self.pushSuggestion(build::LogMsg.ExpectedIdentifier)
			ret nil
		}
		key.Ident = key.Token.Kind
		ret key
	}

	fn buildRangeKindKeys(mut self, mut &parts: [][]&lex::Token): []&ast::VarDecl {
		let mut keys: []&ast::VarDecl = nil
		for (_, mut tokens) in parts {
			keys = append(keys, self.buildRangeKindKey(tokens))
		}
		ret keys
	}

	fn setupRangeKindKeysPlain(mut self, mut &rng: &ast::RangeKind, mut &tokens: []&lex::Token) {
		mut keyTokens := self.getRangeKindKeysTokens(tokens)
		if len(keyTokens) == 0 {
			ret
		}
		if len(keyTokens) > 2 {
			self.pushErr(rng.InToken, build::LogMsg.MuchRangeVars)
		}
		mut keys := self.buildRangeKindKeys(keyTokens)
		rng.KeyA = keys[0]
		if len(keys) > 1 {
			rng.KeyB = keys[1]
		}
	}

	fn setupRangeKindKeysExplicit(mut self, mut &rng: &ast::RangeKind, mut &tokens: []&lex::Token) {
		mut i := 0
		mut rang := range(i, lex::TokenId.LParent, lex::TokenId.RParent, tokens)
		if i < len(tokens) {
			self.pushErr(rng.InToken, build::LogMsg.InvalidSyntax)
		}
		self.setupRangeKindKeysPlain(rng, rang)
	}

	fn setupRangeKindKeys(mut self, mut &rng: &ast::RangeKind, mut &tokens: []&lex::Token) {
		if tokens[0].Id == lex::TokenId.LParent {
			self.setupRangeKindKeysExplicit(rng, tokens)
			ret
		}
		self.setupRangeKindKeysPlain(rng, tokens)
	}

	fn buildRangeIterKind(mut self, mut &varTokens: []&lex::Token,
		mut &exprTokens: []&lex::Token, mut &inToken: &lex::Token): &ast::RangeKind {
		mut rng := &ast::RangeKind{
			InToken: inToken,
		}
		if len(exprTokens) == 0 {
			self.pushErr(rng.InToken, build::LogMsg.MissingExpr)
			ret rng
		}
		rng.Expr = self.p.buildExpr(exprTokens)
		if len(varTokens) > 0 {
			self.setupRangeKindKeys(rng, varTokens)
		}
		ret rng
	}

	fn buildCommonIterKind(mut self, mut &tokens: []&lex::Token, &errTok: &lex::Token): ast::IterKind {
		mut braceN := 0
		for (i, mut tok) in tokens {
			match tok.Id {
			| lex::TokenId.LBrace
			| lex::TokenId.LBracket
			| lex::TokenId.LParent:
				braceN++
				continue
			| lex::TokenId.RBrace
			| lex::TokenId.RBracket
			| lex::TokenId.RParent:
				braceN--
			}
			if braceN != 0 {
				continue
			}
			match tok.Id {
			| lex::TokenId.In:
				mut declTokens := tokens[:i]
				mut exprTokens := tokens[i+1:]
				ret self.buildRangeIterKind(declTokens, exprTokens, tok)
			}
		}
		ret self.buildWhileIterKind(tokens)
	}

	fn buildCommonIter(mut self, mut tokens: []&lex::Token): &ast::Iter {
		mut it := &ast::Iter{
			Token: tokens[0],
		}
		tokens = tokens[1:] // Skip "iter" keyword.
		if len(tokens) == 0 {
			self.stop()
			self.pushErr(it.Token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		}
		mut exprTokens := getBlockExpr(tokens)
		if len(exprTokens) > 0 {
			it.Kind = self.buildCommonIterKind(exprTokens, it.Token)
		}
		mut i := len(exprTokens)
		mut scopeTokens := range(i, lex::TokenId.LBrace, lex::TokenId.RBrace, tokens)
		if scopeTokens == nil {
			self.stop()
			self.pushErr(it.Token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}
		it.Scope = self.buildScope(scopeTokens, tokens[i-1])
		ret it
	}

	fn buildIterSt(mut self, mut &st: &stmt): &ast::Iter {
		if st.terminated {
			ret self.buildWhileNextIter(st)
		}
		ret self.buildCommonIter(st.tokens)
	}

	fn buildBreakSt(mut self, mut &tokens: []&lex::Token): &ast::BreakSt {
		mut brk := &ast::BreakSt{
			Token: tokens[0],
		}
		if len(tokens) > 1 {
			if tokens[1].Id != lex::TokenId.Ident {
				self.pushErr(tokens[1], build::LogMsg.InvalidSyntax)
				self.pushSuggestion(build::LogMsg.ExpectedLabelIdent)
			} else {
				brk.Label = tokens[1]
				if len(tokens) > 2 {
					self.pushErr(tokens[1], build::LogMsg.InvalidSyntax)
				}
			}
		}
		ret brk
	}

	fn buildContSt(mut self, mut &tokens: []&lex::Token): &ast::ContSt {
		mut cont := &ast::ContSt{
			Token: tokens[0],
		}
		if len(tokens) > 1 {
			if tokens[1].Id != lex::TokenId.Ident {
				self.pushErr(tokens[1], build::LogMsg.InvalidSyntax)
				self.pushSuggestion(build::LogMsg.ExpectedLabelIdent)
			} else {
				cont.Label = tokens[1]
				if len(tokens) > 2 {
					self.pushErr(tokens[1], build::LogMsg.InvalidSyntax)
				}
			}
		}
		ret cont
	}

	fn buildIf(mut self, mut &tokens: []&lex::Token): &ast::If {
		mut model := &ast::If{
			Token: tokens[0],
		}
		tokens = tokens[1:]
		mut exprTokens := getBlockExpr(tokens)
		mut i := 0
		if len(exprTokens) == 0 {
			self.pushErr(model.Token, build::LogMsg.MissingExpr)
		} else {
			i = len(exprTokens)
		}
		mut scopeTokens := range(i, lex::TokenId.LBrace, lex::TokenId.RBrace, tokens)
		if scopeTokens == nil {
			self.stop()
			self.pushErr(model.Token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		}
		mut end := tokens[i-1]
		if i < len(tokens) {
			if tokens[i].Id == lex::TokenId.Else {
				tokens = tokens[i:]
			} else {
				self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
				tokens = nil
			}
		}
		model.Expr = self.p.buildExpr(exprTokens)
		model.Scope = self.buildScope(scopeTokens, end)
		ret model
	}

	fn buildElse(mut self, mut &tokens: []&lex::Token): &ast::Else {
		mut els := &ast::Else{
			Token: tokens[0],
		}
		tokens = tokens[1:] // Remove "else" keyword.
		mut i := 0
		mut scopeTokens := range(i, lex::TokenId.LBrace, lex::TokenId.RBrace, tokens)
		if scopeTokens == nil {
			if i < len(tokens) {
				self.pushErr(els.Token, build::LogMsg.ElseHaveExpr)
			} else {
				self.stop()
				self.pushErr(els.Token, build::LogMsg.BodyNotExist)
				self.pushSuggestion(build::LogMsg.ExpectedBody)
			}
			ret nil
		}
		if i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}
		els.Scope = self.buildScope(scopeTokens, tokens[i-1])
		ret els
	}

	fn buildIfElseChain(mut self, mut tokens: []&lex::Token): &ast::Conditional {
		mut chain := &ast::Conditional{
			Head: self.buildIf(tokens),
		}
		if chain.Head == nil {
			ret nil
		}
		for len(tokens) != 0 {
			if tokens[0].Id != lex::TokenId.Else {
				break
			}
			if len(tokens) > 1 && tokens[1].Id == lex::TokenId.If {
				tokens = tokens[1:] // Remove else token
				mut elif := self.buildIf(tokens)
				chain.Tail = append(chain.Tail, elif)
				continue
			}
			chain.Default = self.buildElse(tokens)
			break
		}
		ret chain
	}

	fn buildCoCallSt(mut self, mut tokens: []&lex::Token): &ast::Expr {
		token := tokens[0]
		tokens = tokens[1:] // Start 1 to skip "co" token.
		mut e := self.p.buildExpr(tokens)
		if e == nil {
			ret e
		}
		match type e.Kind {
		| &ast::FnCallExpr:
			(&ast::FnCallExpr)(e.Kind).IsCo = true
		|:
			self.pushErr(token, build::LogMsg.ExprNotFnCall)
		}
		ret e
	}

	fn buildGotoSt(mut self, mut &tokens: []&lex::Token): &ast::GotoSt {
		mut gt := &ast::GotoSt{
			Token: tokens[0],
		}
		if len(tokens) == 1 {
			self.pushErr(gt.Token, build::LogMsg.MissingGotoLabel)
			ret nil
		} else if len(tokens) > 2 {
			self.pushErr(tokens[2], build::LogMsg.InvalidSyntax)
		}
		mut identToken := tokens[1]
		if identToken.Id != lex::TokenId.Ident {
			self.pushErr(identToken, build::LogMsg.InvalidSyntax)
			self.pushSuggestion(build::LogMsg.ExpectedIdentifier)
			ret gt
		}
		gt.Label = identToken
		ret gt
	}

	fn buildFallSt(mut self, mut &tokens: []&lex::Token): &ast::FallSt {
		mut fll := &ast::FallSt{
			Token: tokens[0],
		}
		if len(tokens) > 1 {
			self.pushErr(tokens[1], build::LogMsg.InvalidSyntax)
		}
		ret fll
	}

	fn buildTypeAliasSt(mut self, mut &tokens: []&lex::Token): &ast::TypeAliasDecl {
		mut tad := self.p.buildTypeAliasDecl(tokens)
		tad.Scope = self.s
		ret tad
	}

	fn pushCaseExpr(mut self, mut tokens: []&lex::Token, mut token: &lex::Token,
		typeMatch: bool, mut &exprs: []&ast::Expr) {
		if len(tokens) == 0 {
			ret
		}
		if typeMatch {
			mut i := 0
			mut t, ok := unsafe { self.p.buildType(tokens, &i, true) }
			if ok {
				exprs = append(exprs, &ast::Expr{
					Token: tokens[0],
					End: tokens[len(tokens)-1],
					Kind: t,
				})
				if i < len(tokens) {
					self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
				}
			}
			ret
		}
		exprs = append(exprs, self.p.buildExpr(tokens))
	}

	fn buildCaseExprs(mut self, mut &tokens: []&lex::Token, mut &colon: &lex::Token, typeMatch: bool): ([]&ast::Expr, bool) {
		mut exprs := make([]&ast::Expr, 0, 1)
		mut braceN := 0
		mut j := 0
		for (i, mut tok) in tokens {
			match tok.Id {
			| lex::TokenId.LParent
			| lex::TokenId.LBrace
			| lex::TokenId.LBracket:
				braceN++
				continue
			| lex::TokenId.RParent
			| lex::TokenId.RBrace
			| lex::TokenId.RBracket:
				braceN--
				continue
			}

			if braceN != 0 {
				continue
			}
			match {
			| tok.Id == lex::TokenId.Vline:
				exprTokens := tokens[j:i]
				if len(exprTokens) == 0 {
					self.pushErr(tok, build::LogMsg.MissingExpr)
				} else {
					self.pushCaseExpr(tokens[j:i], tok, typeMatch, exprs)
				}
				j = i + 1
			| tok.Id == lex::TokenId.Colon:
				colon = tok
				self.pushCaseExpr(tokens[j:i], tok, typeMatch, exprs)
				tokens = tokens[i+1:]
				ret exprs, i-j == 0 || len(exprs) != 0
			}
		}
		self.pushErr(tokens[0], build::LogMsg.InvalidSyntax)
		tokens = nil
		ret nil, false
	}

	fn buildCaseScope(mut self, mut &tokens: []&lex::Token): &ast::ScopeTree {
		mut n := 0
		for {
			mut i := 0
			mut next, _ := skipSt(i, tokens[n:])
			if len(next) == 0 {
				break
			}
			tok := next[0]
			if tok.Id != lex::TokenId.Vline {
				n += i
				continue
			}
			mut scopeTokens := tokens[:n]
			mut scope := self.buildScope(scopeTokens, tokens[n])
			tokens = tokens[n:]
			ret scope
		}
		let mut end: &lex::Token
		if len(tokens) > 0 {
			end = tokens[len(tokens)-1]
		}
		mut scope := self.buildScope(tokens, end)
		tokens = nil
		ret scope
	}

	fn buildCase(mut self, mut &tokens: []&lex::Token, typeMatch: bool): (&ast::Case, bool) {
		mut c := &ast::Case{
			Token: tokens[0],
		}
		tokens = tokens[1:] // Remove case prefix.
		let mut colon: &lex::Token = nil
		if len(tokens) == 0 {
			self.pushErr(c.Token, build::LogMsg.InvalidSyntax)
			ret nil, false
		}
		c.Exprs, ok := self.buildCaseExprs(tokens, colon, typeMatch)
		c.Scope = self.buildCaseScope(tokens)
		if c.Scope.End == nil {
			c.Scope.End = colon
		}
		isDefault := ok && len(c.Exprs) == 0
		ret c, isDefault
	}

	fn buildCases(mut self, mut tokens: []&lex::Token, typeMatch: bool): ([]&ast::Case, &ast::Else) {
		let mut cases: []&ast::Case = nil
		let mut def: &ast::Else = nil
		mut defNotLast := false
		for len(tokens) > 0 {
			mut tok := tokens[0]
			if tok.Id != lex::TokenId.Vline {
				self.pushErr(tok, build::LogMsg.InvalidSyntax)
				break
			}
			mut c, isDefault := self.buildCase(tokens, typeMatch)
			if isDefault {
				c.Token = tok
				if def == nil {
					def = &ast::Else{
						Token: c.Token,
						Scope: c.Scope,
					}
				} else {
					self.pushErr(tok, build::LogMsg.InvalidSyntax)
				}
			} else {
				defNotLast = defNotLast || def != nil
				cases = append(cases, c)
			}
		}

		if defNotLast {
			self.pushErr(def.Token, build::LogMsg.DefaultNotLast)
		}

		ret cases, def
	}

	fn buildMatchCase(mut self, mut tokens: []&lex::Token): &ast::MatchCase {
		mut m := &ast::MatchCase{
			Token: tokens[0],
		}
		tokens = tokens[1:] // Remove "match" keyword.

		if len(tokens) > 0 && tokens[0].Id == lex::TokenId.Type {
			m.TypeMatch = true
			tokens = tokens[1:] // Skip "type" keyword
		}

		mut exprTokens := getBlockExpr(tokens)
		if len(exprTokens) > 0 {
			m.Expr = self.p.buildExpr(exprTokens)
		} else if m.TypeMatch {
			self.pushErr(m.Token, build::LogMsg.MissingExpr)
		}

		mut i := len(exprTokens)
		mut blockToks := range(i, lex::TokenId.LBrace, lex::TokenId.RBrace, tokens)
		if blockToks == nil {
			self.stop()
			self.pushErr(m.Token, build::LogMsg.BodyNotExist)
			self.pushSuggestion(build::LogMsg.ExpectedBody)
			ret nil
		} else if i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}
		m.End = tokens[i-1]
		m.Cases, m.Default = self.buildCases(blockToks, m.TypeMatch)
		ret m
	}

	fn buildScopeSt(mut self, mut tokens: []&lex::Token): &ast::ScopeTree {
		mut isUnsafe := false
		mut isDeferred := false
		mut token := tokens[0]
		if token.Id == lex::TokenId.Unsafe {
			isUnsafe = true
			tokens = tokens[1:]
			if len(tokens) == 0 {
				self.pushErr(token, build::LogMsg.InvalidSyntax)
				ret nil
			}
			token = tokens[0]
			if token.Id == lex::TokenId.Defer {
				isDeferred = true
				tokens = tokens[1:]
				if len(tokens) == 0 {
					self.pushErr(token, build::LogMsg.InvalidSyntax)
					ret nil
				}
			}
		} else if token.Id == lex::TokenId.Defer {
			isDeferred = true
			tokens = tokens[1:]
			if len(tokens) == 0 {
				self.pushErr(token, build::LogMsg.InvalidSyntax)
				ret nil
			}
		}

		mut i := 0
		mut scopeTokens := range(i, lex::TokenId.LBrace, lex::TokenId.RBrace, tokens)
		if scopeTokens == nil {
			self.pushErr(token, build::LogMsg.InvalidSyntax)
			ret nil
		} else if i < len(tokens) {
			self.pushErr(tokens[i], build::LogMsg.InvalidSyntax)
		}
		mut scope := self.buildScope(scopeTokens, tokens[i-1])
		scope.Unsafety = isUnsafe
		scope.Deferred = isDeferred
		ret scope
	}

	fn buildLabelSt(mut self, mut &tokens: []&lex::Token): &ast::LabelSt {
		mut lbl := &ast::LabelSt{
			Token: tokens[0],
			Ident: tokens[0].Kind,
		}

		// Save followed statement
		if len(tokens) > 2 {
			tokens = tokens[2:] // Remove goto keyword and label
			self.insertAsNext(tokens)
		}

		ret lbl
	}

	fn buildIdSt(mut self, mut &tokens: []&lex::Token): (ast::StmtData, ok: bool) {
		if len(tokens) == 1 {
			ret
		}

		mut token := tokens[1]
		match token.Id {
		| lex::TokenId.Colon:
			ret self.buildLabelSt(tokens), true
		}

		ret
	}

	fn buildAssignInfo(mut self, mut &tokens: []&lex::Token): &assignInfo {
		mut info := &assignInfo{
			ok: true,
		}
		mut braceN := 0
		for (i, mut token) in tokens {
			match token.Id {
			| lex::TokenId.LBrace
			| lex::TokenId.LBracket
			| lex::TokenId.LParent:
				braceN++
			| lex::TokenId.RBrace
			| lex::TokenId.RBracket
			| lex::TokenId.RParent:
				braceN--
			}
			match {
			| braceN > 0:
				continue
			| !lex::IsAssignOp(token.Id) && token.Id != lex::TokenId.ColonEq:
				continue
			}

			info.l = tokens[:i]
			if len(info.l) == 0 {
				info.ok = false
			}
			info.setter = token
			if i+1 >= len(tokens) {
				info.r = nil
				info.ok = lex::IsPostfixOp(info.setter.Id)
				break
			}
			info.r = tokens[i+1:]
			if lex::IsPostfixOp(info.setter.Id) {
				if len(info.r) > 0 {
					self.pushErr(info.r[0], build::LogMsg.InvalidSyntax)
					info.r = nil
				}
			}
			break
		}
		ret info
	}

	fn buildAssignL(mut self, mut &tokens: []&lex::Token): &ast::AssignLeft {
		mut l := &ast::AssignLeft{
			Token: tokens[0],
		}
		if tokens[0].Id == lex::TokenId.Ident {
			l.Ident = l.Token.Kind
		}
		l.Expr = self.p.buildExpr(tokens)
		ret l
	}

	fn buildAssignLs(mut self, mut &parts: [][]&lex::Token): []&ast::AssignLeft {
		let mut lefts: []&ast::AssignLeft = nil
		for (_, mut part) in parts {
			mut l := self.buildAssignL(part)
			lefts = append(lefts, l)
		}
		ret lefts
	}

	fn buildPlainAssign(mut self, mut &tokens: []&lex::Token): (ast::StmtData, bool) {
		mut info := self.buildAssignInfo(tokens)
		if !info.ok {
			ret nil, false
		}

		mut assign := &ast::AssignSt{
			Setter: info.setter,
		}

		// Caught declaration assignments.
		if info.setter.Id == lex::TokenId.ColonEq {
			assign.Declarative = true
			assign.Right = self.p.buildExpr(info.r)
			ok := self.buildDeclAssign1(info.l, assign)
			if !ok {
				// Return with true to avoid duplicate error.
				ret nil, true
			}
			if len(assign.Left) > 1 {
				ret assign, true
			}
			// Single left, use &VarDecl intead if possible.
			mut left := assign.Left[0]
			match type left.Expr.Kind {
			| &ast::IdentExpr:
				mut decl := &ast::VarDecl{
					Token: left.Token,
					Setter: assign.Setter,
					Ident: left.Ident,
					Mutable: left.Mutable,
					Reference: left.Reference,
					Scope: self.s,
					Expr: assign.Right,
				}
				ret decl, true
			}
			ret assign, true
		}

		mut parts, errs := parts(info.l, lex::TokenId.Comma, true)
		if len(errs) > 0 {
			self.p.errors = append(self.p.errors, errs...)
			ret nil, false
		}

		assign.Left = self.buildAssignLs(parts)
		if info.r != nil {
			assign.Right = self.p.buildExpr(info.r)
		}

		ret assign, true
	}

	fn buildDeclAssign1(mut self, mut &lefts: []&lex::Token, mut &assign: &ast::AssignSt): bool {
		// Lefts
		mut parts, errs := parts(lefts, lex::TokenId.Comma, true)
		if len(errs) > 0 {
			self.p.errors = append(self.p.errors, errs...)
			ret false
		}

		for (_, mut part) in parts {
			mut isMut := false
			mut isRef := false

			token := part[0]
			if token.Id == lex::TokenId.Mut {
				isMut = true
				part = part[1:]
				if len(part) == 0 {
					self.pushErr(token, build::LogMsg.InvalidSyntax)
					ret false
				}
			}

			if part[0].Id == lex::TokenId.Amper {
				isRef = true
				part = part[1:]
				if len(part) == 0 {
					self.pushErr(token, build::LogMsg.InvalidSyntax)
					ret false
				}
			}

			if part[0].Id != lex::TokenId.Ident && part[0].Id != lex::TokenId.LParent {
				self.pushErr(token, build::LogMsg.InvalidSyntax)
				ret false
			}

			mut l := self.buildAssignL(part)
			if l.Expr == nil {
				ret false
			}
			l.Mutable = isMut
			l.Reference = isRef
			assign.Left = append(assign.Left, l)
		}

		ret true
	}

	fn buildDeclAssign(mut self, mut tokens: []&lex::Token): (&ast::AssignSt, bool) {
		if len(tokens) < 1 {
			ret nil, false
		}

		tokens = tokens[1:] // Skip "let" keyword
		mut token := tokens[0]
		if token.Id != lex::TokenId.LParent {
			ret nil, false
		}

		mut assign := &ast::AssignSt{
			Declarative: true,
		}

		mut i := 0
		mut rang := range(i, lex::TokenId.LParent, lex::TokenId.RParent, tokens)
		if rang == nil {
			self.pushErr(token, build::LogMsg.InvalidSyntax)
			ret nil, false
		} else if i+1 < len(tokens) {
			assign.Setter = tokens[i]
			if assign.Setter.Id != lex::TokenId.Eq {
				self.pushErr(assign.Setter, build::LogMsg.InvalidSyntax)
			}
			i++
			mut exprTokens := tokens[i:]
			assign.Right = self.p.buildExpr(exprTokens)
		}

		ok := self.buildDeclAssign1(rang, assign)
		ret assign, ok
	}

	fn buildAssignSt(mut self, mut &tokens: []&lex::Token): (st: ast::StmtData, ok: bool) {
		if !checkAssignTokens(tokens) {
			ret nil, false
		}
		match tokens[0].Id {
		| lex::TokenId.Let:
			st, ok = self.buildDeclAssign(tokens)
		|:
			st, ok = self.buildPlainAssign(tokens)
		}
		ret
	}

	fn buildUseExpr(mut self, mut &tokens: []&lex::Token): &ast::UseExpr {
		if len(tokens) == 1 {
			self.pushErr(tokens[0], build::LogMsg.MissingExpr)
			ret nil
		}
		mut ue := &ast::UseExpr{
			Token: tokens[0],
		}
		tokens = tokens[1:] // Ignore "use" keyword.
		ue.Expr = self.p.buildExpr(tokens)
		ret ue
	}

	fn buildConstSt(mut self, mut &st: &stmt): ast::StmtData {
		if len(st.tokens) == 1 {
			self.pushErr(st.tokens[0], build::LogMsg.InvalidSyntax)
			ret nil
		}
		match st.tokens[1].Id {
		| lex::TokenId.For:
			st.tokens = st.tokens[1:]
			mut iter := self.buildIterSt(st)
			if iter != nil {
				iter.Comptime = true
			}
			ret iter
		| lex::TokenId.Match:
			st.tokens = st.tokens[1:]
			mut mt := self.buildMatchCase(st.tokens)
			if mt != nil {
				mt.Comptime = true
			}
			ret mt
		|:
			ret self.buildVarSt(st.tokens)
		}
	}

	fn buildSt(mut self, mut &st: &stmt): ast::StmtData {
		mut token := st.tokens[0]
		if token.Id == lex::TokenId.Ident {
			mut s, ok := self.buildIdSt(st.tokens)
			if ok {
				ret s
			}
		}

		mut s, ok := self.buildAssignSt(st.tokens)
		if ok {
			ret s
		}

		match token.Id {
		| lex::TokenId.Use:
			ret self.buildUseExpr(st.tokens)
		| lex::TokenId.Const:
			ret self.buildConstSt(st)
		| lex::TokenId.Static
		| lex::TokenId.Let
		| lex::TokenId.Mut:
			ret self.buildVarSt(st.tokens)
		| lex::TokenId.Ret:
			ret self.buildRetSt(st.tokens)
		| lex::TokenId.For:
			ret self.buildIterSt(st)
		| lex::TokenId.Break:
			ret self.buildBreakSt(st.tokens)
		| lex::TokenId.Cont:
			ret self.buildContSt(st.tokens)
		| lex::TokenId.If:
			ret self.buildIfElseChain(st.tokens)
		| lex::TokenId.Co:
			ret self.buildCoCallSt(st.tokens)
		| lex::TokenId.Goto:
			ret self.buildGotoSt(st.tokens)
		| lex::TokenId.Fall:
			ret self.buildFallSt(st.tokens)
		| lex::TokenId.Type:
			ret self.buildTypeAliasSt(st.tokens)
		| lex::TokenId.Match:
			ret self.buildMatchCase(st.tokens)
		| lex::TokenId.Unsafe:
			if len(st.tokens) < 1 {
				break
			}
			if st.tokens[1].Id == lex::TokenId.Defer ||
				st.tokens[1].Id == lex::TokenId.LBrace { // Scope.
				ret self.buildScopeSt(st.tokens)
			}
		| lex::TokenId.Defer:
			ret self.buildScopeSt(st.tokens)
		| lex::TokenId.LBrace:
			ret self.buildScopeSt(st.tokens)
		}
		mut expr := self.p.buildExpr(st.tokens)
		if expr != nil {
			ret expr
		}
		self.pushErr(token, build::LogMsg.InvalidSyntax)
		ret nil
	}

	fn build(mut self, mut &tokens: []&lex::Token, mut &s: &ast::ScopeTree) {
		if s == nil {
			ret
		}
		self.stmts = splitStmts(tokens)
		self.pos = -1 // sp.next() first increase position
		self.s = s
		for !self.isLastSt() && !self.finished() {
			mut st := self.next()
			mut data := self.buildSt(st)
			if data != nil {
				self.s.Stmts = append(self.s.Stmts, ast::Stmt{
					Token: st.tokens[0],
					Data: data,
				})
			}
			if self.stopped() {
				break
			}
		}
	}
}