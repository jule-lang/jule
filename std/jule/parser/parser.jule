// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::fs::path::{join}
use std::jule::ast::{
    Ast,
    Constraint,
    Directive,
    Expr,
    ScopeTree,
    TypeDecl,
    TypeAliasDecl,
    VarDecl,
    GenericDecl,
    ParamDecl,
    IdentTypeDecl,
    RetTypeDecl,
    TupleTypeDecl,
    FnDecl,
    UseDecl,
    EnumItemDecl,
    EnumDecl,
    TypeEnumDecl,
    TypeEnumItemDecl,
    FieldDecl,
    StructDecl,
    TraitDecl,
    NodeData,
    Impl,
    Node,
}
use std::jule::lex::{
    File,
    Token,
    TokenId,
    TokenKind,
    Ident,
    is_ignore_ident,
}
use std::jule::build::{
    DIRECTIVE_PREFIX,
    LogMsg,
    Log,
    LogKind,
    logf,
    is_std_header_path,
    is_top_directive,
}
use strings for std::strings

fn make_err(row: int, col: int, &f: &File, fmt: LogMsg, args: ...any): Log {
    ret Log{
        kind: LogKind.Error,
        row: row,
        column: col,
        path: f.path,
        text: logf(fmt, args...),
    }
}

// Returns between of open and close ranges.
// Starts selection at i.
// Increases i for each selected token.
// i points to close range token after selection.
//
// Special cases are:
//  range(i, open, close, tokens) = nil if i > tokens.len
//  range(i, open, close, tokens) = nil if tokens[i].id != TokenId.Range
//  range(i, open, close, tokens) = nil if tokens[i].kind != open
fn range(mut &i: int, open: TokenKind, close: TokenKind, mut &tokens: []&Token): []&Token {
    if i >= tokens.len {
        ret nil
    }

    let tok = tokens[i]
    if tok.id != TokenId.Range || tok.kind != open {
        ret nil
    }

    i++
    let mut range_n = 1
    let start = i
    for range_n != 0 && i < tokens.len; i++ {
        let token = tokens[i]
        if token.id == TokenId.Range {
            match token.kind {
            | open:
                range_n++
            | close:
                range_n--
            }
        }
    }

    ret tokens[start:i-1]
}

// Range_last returns last range from tokens.
// Returns tokens without range tokens and range tokens.
// Range tokens includes left and right range tokens.
//
// Special cases are;
//  range_last(tokens) = tokens, nil if tokens.len == 0
//  range_last(tokens) = tokens, nil if tokens is not has range at last
fn range_last(mut &tokens: []&Token): (cutted: []&Token, cut: []&Token) {
    if tokens.len == 0 {
        ret tokens, nil
    } else if tokens[tokens.len-1].id != TokenId.Range {
        ret tokens, nil
    }

    let mut brace_n = 0
    let mut i = tokens.len - 1
    for i >= 0; i-- {
        let token = tokens[i]
        if token.id == TokenId.Range {
            match token.kind {
            | TokenKind.RBrace
            | TokenKind.RBracket
            | TokenKind.RParent:
                brace_n++
                continue
            |:
                brace_n--
            }
        }

        if brace_n == 0 {
            ret tokens[:i], tokens[i:]
        }
    }

    ret tokens, nil
}

// Same as parts, but uses TokenKind as separator.
fn parts_kind(mut &tokens: []&Token, kind: TokenKind, expr_must: bool): ([][]&Token, []Log) {
    if tokens.len == 0 {
        ret nil, nil
    }

    let mut parts: [][]&Token = nil
    let mut errors: []Log = nil

    let mut range_n = 0
    let mut last = 0
    for i, token in tokens {
        if token.id == TokenId.Range {
            match token.kind {
            | TokenKind.LBrace
            | TokenKind.LBracket
            | TokenKind.LParent:
                range_n++
                continue
            |:
                range_n--
            }
        }

        if range_n > 0 {
            continue
        }

        if token.kind == kind {
            if expr_must && i-last <= 0 {
                let err = make_err(token.row, token.column, token.file, LogMsg.MissingExpr)
                errors = append(errors, err)
            }
            parts = append(parts, tokens[last:i])
            last = i + 1
        }
    }

    if last < tokens.len {
        parts = append(parts, tokens[last:])
    } else if !expr_must {
        parts = append(parts, [])
    }

    ret parts, errors
}

// Returns parts separated by given token identifier.
// It's skips parentheses ranges.
// Logs missing_expr if expr_must == true and not exist any expression for part.
//
// Special case is;
//  parts(tokens) = nil if tokens.len == 0
fn parts(mut &tokens: []&Token, id: TokenId, expr_must: bool): ([][]&Token, []Log) {
    if tokens.len == 0 {
        ret nil, nil
    }

    let mut parts: [][]&Token = nil
    let mut errors: []Log = nil

    let mut range_n = 0
    let mut last = 0
    for i, token in tokens {
        if token.id == TokenId.Range {
            match token.kind {
            | TokenKind.LBrace
            | TokenKind.LBracket
            | TokenKind.LParent:
                range_n++
                continue
            |:
                range_n--
            }
        }

        if range_n > 0 {
            continue
        }

        if token.id == id {
            if expr_must && i-last <= 0 {
                let err = make_err(token.row, token.column, token.file, LogMsg.MissingExpr)
                errors = append(errors, err)
            }
            parts = append(parts, tokens[last:i])
            last = i + 1
        }
    }

    if last < tokens.len {
        parts = append(parts, tokens[last:])
    } else if !expr_must {
        parts = append(parts, [])
    }

    ret parts, errors
}

fn get_close_kind_of_brace(left: str): str {
    match left {
    | TokenKind.RParent:
        ret TokenKind.LParent
    | TokenKind.RBrace:
        ret TokenKind.LBrace
    | TokenKind.RBracket:
        ret TokenKind.LBracket
    |:
        ret ""
    }
}

fn compiler_err(&token: &Token, &fmt: LogMsg, args: ...any): Log {
    ret Log{
        kind: LogKind.Error,
        row: token.row,
        column: token.column,
        path: token.file.path,
        text: logf(fmt, args...),
        line: token.file.get_row(token.row),
    }
}

unsafe fn push_suggestion(mut log: *Log, fmt: LogMsg, args: ...any) {
    log.suggestion = logf(fmt, args...)
}

fn tokstoa(&tokens: []&Token): str {
    let mut n = 0
    for _, token in tokens {
        n += token.kind.len
    }
    let mut s = make(str, n)
    for _, token in tokens {
        s += token.kind
    }
    ret s
}

struct Parser {
    ast:        &Ast
    directives: []&Directive
    errors:     []Log
}

impl Parser {
    fn stop(mut self) { self.ast = nil }
    fn stopped(self): bool { ret self.ast == nil }

    // Appends error by specified token, key and args.
    fn push_err(mut self, token: &Token, fmt: LogMsg, args: ...any) {
        self.errors = append(self.errors, compiler_err(token, fmt, args...))
    }

    // Push suggestion to last log.
    fn push_suggestion(mut self, fmt: LogMsg, args: ...any) {
        unsafe { push_suggestion(&self.errors[self.errors.len-1], fmt, args...) }
    }

    fn build_expr(mut &self, mut &tokens: []&Token): &Expr {
        let mut ep = &ExprBuilder{
            p: self,
        }
        let mut expr = ep.build_from_tokens(tokens)
        ret expr
    }

    fn build_directive(mut self, mut tokens: []&Token): &Directive {
        if tokens.len == 1 {
            self.push_err(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }

        if tokens[1].column != tokens[0].column+1 {
            self.push_err(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }

        ret &Directive{
            tag: tokens[1],
            args: tokens[2:], // Start 2 to skip '#', and tag tokens.
        }
    }

    fn push_directive(mut self, mut d: &Directive) {
        if d == nil {
            ret
        }

        // Don't append if already added this directive.
        for _, pd in self.directives {
            if d.tag.kind == pd.tag.kind {
                ret
            }
        }
        self.directives = append(self.directives, d)
    }

    fn build_scope(mut &self, mut &tokens: []&Token, mut end: &Token): &ScopeTree {
        let mut s = new_scope()
        s.end = end
        let mut sp = ScopeParser{
            p: self,
        }
        sp.build(tokens, s)
        ret s
    }

    unsafe fn __build_type(mut &self, mut &tokens: []&Token,
        mut i: *int, err: bool): (&TypeDecl, bool) {
        let mut tb = TypeBuilder{
            p: self,
            tokens: tokens,
            i: i,
            err: err,
        }
        let (mut decl, ok) = tb.build()
        ret decl, ok
    }

    // build_type builds AST model of data-type.
    unsafe fn build_type(mut &self, mut &tokens: []&Token,
        mut i: *int, err: bool): (&TypeDecl, bool) {
        let token = tokens[*i]
        let (mut t, ok) = self.__build_type(tokens, i, err)
        if err && !ok {
            self.push_err(token, LogMsg.InvalidType)
        }
        ret t, ok
    }

    fn build_type_alias_decl(mut &self, mut &tokens: []&Token): &TypeAliasDecl {
        let mut i = 1 // Skip "type" keyword.
        if i >= tokens.len {
            self.push_err(tokens[i-1], LogMsg.InvalidSyntax)
            ret nil
        }
        let mut tad = &TypeAliasDecl{
            token: tokens[1],
            ident: tokens[1].kind,
        }
        let mut token = tokens[i]
        if token.id != TokenId.Ident {
            self.push_err(token, LogMsg.InvalidSyntax)
            self.push_suggestion(LogMsg.ExpectedIdentifier)
        }
        i++
        if i >= tokens.len {
            self.push_err(tokens[i-1], LogMsg.InvalidSyntax)
            ret tad
        }
        token = tokens[i]
        if token.id != TokenId.Colon {
            self.push_err(tokens[i-1], LogMsg.InvalidSyntax)
            self.push_suggestion(LogMsg.ExpectedColon)
            ret tad
        }
        i++
        if i >= tokens.len {
            self.push_err(tokens[i-1], LogMsg.MissingType)
            ret tad
        }
        let (mut t, ok) = unsafe { self.build_type(tokens, &i, true) }
        tad.kind = t
        if ok && i < tokens.len {
            self.push_err(tokens[i], LogMsg.InvalidSyntax)
        }
        ret tad
    }

    fn build_var_type_and_expr(mut &self, mut &v: &VarDecl, mut &tokens: []&Token) {
        let mut i = 0
        let mut tok = tokens[i]
        if tok.id == TokenId.Colon {
            i++ // Skip type annotation operator (:)
            if (i >= tokens.len ||
                (tokens[i].id == TokenId.Op && tokens[i].kind == TokenKind.Eq)) {
                self.push_err(tok, LogMsg.MissingType)
                ret
            }
            let (mut t, ok) = unsafe { self.build_type(tokens, &i, true) }
            if ok {
                v.kind = t
                if i >= tokens.len {
                    ret
                }
                tok = tokens[i]
            }
        }

        if tok.id == TokenId.Op {
            if tok.kind != TokenKind.Eq {
                self.push_err(tok, LogMsg.InvalidSyntax)
                ret
            }
            let mut expr_tokens = tokens[i+1:]
            if expr_tokens.len == 0 {
                self.push_err(tok, LogMsg.MissingExpr)
                ret
            }
            v.expr = self.build_expr(expr_tokens)
        } else {
            self.push_err(tok, LogMsg.InvalidSyntax)
        }
    }

    fn build_var_common(mut &self, mut &v: &VarDecl, mut tokens: []&Token) {
        v.token = tokens[0]
        if v.token.id != TokenId.Ident {
            self.push_err(v.token, LogMsg.InvalidSyntax)
            self.push_suggestion(LogMsg.ExpectedIdentifier)
            ret
        }
        v.ident = v.token.kind
        v.kind = nil // For auto-type.
        if tokens.len > 1 {
            tokens = tokens[1:] // Remove identifier.
            self.build_var_type_and_expr(v, tokens)
        }
    }

    fn build_var_begin(mut self, mut &v: &VarDecl, mut &i: int, &tokens: []&Token) {
        let tok = tokens[i]
        match tok.id {
        | TokenId.Static:
            v.statically = true
            fall
        | TokenId.Let:
            // Initialize 1 for skip the let keyword
            i++
            if i >= tokens.len {
                self.push_err(tok, LogMsg.InvalidSyntax)
                ret
            }
            if tokens[i].id == TokenId.Mut {
                v.mutable = true
                // Skip the mut keyword
                i++
            }
        | TokenId.Const:
            i++
            v.constant = true
        |:
            self.push_err(tok, LogMsg.InvalidSyntax)
            ret
        }
        if i >= tokens.len {
            self.push_err(tok, LogMsg.InvalidSyntax)
        }
    }

    fn build_var(mut &self, mut tokens: []&Token): &VarDecl {
        let mut i = 0
        let mut v = &VarDecl{
            token: tokens[0],
        }
        self.build_var_begin(v, i, tokens)
        if i >= tokens.len {
            ret nil
        }

        tokens = tokens[i:]
        if tokens[0].id == TokenId.Op && tokens[0].kind == TokenKind.Amper {
            v.reference = true
            if tokens.len == 1 {
                ret nil
            }
            tokens = tokens[1:]
        }
        self.build_var_common(v, tokens)
        ret v
    }

    fn build_generic(mut &self, mut &tokens: []&Token): &GenericDecl {
        let mut g = &GenericDecl{
            token: tokens[0],
        }
        if g.token.id != TokenId.Ident {
            self.push_err(g.token, LogMsg.InvalidSyntax)
            self.push_suggestion(LogMsg.ExpectedIdentifier)
        }
        g.ident = g.token.kind
        if tokens.len > 1 {
            if tokens[1].id != TokenId.Colon {
                self.push_err(tokens[1], LogMsg.InvalidSyntax)
                ret nil
            }
            if tokens.len == 2 {
                self.push_err(tokens[1], LogMsg.MissingExpr)
                ret nil
            }
            let mut constraint_tokens = tokens[2:]
            let (mut parts, errors) = parts_kind(constraint_tokens, TokenKind.Vline, true)
            if errors.len > 0 {
                self.errors = append(self.errors, errors...)
                ret nil
            }
            g.constraint = &Constraint{mask: make([]&TypeDecl, 0, parts.len)}
            for (_, mut part) in parts {
                let mut i = 0
                let (mut kind, _) = unsafe { self.build_type(part, &i, true) }
                g.constraint.mask = append(g.constraint.mask, kind)
                if i < part.len {
                    self.push_err(part[i], LogMsg.InvalidSyntax)
                }
            }
        }
        ret g
    }

    fn build_generics(mut &self, mut &tokens: []&Token, &error_token: &Token): []&GenericDecl {
        if tokens.len == 0 {
            self.push_err(error_token, LogMsg.MissingExpr)
            ret nil
        }

        let (mut parts, errors) = parts(tokens, TokenId.Comma, true)
        if errors.len > 0 {
            self.errors = append(self.errors, errors...)
            ret nil
        }

        let mut generics = make([]&GenericDecl, 0, parts.len)
        for (_, mut part) in parts {
            generics = append(generics, self.build_generic(part))
        }

        ret generics
    }

    fn build_self_param(mut self, mut tokens: []&Token): &ParamDecl {
        if tokens.len == 0 {
            ret nil
        }

        let mut param = new(ParamDecl)

        // Detects mut keyword.
        let mut i = 0
        if tokens[i].id == TokenId.Mut {
            param.mutable = true
            i++
            if i >= tokens.len {
                self.push_err(tokens[i-1], LogMsg.InvalidSyntax)
                ret nil
            }
        }

        if tokens[i].kind == TokenKind.Amper {
            param.ident = TokenKind.Amper
            i++
            if i >= tokens.len {
                self.push_err(tokens[i-1], LogMsg.InvalidSyntax)
                ret nil
            }
        }

        if tokens[i].id == TokenId.Self {
            param.ident += str(TokenKind.Self)
            param.token = tokens[i]
            i++
            if i < tokens.len {
                self.push_err(tokens[i], LogMsg.InvalidSyntax)
            }
        }

        ret param
    }

    fn param_type_begin(mut self, mut &param: &ParamDecl, mut &i: int, &tokens: []&Token) {
        for i < tokens.len; i++ {
            let token = tokens[i]
            if token.id != TokenId.Op {
                ret
            } else if token.kind != TokenKind.TripleDot {
                ret
            }

            if param.variadic {
                self.push_err(token, LogMsg.AlreadyVariadic)
                continue
            }
            param.variadic = true
        }
    }

    fn build_param_type(mut &self, mut &param: &ParamDecl, mut &tokens: []&Token) {
        let mut i = 0
        self.param_type_begin(param, i, tokens)
        if i >= tokens.len {
            ret
        }

        param.kind, _ = unsafe { self.build_type(tokens, &i, true) }
        if i < tokens.len {
            self.push_err(tokens[i], LogMsg.InvalidSyntax)
        }
    }

    fn build_param_body(mut &self, mut &param: &ParamDecl, mut tokens: []&Token) {
        let mut tok = tokens[0]
        param.ident = tok.kind
        if tokens.len == 1 {
            // Just identifier token.
            ret
        } else if tokens.len < 3 {
            self.push_err(tok, LogMsg.MissingType)
            ret
        }
        if tokens[1].id != TokenId.Colon {
            self.build_param_type(param, tokens)
            ret
        }
        tokens = tokens[2:] // Skip colon
        self.build_param_type(param, tokens)
    }

    fn build_param(mut &self, mut tokens: []&Token): &ParamDecl {
        let mut param = &ParamDecl{
            token: tokens[0],
        }

        // Detects mut keyword.
        if param.token.id == TokenId.Mut {
            param.mutable = true
            if tokens.len == 1 {
                self.push_err(tokens[0], LogMsg.InvalidSyntax)
                ret nil
            }
            tokens = tokens[1:]
            param.token = tokens[0]
        }

        // Catch reference parameters.
        if tokens.len >= 3 {
            if param.token.id == TokenId.Op && param.token.kind == TokenKind.Amper {
                if tokens.len == 1 {
                    self.push_err(tokens[0], LogMsg.InvalidSyntax)
                    ret nil
                }

                if tokens[1].id == TokenId.Ident && tokens[2].id == TokenId.Colon {
                    param.reference = true
                    tokens = tokens[1:]
                    param.token = tokens[0]
                }
            }
        }

        if param.token.id != TokenId.Ident {
            // Just data type
            param.ident = Ident.Anon
            self.build_param_type(param, tokens)
        } else {
            self.build_param_body(param, tokens)
        }

        ret param
    }

    fn check_params(mut self, mut &params: []&ParamDecl) {
        for (_, mut param) in params {
            if param.is_self() || param.kind != nil {
                continue
            }
            if param.token == nil {
                self.push_err(param.token, LogMsg.MissingType)
            } else {
                param.kind = &TypeDecl{
                    token: param.token,
                    kind: &IdentTypeDecl{
                        token: param.token,
                        ident: param.token.kind,
                    },
                }
                param.ident = Ident.Anon
            }
        }
    }

    fn build_params(mut &self, mut &tokens: []&Token, method: bool): []&ParamDecl {
        let (mut parts, errs) = parts(tokens, TokenId.Comma, true)
        self.errors = append(self.errors, errs...)
        if parts.len == 0 {
            ret nil
        }

        let mut params: []&ParamDecl = nil
        if method && parts.len > 0 {
            let mut param = self.build_self_param(parts[0])
            if param != nil && param.is_self() {
                params = append(params, param)
                parts = parts[1:]
            }
        }

        for (_, mut part) in parts {
            let mut param = self.build_param(part)
            if param != nil {
                params = append(params, param)
            }
        }

        self.check_params(params)
        ret params
    }

    fn build_multi_ret_type(mut &self, mut &tokens: []&Token, mut &i: int): (t: &RetTypeDecl, ok: bool) {
        t = new(RetTypeDecl)
        i++
        if i >= tokens.len {
            i--
            t.kind, ok = unsafe { self.build_type(tokens, &i, false) }
            ret
        }

        i-- // For point to parentheses - ( -
        let mut range_tokens = range(i, TokenKind.LParent, TokenKind.RParent, tokens)

        let (mut parts, errs) = parts(range_tokens, TokenId.Comma, true)
        self.errors = append(self.errors, errs...)
        if parts.len == 0 {
            ret
        }

        let mut types = make([]&TypeDecl, 0, parts.len)
        t.idents = make([]&Token, 0, parts.len)
        for (_, mut part) in parts {
            let mut token = part[0]
            let mut offset = 0

            // Check type annotation.
            if part.len > 1 {
                token = part[1]
                if token.id == TokenId.Colon {
                    offset = 2
                    if part.len < 3 {
                        self.push_err(token, LogMsg.MissingType)
                        continue
                    }
                }
            }

            token = part[0]
            if offset != 2 {
                let mut new_token = new(Token, *token)
                new_token.kind = Ident.Anon
                t.idents = append(t.idents, new_token)
            } else {
                t.idents = append(t.idents, token)
            }

            let (mut tk, _) = unsafe { self.build_type(part, &offset, true) }
            if offset < part.len {
                self.push_err(part[offset], LogMsg.InvalidSyntax)
            }
            types = append(types, tk)
        }

        if types.len > 1 {
            t.kind = &TypeDecl{
                token: tokens[0],
                kind: &TupleTypeDecl{
                    types: types,
                },
            }
        } else {
            t.kind = types[0]
        }

        ok = true
        ret
    }

    // Builds function return type from tokens.
    fn build_ret_type(mut &self, mut &tokens: []&Token, mut &i: int): (t: &RetTypeDecl, ok: bool) {
        t = new(RetTypeDecl)
        if i >= tokens.len {
            ret
        }

        let mut token = tokens[i]
        match token.id {
        | TokenId.Range:
            if token.kind == TokenKind.LBrace {
                ret
            }
        | TokenId.Op:
            if token.kind == TokenKind.Eq {
                ret
            }
        | TokenId.Colon:
            if i+1 >= tokens.len {
                self.push_err(token, LogMsg.MissingType)
                ret
            }

            i++
            token = tokens[i]
            if token.id == TokenId.Range {
                match token.kind {
                | TokenKind.LParent:
                    t, ok = self.build_multi_ret_type(tokens, i)
                    ret
                | TokenKind.LBrace:
                    self.push_err(token, LogMsg.MissingType)
                    ret
                }
            }
            t.kind, ok = unsafe { self.build_type(tokens, &i, true) }
            ret
        }
        i++
        self.push_err(token, LogMsg.InvalidSyntax)
        ret
    }

    // Build function prototype.
    // Body is not necessary for successfull parsing.
    // Just declration.
    fn build_fn_prototype(mut &self, mut &tokens: []&Token, mut &i: int, method: bool): &FnDecl {
        let mut f = &FnDecl{
            token: tokens[i],
        }

        // Detect static keyword.
        if f.token.id == TokenId.Static {
            f.statically = true
            i++
            if i >= tokens.len {
                self.push_err(f.token, LogMsg.InvalidSyntax)
                ret nil
            }
            f.token = tokens[i]
        }

        // Detect unsafe keyword.
        if f.token.id == TokenId.Unsafe {
            f.unsafety = true
            i++
            if i >= tokens.len {
                self.push_err(f.token, LogMsg.InvalidSyntax)
                ret nil
            }
            f.token = tokens[i]
        }

        // Skips fn token.
        i++
        if i >= tokens.len {
            self.push_err(f.token, LogMsg.InvalidSyntax)
            ret nil
        }

        let tok = tokens[i]
        if tok.id == TokenId.Ident {
            i++
            if i >= tokens.len {
                self.push_err(f.token, LogMsg.InvalidSyntax)
                ret nil
            }
            f.ident = tok.kind
        } else {
            f.ident = Ident.Anon
        }

        let error_token = tokens[i]
        let mut generics_tokens = range(i, TokenKind.LBracket, TokenKind.RBracket, tokens)
        if generics_tokens != nil {
            f.generics = self.build_generics(generics_tokens, error_token)
        }

        if tokens[i].kind != TokenKind.LParent {
            self.push_err(tokens[i], LogMsg.MissingFnParentheses)
            ret nil
        }

        let mut params_toks = range(i, TokenKind.LParent, TokenKind.RParent, tokens)
        if params_toks.len > 0 {
            f.params = self.build_params(params_toks, method)
        }

        if i < tokens.len {
            let token = tokens[i]
            if token.id == TokenId.Op && token.kind == TokenKind.Excl {
                f.exceptional = true
                i++
            }
        }

        f.result, _ = self.build_ret_type(tokens, i)
        ret f
    }

    // Parses function define.
    // Prototype and body.
    fn build_fn(mut &self, mut &tokens: []&Token, method: bool, prototype: bool): &FnDecl {
        let mut i = 0
        let mut f = self.build_fn_prototype(tokens, i, method)
        if prototype {
            if i < tokens.len {
                self.push_err(tokens[i+1], LogMsg.InvalidSyntax)
            }
            ret f
        } else if f == nil {
            ret f
        }

        if i >= tokens.len {
            self.stop()
            self.push_err(f.token, LogMsg.BodyNotExist)
            self.push_suggestion(LogMsg.ExpectedBody)
            ret nil
        }
        let mut block_tokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if block_tokens != nil {
            f.scope = self.build_scope(block_tokens, tokens[i-1])
            f.scope.unsafety = f.unsafety
            if i < tokens.len {
                self.push_err(tokens[i], LogMsg.InvalidSyntax)
            }
        } else {
            self.stop()
            self.push_err(f.token, LogMsg.BodyNotExist)
            self.push_suggestion(LogMsg.ExpectedBody)
            ret nil
        }
        ret f
    }

    fn get_use_decl_selectors(mut self, mut tokens: []&Token): []&Token {
        let mut i = 0
        tokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        let (mut parts, errs) = parts(tokens, TokenId.Comma, true)
        if errs.len > 0 {
            self.errors = append(self.errors, errs...)
            ret nil
        }

        let mut selectors = make([]&Token, 0, parts.len)
        for (_, mut part) in parts {
            if part.len > 1 {
                self.push_err(part[1], LogMsg.InvalidSyntax)
            }
            let mut tok = part[0]
            if tok.id != TokenId.Ident && tok.id != TokenId.Self {
                self.push_err(tok, LogMsg.InvalidSyntax)
                self.push_suggestion(LogMsg.ExpectedIdentifier)
                continue
            }
            selectors = append(selectors, tok)
        }
        ret selectors
    }

    fn build_cpp_use_decl(mut self, mut &decl: &UseDecl, &tokens: []&Token) {
        if tokens.len > 1 {
            self.push_err(tokens[1], LogMsg.InvalidSyntax)
        }
        let token = tokens[0]
        if token.id != TokenId.Lit || (token.kind[0] != '`' && token.kind[0] != '"') {
            self.push_err(token, LogMsg.InvalidExpr)
            ret
        }
        decl.cpp_linked = true
        decl.link_path = token.kind[1:token.kind.len-1]
    }

    fn build_std_use_decl(mut self, mut &decl: &UseDecl, mut tokens: []&Token) {
        decl.std = true

        let mut token = tokens[0]
        if tokens.len < 3 {
            self.push_err(token, LogMsg.InvalidSyntax)
            ret
        }

        tokens = tokens[2:]
        token = tokens[tokens.len-1]
        match token.id {
        | TokenId.DblColon:
            self.push_err(token, LogMsg.InvalidSyntax)
            ret
        | TokenId.Range:
            if token.kind != TokenKind.RBrace {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }
            let mut selectors: []&Token = nil
            tokens, selectors = range_last(tokens)
            decl.selected = self.get_use_decl_selectors(selectors)
            if tokens.len == 0 {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }
            token = tokens[tokens.len-1]
            if token.id != TokenId.DblColon {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }
            tokens = tokens[:tokens.len-1]
            if tokens.len == 0 {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }
        | TokenId.Op:
            if token.kind != TokenKind.Star {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }
            tokens = tokens[:tokens.len-1]
            if tokens.len == 0 {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }
            token = tokens[tokens.len-1]
            if token.id != TokenId.DblColon {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }
            tokens = tokens[:tokens.len-1]
            if tokens.len == 0 {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }
            decl.full = true
        }
        decl.link_path = "std::" + tokstoa(tokens)
    }

    fn build_ident_use_decl(mut self, mut &decl: &UseDecl, mut tokens: []&Token) {
        decl.std = false

        let mut token = tokens[tokens.len-1]
        match token.id {
        | TokenId.DblColon:
            self.push_err(token, LogMsg.InvalidSyntax)
            ret
        | TokenId.Range:
            if token.kind != TokenKind.RBrace {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }

            let mut selectors: []&Token = nil
            tokens, selectors = range_last(tokens)
            decl.selected = self.get_use_decl_selectors(selectors)
            if tokens.len == 0 {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }

            token = tokens[tokens.len-1]
            if token.id != TokenId.DblColon {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }

            tokens = tokens[:tokens.len-1]
            if tokens.len == 0 {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }
        | TokenId.Op:
            if token.kind != TokenKind.Star {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }

            tokens = tokens[:tokens.len-1]
            if tokens.len == 0 {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }

            token = tokens[tokens.len-1]
            if token.id != TokenId.DblColon {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }

            tokens = tokens[:tokens.len-1]
            if tokens.len == 0 {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret
            }

            decl.full = true
        }

        decl.link_path = tokstoa(tokens)
    }

    fn parse_use_decl(mut self, mut &decl: &UseDecl, mut tokens: []&Token) {
        if decl.cpp_linked {
            self.build_cpp_use_decl(decl, tokens)
            ret
        }

        let mut token = tokens[0]
        if token.id != TokenId.Ident {
            self.push_err(token, LogMsg.InvalidSyntax)
            self.push_suggestion(LogMsg.ExpectedIdentifier)
            ret
        }

        if tokens.len > 2 && tokens[1].id == TokenId.For {
            decl.alias = token.kind
            if tokens[2].id != TokenId.Ident {
                self.push_err(token, LogMsg.InvalidSyntax)
                self.push_suggestion(LogMsg.ExpectedIdentifier)
                ret
            }
            tokens = tokens[2:]
            token = tokens[0]
        }

        const STD_LIB_PREFIX = "std"

        match {
        | token.kind == STD_LIB_PREFIX:
            self.build_std_use_decl(decl, tokens)
        |:
            self.build_ident_use_decl(decl, tokens)
        }
    }

    fn build_use_decl(mut self, mut tokens: []&Token, cpp_linked: bool): &UseDecl {
        let mut decl = &UseDecl{
            token: tokens[0],
            cpp_linked: cpp_linked,
        }
        if tokens.len < 2 {
            self.push_err(decl.token, LogMsg.MissingUsePath)
            ret nil
        }
        tokens = tokens[1:] // Skip "use" keyword.
        self.parse_use_decl(decl, tokens)
        ret decl
    }

    fn build_type_enum_item_kind(mut &self, mut &i: int, mut &tokens: []&Token): &TypeDecl {
        let mut brace_n = 0
        let expr_start = i
        for i < tokens.len; i++ {
            let t = tokens[i]
            if t.id == TokenId.Range {
                match t.kind {
                | TokenKind.LBrace
                | TokenKind.LBracket
                | TokenKind.LParent:
                    brace_n++
                    continue
                |:
                    brace_n--
                }
            }
            if brace_n > 0 {
                continue
            }
            if t.id == TokenId.Comma || i+1 >= tokens.len {
                let mut kind_tokens: []&Token = nil
                if t.id == TokenId.Comma {
                    kind_tokens = tokens[expr_start:i]
                } else {
                    kind_tokens = tokens[expr_start:]
                }
                let mut j = 0
                let (mut kind, _) = unsafe { self.build_type(kind_tokens, &j, true) }
                if j < kind_tokens.len {
                    self.push_err(kind_tokens[j], LogMsg.InvalidSyntax)
                }
                ret kind
            }
        }
        ret nil
    }

    fn build_type_enum_items(mut &self, mut &tokens: []&Token): []&TypeEnumItemDecl {
        let mut items = make([]&TypeEnumItemDecl, 0, 1)
        let mut i = 0
        for i < tokens.len; i++ {
            let mut t = tokens[i]
            let mut item = new(TypeEnumItemDecl)
            item.token = t
            if item.token.id == TokenId.Ident && tokens.len - i > 2 {
                item.ident = item.token.kind
                t = tokens[i+1]
                if t.id == TokenId.Colon {
                    i += 2
                    if i >= tokens.len || tokens[i].id == TokenId.Comma {
                        self.push_err(t, LogMsg.MissingType)
                        continue
                    }
                }
            }
            item.kind = self.build_type_enum_item_kind(i, tokens)
            items = append(items, item)
        }
        ret items
    }

    fn build_type_enum_decl(mut &self, mut &tokens: []&Token): &TypeEnumDecl {
        let mut i = 1 // Skip "enum" tokens.
        let mut e = &TypeEnumDecl{
            token: tokens[i],
        }
        if e.token.id != TokenId.Ident {
            self.push_err(e.token, LogMsg.InvalidSyntax)
            self.push_suggestion(LogMsg.ExpectedIdentifier)
        }
        e.ident = e.token.kind
        i += 3 // Skip "identifier: type" tokens.
        let mut item_tokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if item_tokens == nil {
            self.stop()
            self.push_err(e.token, LogMsg.BodyNotExist)
            self.push_suggestion(LogMsg.ExpectedBody)
            ret e
        } else if i < tokens.len {
            self.push_err(tokens[i], LogMsg.InvalidSyntax)
        }
        e.end = tokens[i-1]
        e.items = self.build_type_enum_items(item_tokens)
        ret e
    }

    fn build_enum_item_expr(mut &self, mut &i: int, mut &tokens: []&Token): &Expr {
        let mut brace_n = 0
        let expr_start = i
        for i < tokens.len; i++ {
            let t = tokens[i]
            if t.id == TokenId.Range {
                match t.kind {
                | TokenKind.LBrace
                | TokenKind.LBracket
                | TokenKind.LParent:
                    brace_n++
                    continue
                |:
                    brace_n--
                }
            }
            if brace_n > 0 {
                continue
            }
            if t.id == TokenId.Comma || i+1 >= tokens.len {
                let mut expr_tokens: []&Token = nil
                if t.id == TokenId.Comma {
                    expr_tokens = tokens[expr_start:i]
                } else {
                    expr_tokens = tokens[expr_start:]
                }
                ret self.build_expr(expr_tokens)
            }
        }
        ret nil
    }

    fn build_enum_items(mut &self, mut &tokens: []&Token): []&EnumItemDecl {
        let mut items = make([]&EnumItemDecl, 0, 1)
        let mut i = 0
        for i < tokens.len; i++ {
            let mut t = tokens[i]
            let mut item = new(EnumItemDecl)
            item.token = t
            if item.token.id != TokenId.Ident {
                self.push_err(item.token, LogMsg.InvalidSyntax)
                self.push_suggestion(LogMsg.ExpectedIdentifier)
            }
            item.ident = item.token.kind
            if i+1 >= tokens.len || tokens[i+1].id == TokenId.Comma {
                if i+1 < tokens.len {
                    i++
                }
                items = append(items, item)
                continue
            }
            i++
            t = tokens[i]
            i++
            if t.id != TokenId.Colon {
                self.push_err(t, LogMsg.InvalidSyntax)
                self.push_suggestion(LogMsg.ExpectedColonForAssign)
                continue
            }
            if i >= tokens.len || tokens[i].id == TokenId.Comma {
                self.push_err(t, LogMsg.MissingExpr)
                continue
            }
            item.expr = self.build_enum_item_expr(i, tokens)
            items = append(items, item)
        }
        ret items
    }

    fn build_enum_decl(mut &self, mut &tokens: []&Token): &EnumDecl {
        if tokens.len < 3 {
            self.push_err(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }
        let mut e = &EnumDecl{
            token: tokens[1],
        }
        if e.token.id != TokenId.Ident {
            self.push_err(e.token, LogMsg.InvalidSyntax)
            self.push_suggestion(LogMsg.ExpectedIdentifier)
        }
        e.ident = e.token.kind
        let mut i = 2
        if tokens[i].id == TokenId.Colon {
            i++
            if i >= tokens.len {
                self.push_err(tokens[i-1], LogMsg.InvalidSyntax)
                ret e
            }
            e.kind, _ = unsafe { self.build_type(tokens, &i, true) }
            if i >= tokens.len {
                self.stop()
                self.push_err(e.token, LogMsg.BodyNotExist)
                self.push_suggestion(LogMsg.ExpectedBody)
                ret e
            }
        } else {
            e.kind = nil
        }
        let mut item_tokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if item_tokens == nil {
            self.stop()
            self.push_err(e.token, LogMsg.BodyNotExist)
            self.push_suggestion(LogMsg.ExpectedBody)
            ret e
        } else if i < tokens.len {
            self.push_err(tokens[i], LogMsg.InvalidSyntax)
        }
        e.end = tokens[i-1]
        e.items = self.build_enum_items(item_tokens)
        ret e
    }

    fn build_node_enum_decl(mut &self, mut &tokens: []&Token): NodeData {
        if tokens.len > 3 && tokens[2].id == TokenId.Colon {
            if tokens[3].id == TokenId.Type {
                ret self.build_type_enum_decl(tokens)
            }
        }
        ret self.build_enum_decl(tokens)
    }

    fn build_field(mut &self, mut tokens: []&Token): &FieldDecl {
        let mut f = &FieldDecl{}

        f.public = tokens[0].id == TokenId.Pub
        if f.public {
            if tokens.len == 1 {
                self.push_err(tokens[0], LogMsg.InvalidSyntax)
                ret nil
            }
            tokens = tokens[1:]
        }

        f.mutable = tokens[0].id == TokenId.Mut
        if f.mutable {
            if tokens.len == 1 {
                self.push_err(tokens[0], LogMsg.InvalidSyntax)
                ret nil
            }
            tokens = tokens[1:]
        }

        f.token = tokens[0]
        if f.token.id != TokenId.Ident {
            self.push_err(f.token, LogMsg.InvalidSyntax)
            self.push_suggestion(LogMsg.ExpectedIdentifier)
            ret nil
        }
        f.ident = f.token.kind

        if tokens.len == 1 {
            self.push_err(tokens[0], LogMsg.MissingType)
            ret nil
        } else if tokens[1].id != TokenId.Colon {
            self.push_err(tokens[1], LogMsg.MissingType)
            ret nil
        }

        tokens = tokens[2:] // Remove identifier and colon tokens.
        let mut i = 0
        f.kind, _ = unsafe { self.build_type(tokens, &i, true) }
        if i < tokens.len {
            let token = tokens[i]
            if token.id != TokenId.Op || token.kind != TokenKind.Eq {
                self.push_err(tokens[i], LogMsg.InvalidSyntax)
                ret nil
            }
            i++
            if i >= tokens.len {
                self.push_err(token, LogMsg.MissingExpr)
                ret nil
            }
            tokens = tokens[i:]
            f.default = self.build_expr(tokens)
        }

        ret f
    }

    fn build_struct_decl_fields(mut &self, mut tokens: []&Token): []&FieldDecl {
        let mut fields: []&FieldDecl = nil
        let mut stmts = split_stmts(tokens)
        for (_, mut stmt) in stmts {
            tokens = stmt.tokens
            let mut f = self.build_field(tokens)
            fields = append(fields, f)
        }
        ret fields
    }

    fn build_struct_decl(mut &self, mut &tokens: []&Token): &StructDecl {
        if tokens.len < 3 {
            self.push_err(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }

        let mut i = 1
        let mut s = &StructDecl{
            token: tokens[i],
        }
        if s.token.id != TokenId.Ident {
            self.push_err(s.token, LogMsg.InvalidSyntax)
            self.push_suggestion(LogMsg.ExpectedIdentifier)
        }
        i++
        if i >= tokens.len {
            self.push_err(tokens[i], LogMsg.InvalidSyntax)
            ret s
        }
        s.ident = s.token.kind

        let error_token = tokens[i]
        let mut generics_tokens = range(i, TokenKind.LBracket, TokenKind.RBracket, tokens)
        if generics_tokens != nil {
            s.generics = self.build_generics(generics_tokens, error_token)
        }
        if i >= tokens.len {
            self.push_err(tokens[i-1], LogMsg.BodyNotExist)
            self.push_suggestion(LogMsg.ExpectedBody)
            ret s
        }

        let mut body_tokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if body_tokens == nil {
            self.stop()
            self.push_err(s.token, LogMsg.BodyNotExist)
            self.push_suggestion(LogMsg.ExpectedBody)
            ret s
        }
        if i < tokens.len {
            self.push_err(tokens[i], LogMsg.InvalidSyntax)
        }
        s.fields = self.build_struct_decl_fields(body_tokens)
        s.end = tokens[i-1]
        ret s
    }

    fn check_method_receiver(mut self, &f: &FnDecl) {
        // Static methods cannot have receiver.
        if f.statically {
            if f.params.len > 0 && f.params[0].is_self() {
                self.push_err(f.token, LogMsg.StaticFnHasReceiver)
            }
            ret
        }

        if f.params.len == 0 {
            self.push_err(f.token, LogMsg.MissingReceiver)
            ret
        }
        let param = f.params[0]
        if !param.is_self() {
            self.push_err(f.token, LogMsg.MissingReceiver)
            ret
        }
    }

    fn build_trait_methods(mut &self, mut tokens: []&Token): []&FnDecl {
        let mut methods: []&FnDecl = nil
        let mut stmts = split_stmts(tokens)
        for (_, mut stmt) in stmts {
            tokens = stmt.tokens
            if tokens.len == 0 {
                continue
            }

            let mut is_pub = false
            if tokens[0].id == TokenId.Pub {
                is_pub = true
                if tokens.len == 1 {
                    self.push_err(tokens[0], LogMsg.InvalidSyntax)
                    continue
                }
                tokens = tokens[1:]
            }

            let mut f = self.build_fn(tokens, true, true)
            if f != nil {
                if f.is_anon() {
                    self.push_err(f.token, LogMsg.InvalidSyntax)
                }
                self.check_method_receiver(f)
                if f.generics.len > 0 {
                    self.push_err(f.token, LogMsg.TraitMethodHasGenerics)
                }
                f.public = is_pub
                methods = append(methods, f)
            }
        }
        ret methods
    }

    fn build_trait_decl(mut &self, mut &tokens: []&Token): &TraitDecl {
        if tokens.len < 3 {
            self.push_err(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }
        let mut t = &TraitDecl{
            token: tokens[1],
        }
        if t.token.id != TokenId.Ident {
            self.push_err(t.token, LogMsg.InvalidSyntax)
            self.push_suggestion(LogMsg.ExpectedIdentifier)
        }
        t.ident = t.token.kind
        let mut i = 2
        let mut body_tokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if body_tokens == nil {
            self.stop()
            self.push_err(t.token, LogMsg.BodyNotExist)
            self.push_suggestion(LogMsg.ExpectedBody)
            ret nil
        }
        if i < tokens.len {
            self.push_err(tokens[i], LogMsg.InvalidSyntax)
        }
        t.methods = self.build_trait_methods(body_tokens)
        t.end = tokens[i-1]
        ret t
    }

    fn build_cpp_link_fn(mut &self, mut tokens: []&Token): &FnDecl {
        tokens = tokens[1:] // Remove "cpp" keyword.
        let mut f = self.build_fn(tokens, false, true)
        if f != nil {
            if f.is_anon() {
                self.push_err(f.token, LogMsg.InvalidSyntax)
            }
            f.cpp_linked = true
        }
        ret f
    }

    fn build_cpp_link_var(mut &self, mut tokens: []&Token): &VarDecl {
        tokens = tokens[1:] // Remove "cpp" keyword.
        let mut v = self.build_var(tokens)
        if v != nil {
            v.cpp_linked = true
            if v.expr != nil {
                self.push_err(v.token, LogMsg.CppLinkedVarHasExpr)
            }
        }
        ret v
    }

    fn build_cpp_link_struct(mut &self, mut tokens: []&Token): &StructDecl {
        tokens = tokens[1:] // Remove "cpp" keyword.
        let mut s = self.build_struct_decl(tokens)
        if s != nil {
            s.cpp_linked = true
        }
        ret s
    }

    fn build_cpp_link_type_alias(mut &self, mut tokens: []&Token): &TypeAliasDecl {
        tokens = tokens[1:] // Remove "cpp" keyword.
        let mut t = self.build_type_alias_decl(tokens)
        if t != nil {
            t.cpp_linked = true
        }
        ret t
    }

    fn build_cpp_link_use(mut &self, mut tokens: []&Token): &UseDecl {
        if tokens.len == 1 {
            self.push_err(tokens[0], LogMsg.InvalidSyntax)
            ret nil
        }
        tokens = tokens[1:] // Remove the "cpp" keyword.

        const CPP_LINKED = true
        ret self.build_use_decl(tokens, CPP_LINKED)
    }

    fn build_cpp_link(mut &self, mut &tokens: []&Token): NodeData {
        let mut token = tokens[0]
        if tokens.len == 1 {
            self.push_err(token, LogMsg.InvalidSyntax)
            ret nil
        }
        token = tokens[1]
        match token.id {
        | TokenId.Fn
        | TokenId.Unsafe:
            ret self.build_cpp_link_fn(tokens)
        | TokenId.Const
        | TokenId.Let:
            ret self.build_cpp_link_var(tokens)
        | TokenId.Struct:
            ret self.build_cpp_link_struct(tokens)
        | TokenId.Type:
            ret self.build_cpp_link_type_alias(tokens)
        |:
            self.push_err(token, LogMsg.InvalidSyntax)
        }
        ret nil
    }

    fn get_method(mut &self, mut &tokens: []&Token): &FnDecl {
        let mut i = 0
        let mut token = tokens[i]
        if token.id == TokenId.Static {
            if i+1 >= tokens.len {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret nil
            }
            i++
            token = tokens[i]
        }

        if token.id == TokenId.Unsafe {
            if i+1 >= tokens.len {
                self.push_err(token, LogMsg.InvalidSyntax)
                ret nil
            }
            i++
            token = tokens[i]
        }

        if token.id != TokenId.Fn {
            self.push_err(token, LogMsg.InvalidSyntax)
            ret nil
        }

        let mut f = self.build_fn(tokens, true, false)
        if f != nil && f.is_anon() {
            self.push_err(f.token, LogMsg.InvalidSyntax)
        }
        ret f
    }

    fn parse_impl_body(mut &self, mut &ipl: &Impl, mut &tokens: []&Token) {
        let mut stmts = split_stmts(tokens)
        for (_, mut stmt) in stmts {
            tokens = stmt.tokens
            let mut token = tokens[0]
            let mut is_pub = false
            match token.id {
            | TokenId.Hash:
                self.push_directive(self.build_directive(tokens))
                continue
            | TokenId.Pub:
                is_pub = true
                if tokens.len == 1 {
                    self.push_err(tokens[0], LogMsg.InvalidSyntax)
                    continue
                }
                tokens = tokens[1:]
                if tokens.len > 0 {
                    token = tokens[0]
                }
            }

            match token.id {
            | TokenId.Const:
                let mut v = self.build_var(tokens)
                if v != nil {
                    v.public = is_pub
                    ipl.statics = append(ipl.statics, v)
                }
            | TokenId.Static
            | TokenId.Fn
            | TokenId.Unsafe:
                let mut f = self.get_method(tokens)
                if f != nil {
                    self.check_method_receiver(f)
                    self.apply_fn_meta(f, is_pub)
                    ipl.methods = append(ipl.methods, f)
                }
            |:
                self.push_err(token, LogMsg.InvalidSyntax)
                continue
            }
        }
    }

    fn build_impl(mut &self, mut tokens: []&Token): &Impl {
        let mut token = tokens[0]
        if tokens.len < 2 {
            self.push_err(token, LogMsg.InvalidSyntax)
            ret nil
        }

        let mut i = 1

        let (mut base, mut ok) = unsafe { self.build_type(tokens, &i, true) }
        if !ok {
            ret nil
        }
        if i >= tokens.len {
            self.push_err(token, LogMsg.InvalidSyntax)
            ret nil
        }

        let mut ipl = &Impl{
            base: base,
        }

        token = tokens[i]
        if token.id != TokenId.For {
            if token.id == TokenId.Range && token.kind == TokenKind.LBrace {
                // This implementation is single.
                // Just implements to destination.
                // Therefore, swap Base and Dest tokens.
                ipl.base, ipl.dest = ipl.dest, ipl.base

                goto body
            }

            self.stop()
            self.push_err(token, LogMsg.BodyNotExist)
            self.push_suggestion(LogMsg.ExpectedBody)
            ret nil
        }
        i++
        if i >= tokens.len {
            self.stop()
            self.push_err(token, LogMsg.BodyNotExist)
            self.push_suggestion(LogMsg.ExpectedBody)
            ret nil
        }

        ipl.dest, ok = unsafe { self.build_type(tokens, &i, true) }
        if !ok {
            ret nil
        }
        if i >= tokens.len {
            self.stop()
            self.push_err(token, LogMsg.BodyNotExist)
            self.push_suggestion(LogMsg.ExpectedBody)
            ret nil
        }

    body:
        let mut body_tokens = range(i, TokenKind.LBrace, TokenKind.RBrace, tokens)
        if body_tokens == nil {
            self.stop()
            self.push_err(token, LogMsg.BodyNotExist)
            self.push_suggestion(LogMsg.ExpectedBody)
            ret nil
        }
        if i < tokens.len {
            self.push_err(tokens[i], LogMsg.InvalidSyntax)
        }
        ipl.end = tokens[i-1]
        self.parse_impl_body(ipl, body_tokens)
        ret ipl
    }

    fn build_node_data(mut &self, mut &tokens: []&Token): NodeData {
        let mut token = tokens[0]
        match token.id {
        | TokenId.Fn
        | TokenId.Unsafe:
            let mut f = self.build_fn(tokens, false, false)
            if f != nil {
                f.global = true
                if f.is_anon() {
                    self.push_err(f.token, LogMsg.InvalidSyntax)
                }
            }
            ret f
        | TokenId.Let
        | TokenId.Const
        | TokenId.Mut
        | TokenId.Static:
            ret self.build_var(tokens)
        | TokenId.Type:
            ret self.build_type_alias_decl(tokens)
        | TokenId.Enum:
            ret self.build_node_enum_decl(tokens)
        | TokenId.Struct:
            ret self.build_struct_decl(tokens)
        | TokenId.Trait:
            ret self.build_trait_decl(tokens)
        | TokenId.Impl:
            ret self.build_impl(tokens)
        | TokenId.Cpp:
            ret self.build_cpp_link(tokens)
        |:
            self.push_err(token, LogMsg.InvalidSyntax)
            ret nil
        }
    }

    fn apply_fn_meta(mut self, mut &f: &FnDecl, is_pub: bool) {
        f.public = is_pub
        f.directives = self.directives
        self.directives = nil
    }

    fn apply_meta(mut self, mut &node: Node, is_pub: bool) {
        match type node.data {
        | &VarDecl:
            let mut v = (&VarDecl)(node.data)
            if v == nil {
                ret
            }
            v.public = is_pub
            v.directives = self.directives
            self.directives = nil
        | &FnDecl:
            let mut f = (&FnDecl)(node.data)
            if f == nil {
                ret
            }
            self.apply_fn_meta(f, is_pub)
        | &TypeAliasDecl:
            let mut tad = (&TypeAliasDecl)(node.data)
            if tad == nil {
                ret
            }
            tad.public = is_pub
        | &EnumDecl:
            let mut ed = (&EnumDecl)(node.data)
            if ed == nil {
                ret
            }
            ed.public = is_pub
        | &TypeEnumDecl:
            let mut ted = (&TypeEnumDecl)(node.data)
            if ted == nil {
                ret
            }
            ted.public = is_pub
        | &StructDecl:
            let mut sd = (&StructDecl)(node.data)
            if sd == nil {
                ret
            }
            sd.directives = self.directives
            self.directives = nil
            sd.public = is_pub
        | &TraitDecl:
            let mut td = (&TraitDecl)(node.data)
            if td == nil {
                ret
            }
            td.public = is_pub
        |:
            if is_pub {
                self.push_err(node.token, LogMsg.DefNotSupportPub)
            }
        }
    }

    fn build_general_scope_node_data(mut &self, mut st: []&Token): (is_pub: bool, data: NodeData) {
        // Detect pub keyword.
        if st[0].id == TokenId.Pub {
            is_pub = true
            st = st[1:]
            if st.len == 0 {
                self.push_err(st[0], LogMsg.InvalidSyntax)
                ret
            }
        }

        data = self.build_node_data(st)
        ret is_pub, data
    }

    fn push_use_decl(mut &self, mut &decl: &UseDecl) {
        self.ast.use_decls = append(self.ast.use_decls, decl)
        if self.ast.nodes.len > 0 {
            self.push_err(decl.token, LogMsg.UseDeclAtBody)
            self.push_suggestion(LogMsg.MoveUseDeclToTopOfFile)
        }
    }

    fn push_meta_nodes(mut &self, mut &tokens: []&Token): bool {
        match tokens[0].id {
        | TokenId.Use:
            const CPP_LINKED = false
            let mut decl = self.build_use_decl(tokens, CPP_LINKED)
            self.push_use_decl(decl)
            ret true
        | TokenId.Cpp:
            if tokens.len > 1 && tokens[1].id == TokenId.Use {
                let mut decl = self.build_cpp_link_use(tokens)
                self.push_use_decl(decl)
                ret true
            }
        | TokenId.Hash:
            self.push_directive(self.build_directive(tokens))
            ret true
        }
        ret false
    }

    fn parse_node(mut &self, mut &st: []&Token): Node {
        let mut node = Node{
            token: st[0],
        }

        if self.push_meta_nodes(st) {
            ret node
        }

        let (is_pub, mut data) = self.build_general_scope_node_data(st)
        if data == nil {
            ret node
        }

        node.data = data

        self.apply_meta(node, is_pub)
        if self.directives.len != 0 {
            self.push_err(self.directives[0].tag, LogMsg.UnusedDirective)
        }
        self.directives = nil
        ret node
    }

    fn append_node(mut &self, mut &st: []&Token) {
        if st.len == 0 {
            ret
        }

        let mut node = self.parse_node(st)
        if node.data == nil || self.stopped() {
            ret
        }
        self.ast.nodes = append(self.ast.nodes, node)
    }

    fn remove_range(self, mut i: int, kind: str, &tokens: []&Token, mut &ranges: []int) {
        let close = get_close_kind_of_brace(kind)
        for i >= 0; i-- {
            let tok = tokens[ranges[i]]
            if tok.kind != close {
                continue
            }
            ranges = append(ranges[:i], ranges[i+1:]...)
            break
        }
    }

    fn push_wrong_order_close_err(mut self, &t: &Token, &tokens: []&Token, &ranges: []int) {
        match tokens[ranges[ranges.len-1]].kind {
        | TokenKind.LParent:
            self.push_err(t, LogMsg.ExpectedParentClose)
        | TokenKind.LBrace:
            self.push_err(t, LogMsg.ExpectedBraceClose)
        | TokenKind.LBracket:
            self.push_err(t, LogMsg.ExpectedBracketClose)
        }
    }

    fn push_range_close(mut self, t: &Token, left: str, &tokens: []&Token, mut &ranges: []int) {
        let n = ranges.len
        if n == 0 {
            match t.kind {
            | TokenKind.RBracket:
                self.push_err(t, LogMsg.ExtraClosedBracket)
            | TokenKind.RBrace:
                self.push_err(t, LogMsg.ExtraClosedBrace)
            | TokenKind.RParent:
                self.push_err(t, LogMsg.ExtraClosedParent)
            }
            ret
        } else if tokens[ranges[n-1]].kind != left {
            self.push_wrong_order_close_err(t, tokens, ranges)
        }
        self.remove_range(n - 1, t.kind, tokens, ranges)
    }

    fn check_ranges(mut self, &tokens: []&Token) {
        let mut ranges: []int = nil

        for i, token in tokens {
            if token.id != TokenId.Range {
                continue
            }
            match token.kind {
            | TokenKind.LParent
            | TokenKind.LBrace
            | TokenKind.LBracket:
                ranges = append(ranges, i)
            | TokenKind.RParent:
                self.push_range_close(token, TokenKind.LParent, tokens, ranges)
            | TokenKind.RBrace:
                self.push_range_close(token, TokenKind.LBrace, tokens, ranges)
            | TokenKind.RBracket:
                self.push_range_close(token, TokenKind.LBracket, tokens, ranges)
            }
        }

        for _, i in ranges {
            let token = tokens[i]
            match token.kind {
            | TokenKind.LParent:
                self.push_err(token, LogMsg.WaitCloseParent)
            | TokenKind.LBrace:
                self.push_err(token, LogMsg.WaitCloseBrace)
            | TokenKind.LBracket:
                self.push_err(token, LogMsg.WaitCloseBracket)
            }
        }
    }

    fn parse(mut &self, mut &f: &File) {
        self.ast = &Ast{
            file: f,
        }

        self.check_ranges(f.tokens)
        if self.errors.len > 0 {
            ret
        }

        let mut stmts = split_stmts(f.tokens)

        // Get top directives.
        let mut i = 0
        for i < stmts.len; i++ {
            let mut stmt = stmts[i]
            if stmt.tokens.len < 2 {
                ret
            }
            if stmt.tokens[0].id != TokenId.Hash {
                break
            }
            if !is_top_directive(stmt.tokens[1].kind) {
                break
            }
            self.ast.top_directives = append(self.ast.top_directives, self.build_directive(stmt.tokens))
        }

        // Remove all errors.
        self.errors = nil

        for i < stmts.len; i++ {
            let mut stmt = stmts[i]
            self.append_node(stmt.tokens)

            if self.stopped() {
                break
            }
        }

        if self.directives.len != 0 {
            self.push_err(self.directives[0].tag, LogMsg.UnusedDirective)
        }
    }
}