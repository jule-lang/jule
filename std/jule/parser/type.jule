// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::jule::ast::{
    TypeDecl,
    SubIdentTypeDecl,
    IdentTypeDecl,
    NamespaceTypeDecl,
    PtrTypeDecl,
    SptrTypeDecl,
    SlcTypeDecl,
    ArrTypeDecl,
    MapTypeDecl,
}
use std::jule::build::{LogMsg}
use std::jule::lex::{Token, TokenId, TokenKind}

fn buildVoidType(): &TypeDecl {
    ret new(TypeDecl)
}

fn buildPrimType(mut t: &Token): &TypeDecl {
    ret &TypeDecl{
        Token: t,
        Kind: &IdentTypeDecl{
            Token: t,
            Ident: t.Kind,
        },
    }
}

// Returns delimiter index of the map type.
// Returns -1 if not found.
// Starts search at i.
fn mapColon(mut &tokens: []&Token, mut &i: int): (delim: int) {
    delim = -1
    let mut rangeN = 0
    for i < tokens.len; i++ {
        let token = tokens[i]
        if token.Id == TokenId.Range {
            match token.Kind {
            | TokenKind.LBrace
            | TokenKind.LBracket
            | TokenKind.LParent:
                rangeN++
                continue
            |:
                rangeN--
            }
        }
        if rangeN == 0 {
            if tokens.len-i == 1 {
                ret
            }
            if tokens[i+1].Id == TokenId.Colon {
                ret i + 1
            }
            break
        }
    }
    ret
}

struct typeBuilder {
    p:      &parser
    tokens: []&Token
    i:      *int
    err:    bool
}

impl typeBuilder {
    fn pushErr(mut self, token: &Token, fmt: LogMsg) {
        if self.err {
            self.p.pushErr(token, fmt)
        }
    }

    // Push suggestion to last log.
    fn pushSuggestion(mut self, fmt: LogMsg, args: ...any) {
        if self.err {
            self.p.pushSuggestion(fmt, args...)
        }
    }

    unsafe fn buildPrim(mut self): &TypeDecl {
        let mut t = buildPrimType(self.tokens[*self.i])
        *self.i++
        ret t
    }

    unsafe fn buildNamespace(mut self): &TypeDecl {
        let mut t = &TypeDecl{
            Token: self.tokens[*self.i],
        }

        let mut nst = new(NamespaceTypeDecl)
        let mut n = 0
        for *self.i < self.tokens.len; *self.i++ {
            let mut token = self.tokens[*self.i]
            if n%2 == 0 {
                if token.Id != TokenId.Ident {
                    self.pushErr(token, LogMsg.InvalidSyntax)
                    self.pushSuggestion(LogMsg.ExpectedIdentifier)
                }
                nst.Idents = append(nst.Idents, token)
            } else if token.Id != TokenId.DblColon {
                break
            }
            n++
        }

        // Remove selected identifier token.
        nst.Idents = nst.Idents[:nst.Idents.len-1]

        *self.i-- // Set offset to last identifier.
        nst.Kind = self.buildIdent()
        t.Kind = nst
        ret t
    }

    unsafe fn buildGenerics(mut self): []&TypeDecl {
        if *self.i >= self.tokens.len {
            ret nil
        }
        let token = self.tokens[*self.i]
        if token.Id != TokenId.Range || token.Kind != TokenKind.LBracket {
            ret nil
        }

        let mut parts = self.identGenerics()
        if parts.len == 0 {
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret nil
        }

        let mut types = make([]&TypeDecl, 0, parts.len)
        for (_, mut part) in parts {
            let mut j = 0
            let (mut t, _) = unsafe { self.p.buildType(part, &j, true) }
            if j < part.len {
                self.pushErr(part[j], LogMsg.InvalidSyntax)
            }
            types = append(types, t)
        }
        ret types
    }

    unsafe fn identGenerics(mut self): [][]&Token {
        let first = *self.i
        let mut rangeN = 0
        for *self.i < self.tokens.len; *self.i++ {
            let token = self.tokens[*self.i]
            if token.Id == TokenId.Range {
                match token.Kind {
                | TokenKind.LBracket:
                    rangeN++
                | TokenKind.RBracket:
                    rangeN--
                }
            }
            if rangeN == 0 {
                *self.i++ // Skip right bracket
                break
            }
        }
        let mut tokens = self.tokens[first+1 : *self.i-1] // Take range of brackets.
        let (mut parts, errors) = parts(tokens, TokenId.Comma, true)
        if self.err {
            self.p.errors = append(self.p.errors, errors...)
        }
        ret parts
    }

    unsafe fn buildIdent(mut self): &TypeDecl {
        let mut next = *self.i+1 < self.tokens.len
        if next && self.tokens[*self.i+1].Id == TokenId.DblColon {
            ret self.buildNamespace()
        }
        let mut token = self.tokens[*self.i]
        let mut it = &IdentTypeDecl{
            Token: token,
            Ident: token.Kind,
            CppLinked: false,
        }
        *self.i++
        let mut itd = &TypeDecl{
            Token: token,
            Kind: it,
        }
        if !next || self.tokens[*self.i].Id != TokenId.Dot {
            it.Generics = self.buildGenerics()
            ret itd
        }
        if self.tokens.len-*self.i == 1 {
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret itd
        }
        *self.i++
        if self.tokens[*self.i].Id != TokenId.Ident {
            self.pushErr(self.tokens[*self.i-1], LogMsg.InvalidSyntax)
            ret itd
        }
        let mut sit = new(SubIdentTypeDecl)
        sit.Idents = append(sit.Idents, it)
        let mut ident = self.buildIdent()
        match type ident.Kind {
        | &IdentTypeDecl:
            sit.Idents = append(sit.Idents, (&IdentTypeDecl)(ident.Kind))
        | &SubIdentTypeDecl:
            sit.Idents = append(sit.Idents, (&SubIdentTypeDecl)(ident.Kind).Idents...)
        }
        ret &TypeDecl{
            Token: token,
            Kind: sit,
        }
    }

    unsafe fn buildCppLink(mut self): &TypeDecl {
        if *self.i+1 >= self.tokens.len || self.tokens[*self.i+1].Id != TokenId.Dot {
            self.pushErr(self.tokens[*self.i], LogMsg.InvalidSyntax)
            ret nil
        }
        *self.i += 2 // Skip cpp keyword and dot token.
        let mut t = self.buildIdent()
        (&IdentTypeDecl)(t.Kind).CppLinked = true
        ret t
    }

    unsafe fn buildFn(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        let mut f = self.p.buildFnPrototype(self.tokens, *self.i, false)
        if f == nil {
            ret nil
        }
        if !f.IsAnon() {
            self.pushErr(f.Token, LogMsg.InvalidSyntax)
        }
        ret &TypeDecl{
            Token: token,
            Kind: f,
        }
    }

    unsafe fn buildPtr(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        if *self.i+1 >= self.tokens.len {
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret nil
        }

        *self.i++
        if self.tokens[*self.i].Id == TokenId.Unsafe {
            *self.i++
            ret &TypeDecl{
                Token: token,
                Kind: &PtrTypeDecl{
                    Elem: nil, // Set Elem as nil for unsafe pointer (*unsafe) type.
                },
            }
        }

        let mut elem = self.step()
        if elem == nil {
            ret nil
        }

        ret &TypeDecl{
            Token: token,
            Kind: &PtrTypeDecl{
                Elem: elem,
            },
        }
    }

    unsafe fn buildSptr(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        if *self.i+1 >= self.tokens.len {
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret nil
        }

        *self.i++
        let mut elem = self.step()
        if elem == nil {
            ret nil
        }

        ret &TypeDecl{
            Token: token,
            Kind: &SptrTypeDecl{
                Elem: elem,
            },
        }
    }

    unsafe fn buildOp(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        match token.Kind {
        | TokenKind.Star:
            ret self.buildPtr()
        | TokenKind.Amper:
            ret self.buildSptr()
        | TokenKind.DblAmper:
            ret &TypeDecl{
                Kind: &SptrTypeDecl{
                    Elem: self.buildSptr(),
                },
            }
        |:
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret nil
        }
    }

    unsafe fn buildSlc(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        *self.i++ // skip right bracket
        let mut elem = self.step()
        if elem == nil {
            ret nil
        }
        ret &TypeDecl{
            Token: token,
            Kind: &SlcTypeDecl{
                Elem: elem,
            },
        }
    }

    unsafe fn buildArr(mut self): &TypeDecl {
        // *self.i points to element type of array.
        // Brackets places at ... < *self.i offset.

        if *self.i >= self.tokens.len {
            self.pushErr(self.tokens[*self.i-1], LogMsg.MissingType)
            ret nil
        }

        let exprDelta = *self.i

        let mut elem = self.step()
        if elem == nil {
            ret nil
        }

        let mut arrt = &ArrTypeDecl{
            Elem: elem,
        }

        let mut exprTokens = self.tokens[:exprDelta]
        _, exprTokens = rangeLast(exprTokens)
        exprTokens = exprTokens[1:exprTokens.len-1] // Remove brackets.
        let mut token = exprTokens[0]
        if exprTokens.len == 1 && token.Id == TokenId.Op && token.Kind == TokenKind.TripleDot {
            // Ignore.
        } else {
            arrt.Size = self.p.buildExpr(exprTokens)
        }

        ret &TypeDecl{
            Token: token,
            Kind: arrt,
        }
    }

    unsafe fn buildMap(mut self, start: int, delim: int): &TypeDecl {
        let mut delimToken = self.tokens[delim]
        if delim == 0 || delim+1 >= self.tokens.len {
            self.pushErr(delimToken, LogMsg.MissingType)
            ret nil
        }

        // Get key type tokens without brackets.
        let mut keyTokens = self.tokens[start+1 : delim-1]
        if keyTokens.len == 0 {
            self.pushErr(delimToken, LogMsg.MissingType)
            ret nil
        }

        let mut mapt = new(MapTypeDecl)

        let mut j = 0
        let (mut keyt, mut ok) = self.p.buildType(keyTokens, &j, self.err)
        if !ok {
            ret nil
        } else if j < keyTokens.len {
            self.pushErr(keyTokens[j], LogMsg.InvalidSyntax)
        }
        mapt.Key = keyt

        *self.i++ // Skip delimiter token.
        let (mut valt, ok) = self.p.buildType(self.tokens, self.i, self.err)
        if !ok {
            ret nil
        }
        mapt.Val = valt
        ret &TypeDecl{
            Token: delimToken,
            Kind: mapt,
        }
    }

    unsafe fn buildEnumerable(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        if *self.i+2 >= self.tokens.len ||
            token.Id != TokenId.Range ||
            token.Kind != TokenKind.LBracket {
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret nil
        }
        *self.i++
        token = self.tokens[*self.i]
        if token.Id == TokenId.Range && token.Kind == TokenKind.RBracket {
            ret self.buildSlc()
        }

        *self.i-- // Point to left bracket for range parsing of split_colon.
        let i = *self.i
        let mut delim = mapColon(self.tokens, *self.i)
        *self.i++
        if delim == -1 {
            ret self.buildArr()
        }
        ret self.buildMap(i, delim)
    }

    unsafe fn step(mut self): &TypeDecl {
        let token = self.tokens[*self.i]
        match token.Id {
        | TokenId.Prim:
            ret self.buildPrim()
        | TokenId.Ident:
            ret self.buildIdent()
        | TokenId.Cpp:
            ret self.buildCppLink()
        | TokenId.Fn:
            ret self.buildFn()
        | TokenId.Op:
            ret self.buildOp()
        | TokenId.Range:
            ret self.buildEnumerable()
        |:
            *self.i++
            self.pushErr(token, LogMsg.InvalidSyntax)
            ret nil
        }
    }

    // Builds type.
    // Returns void if error occurs.
    unsafe fn build(mut self): (&TypeDecl, ok: bool) {
        let mut root = self.step()
        if root == nil {
            ret buildVoidType(), false
        }
        ret root, true
    }
}