// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::jule::ast::{
    TypeDecl,
    SubIdentTypeDecl,
    IdentTypeDecl,
    NamespaceTypeDecl,
    PtrTypeDecl,
    SptrTypeDecl,
    SlcTypeDecl,
    ArrTypeDecl,
    MapTypeDecl,
}
use std::jule::build::{LogMsg}
use std::jule::lex::{Token, TokenId, TokenKind}

fn build_void_type(): &TypeDecl {
    ret new(TypeDecl)
}

fn build_prim_type(mut t: &Token): &TypeDecl {
    ret &TypeDecl{
        token: t,
        kind: &IdentTypeDecl{
            token: t,
            ident: t.kind,
        },
    }
}

// Returns delimiter index of the map type.
// Returns -1 if not found.
// Starts search at i.
fn map_colon(mut &tokens: []&Token, mut &i: int): (delim: int) {
    delim = -1
    let mut range_n = 0
    for i < tokens.len; i++ {
        let token = tokens[i]
        if token.id == TokenId.Range {
            match token.kind {
            | TokenKind.LBrace
            | TokenKind.LBracket
            | TokenKind.LParent:
                range_n++
                continue
            |:
                range_n--
            }
        }
        if range_n == 0 {
            if tokens.len - i == 1 {
                ret
            }
            if tokens[i+1].id == TokenId.Colon {
                ret i + 1
            }
            break
        }
    }
    ret
}

struct TypeBuilder {
    p:      &Parser
    tokens: []&Token
    i:      *int
    err:    bool
}

impl TypeBuilder {
    fn push_err(mut self, token: &Token, fmt: LogMsg) {
        if self.err {
            self.p.push_err(token, fmt)
        }
    }

    // Push suggestion to last log.
    fn push_suggestion(mut self, fmt: LogMsg, args: ...any) {
        if self.err {
            self.p.push_suggestion(fmt, args...)
        }
    }

    unsafe fn build_prim(mut self): &TypeDecl {
        let mut t = build_prim_type(self.tokens[*self.i])
        *self.i++
        ret t
    }

    unsafe fn build_namespace(mut self): &TypeDecl {
        let mut t = &TypeDecl{
            token: self.tokens[*self.i],
        }

        let mut nst = new(NamespaceTypeDecl)
        let mut n = 0
        for *self.i < self.tokens.len; *self.i++ {
            let mut token = self.tokens[*self.i]
            if n%2 == 0 {
                if token.id != TokenId.Ident {
                    self.push_err(token, LogMsg.InvalidSyntax)
                    self.push_suggestion(LogMsg.ExpectedIdentifier)
                }
                nst.idents = append(nst.idents, token)
            } else if token.id != TokenId.DblColon {
                break
            }
            n++
        }

        // Remove selected identifier token.
        nst.idents = nst.idents[:nst.idents.len-1]

        *self.i-- // Set offset to last identifier.
        nst.kind = self.build_ident()
        t.kind = nst
        ret t
    }

    unsafe fn build_generics(mut self): []&TypeDecl {
        if *self.i >= self.tokens.len {
            ret nil
        }
        let token = self.tokens[*self.i]
        if token.id != TokenId.Range || token.kind != TokenKind.LBracket {
            ret nil
        }

        let mut parts = self.ident_generics()
        if parts.len == 0 {
            self.push_err(token, LogMsg.InvalidSyntax)
            ret nil
        }

        let mut types = make([]&TypeDecl, 0, parts.len)
        for (_, mut part) in parts {
            let mut j = 0
            let (mut t, _) = unsafe { self.p.build_type(part, &j, true) }
            if j < part.len {
                self.push_err(part[j], LogMsg.InvalidSyntax)
            }
            types = append(types, t)
        }
        ret types
    }

    unsafe fn ident_generics(mut self): [][]&Token {
        let first = *self.i
        let mut range_n = 0
        for *self.i < self.tokens.len; *self.i++ {
            let token = self.tokens[*self.i]
            if token.id == TokenId.Range {
                match token.kind {
                | TokenKind.LBracket:
                    range_n++
                | TokenKind.RBracket:
                    range_n--
                }
            }
            if range_n == 0 {
                *self.i++ // Skip right bracket
                break
            }
        }
        let mut tokens = self.tokens[first+1 : *self.i-1] // Take range of brackets.
        let (mut parts, errors) = parts(tokens, TokenId.Comma, true)
        if self.err {
            self.p.errors = append(self.p.errors, errors...)
        }
        ret parts
    }

    unsafe fn build_ident(mut self): &TypeDecl {
        let mut next = *self.i+1 < self.tokens.len
        if next && self.tokens[*self.i+1].id == TokenId.DblColon {
            ret self.build_namespace()
        }
        let mut token = self.tokens[*self.i]
        let mut it = &IdentTypeDecl{
            token: token,
            ident: token.kind,
            cpp_linked: false,
        }
        *self.i++
        let mut itd = &TypeDecl{
            token: token,
            kind: it,
        }
        if !next || self.tokens[*self.i].id != TokenId.Dot {
            it.generics = self.build_generics()
            ret itd
        }
        if self.tokens.len-*self.i == 1 {
            self.push_err(token, LogMsg.InvalidSyntax)
            ret itd
        }
        *self.i++
        if self.tokens[*self.i].id != TokenId.Ident {
            self.push_err(self.tokens[*self.i-1], LogMsg.InvalidSyntax)
            ret itd
        }
        let mut sit = new(SubIdentTypeDecl)
        sit.idents = append(sit.idents, it)
        let mut ident = self.build_ident()
        match type ident.kind {
        | &IdentTypeDecl:
            sit.idents = append(sit.idents, (&IdentTypeDecl)(ident.kind))
        | &SubIdentTypeDecl:
            sit.idents = append(sit.idents, (&SubIdentTypeDecl)(ident.kind).idents...)
        }
        ret &TypeDecl{
            token: token,
            kind: sit,
        }
    }

    unsafe fn build_cpp_link(mut self): &TypeDecl {
        if *self.i+1 >= self.tokens.len || self.tokens[*self.i+1].id != TokenId.Dot {
            self.push_err(self.tokens[*self.i], LogMsg.InvalidSyntax)
            ret nil
        }
        *self.i += 2 // Skip cpp keyword and dot token.
        let mut t = self.build_ident()
        (&IdentTypeDecl)(t.kind).cpp_linked = true
        ret t
    }

    unsafe fn build_fn(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        let mut f = self.p.build_fn_prototype(self.tokens, *self.i, false)
        if f == nil {
            ret nil
        }
        if !f.is_anon() {
            self.push_err(f.token, LogMsg.InvalidSyntax)
        }
        ret &TypeDecl{
            token: token,
            kind: f,
        }
    }

    unsafe fn build_ptr(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        if *self.i+1 >= self.tokens.len {
            self.push_err(token, LogMsg.InvalidSyntax)
            ret nil
        }

        *self.i++
        if self.tokens[*self.i].id == TokenId.Unsafe {
            *self.i++
            ret &TypeDecl{
                token: token,
                kind: &PtrTypeDecl{
                    elem: nil, // Set Elem as nil for unsafe pointer (*unsafe) type.
                },
            }
        }

        let mut elem = self.step()
        if elem == nil {
            ret nil
        }

        ret &TypeDecl{
            token: token,
            kind: &PtrTypeDecl{
                elem: elem,
            },
        }
    }

    unsafe fn build_sptr(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        if *self.i+1 >= self.tokens.len {
            self.push_err(token, LogMsg.InvalidSyntax)
            ret nil
        }

        *self.i++
        let mut elem = self.step()
        if elem == nil {
            ret nil
        }

        ret &TypeDecl{
            token: token,
            kind: &SptrTypeDecl{
                elem: elem,
            },
        }
    }

    unsafe fn build_op(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        match token.kind {
        | TokenKind.Star:
            ret self.build_ptr()
        | TokenKind.Amper:
            ret self.build_sptr()
        | TokenKind.DblAmper:
            ret &TypeDecl{
                kind: &SptrTypeDecl{
                    elem: self.build_sptr(),
                },
            }
        |:
            self.push_err(token, LogMsg.InvalidSyntax)
            ret nil
        }
    }

    unsafe fn build_slc(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        *self.i++ // skip right bracket
        let mut elem = self.step()
        if elem == nil {
            ret nil
        }
        ret &TypeDecl{
            token: token,
            kind: &SlcTypeDecl{
                elem: elem,
            },
        }
    }

    unsafe fn build_arr(mut self): &TypeDecl {
        // *self.i points to element type of array.
        // Brackets places at ... < *self.i offset.

        if *self.i >= self.tokens.len {
            self.push_err(self.tokens[*self.i-1], LogMsg.MissingType)
            ret nil
        }

        let expr_delta = *self.i

        let mut elem = self.step()
        if elem == nil {
            ret nil
        }

        let mut arrt = &ArrTypeDecl{
            elem: elem,
        }

        let mut expr_tokens = self.tokens[:expr_delta]
        _, expr_tokens = range_last(expr_tokens)
        expr_tokens = expr_tokens[1:expr_tokens.len-1] // Remove brackets.
        let mut token = expr_tokens[0]
        if expr_tokens.len == 1 && token.id == TokenId.Op && token.kind == TokenKind.TripleDot {
            // Ignore.
        } else {
            arrt.size = self.p.build_expr(expr_tokens)
        }

        ret &TypeDecl{
            token: token,
            kind: arrt,
        }
    }

    unsafe fn build_map(mut self, start: int, delim: int): &TypeDecl {
        let mut delim_token = self.tokens[delim]
        if delim == 0 || delim+1 >= self.tokens.len {
            self.push_err(delim_token, LogMsg.MissingType)
            ret nil
        }

        // Get key type tokens without brackets.
        let mut key_tokens = self.tokens[start+1:delim-1]
        if key_tokens.len == 0 {
            self.push_err(delim_token, LogMsg.MissingType)
            ret nil
        }

        let mut mapt = new(MapTypeDecl)

        let mut j = 0
        let (mut keyt, mut ok) = self.p.build_type(key_tokens, &j, self.err)
        if !ok {
            ret nil
        } else if j < key_tokens.len {
            self.push_err(key_tokens[j], LogMsg.InvalidSyntax)
        }
        mapt.key = keyt

        *self.i++ // Skip delimiter token.
        let (mut valt, ok) = self.p.build_type(self.tokens, self.i, self.err)
        if !ok {
            ret nil
        }
        mapt.val = valt
        ret &TypeDecl{
            token: delim_token,
            kind: mapt,
        }
    }

    unsafe fn build_enumerable(mut self): &TypeDecl {
        let mut token = self.tokens[*self.i]
        if *self.i+2 >= self.tokens.len ||
            token.id != TokenId.Range ||
            token.kind != TokenKind.LBracket {
            self.push_err(token, LogMsg.InvalidSyntax)
            ret nil
        }
        *self.i++
        token = self.tokens[*self.i]
        if token.id == TokenId.Range && token.kind == TokenKind.RBracket {
            ret self.build_slc()
        }

        *self.i-- // Point to left bracket for range parsing of split_colon.
        let i = *self.i
        let mut delim = map_colon(self.tokens, *self.i)
        *self.i++
        if delim == -1 {
            ret self.build_arr()
        }
        ret self.build_map(i, delim)
    }

    unsafe fn step(mut self): &TypeDecl {
        let token = self.tokens[*self.i]
        match token.id {
        | TokenId.Prim:
            ret self.build_prim()
        | TokenId.Ident:
            ret self.build_ident()
        | TokenId.Cpp:
            ret self.build_cpp_link()
        | TokenId.Fn:
            ret self.build_fn()
        | TokenId.Op:
            ret self.build_op()
        | TokenId.Range:
            ret self.build_enumerable()
        |:
            *self.i++
            self.push_err(token, LogMsg.InvalidSyntax)
            ret nil
        }
    }

    // Builds type.
    // Returns void if error occurs.
    unsafe fn build(mut self): (&TypeDecl, ok: bool) {
        let mut root = self.step()
        if root == nil {
            ret build_void_type(), false
        }
        ret root, true
    }
}