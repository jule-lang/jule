// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use ast for std::jule::ast
use std::jule::build::{Directive, Derive, LogMsg, Log, LogKind, logf}
use std::jule::constant::{Const}
use std::jule::lex::{File, Token, TokenKind, is_ignore_ident, is_anon_ident}
use types for std::jule::types
use strings for std::strings

fn is_valid_model_for_ref(mut &m: ExprModel): bool {
    match type m {
    | &Var:
        ret true

    | &StructSubIdentExprModel:
        let mut model = (&StructSubIdentExprModel)(m)
        ret is_valid_model_for_ref(model.expr)

    | &TraitSubIdentExprModel:
        let mut model = (&TraitSubIdentExprModel)(m)
        ret is_valid_model_for_ref(model.expr)

    | &UnaryExprModel:
        let mut unary = (&UnaryExprModel)(m)
        if unary.op.kind != TokenKind.Star {
            ret false
        }

        // Return true because of pointer dereferencing is an Unsafe Jule feature.
        if unary.expr.kind.ptr() != nil {
            ret true
        }

        // Dereferencing should be smart pointer, in other words return false.
        if unary.expr.kind.sptr() == nil {
            ret false
        }

        ret is_valid_model_for_ref(unary.expr.model)

    |:
        ret false
    }
}

fn compiler_err(&token: Token, line: bool, fmt: LogMsg, args: ...any): Log {
    let mut log = Log{
        kind:   LogKind.Error,
        row:    token.row,
        column: token.column,
        path:   token.file.path(),
        text:   logf(fmt, args...),
    }
    if line {
        log.line = token.file.get_row(token.row)
    }
    ret log
}

fn imp_is_lookupable(&i: &ImportInfo, ident: str): bool {
    if i.cpp_linked {
        ret false
    }

    if !i.import_all {
        if i.selected.len > 0 {
            ret i.exist_ident(ident)
        }
    }
    ret i.import_all
}

fn build_ret_vars(mut &f: &FnIns): []&Var {
    if f.decl.is_void() || f.result == nil {
        ret nil
    }

    let mut vars: []&Var = nil
    let mut types = get_result_types(f.result)
    for (i, mut ident) in f.decl.result.idents {
        if is_ignore_ident(ident.kind) {
            continue
        }

        let mut v = &Var{
            used:    true,
            mutable: true,
            ident:   ident.kind,
            token:   ident,
            scope:   f.scope,
            kind:    &TypeSymbol{kind: types[i]},
            value: &Value{
                data: &Data{},
            },
        }
        vars = append(vars, v)
    }

    ret vars
}

fn build_param_vars(mut &f: &FnIns): []&Var {
    if f.params.len == 0 {
        ret nil
    }

    let mut vars = make([]&Var, 0, f.params.len)
    for (_, mut p) in f.params {
        let mut v = &Var{
            used:      true,
            reference: p.decl.reference,
            mutable:   p.decl.mutable,
            ident:     p.decl.ident,
            token:     p.decl.token,
            kind:      &TypeSymbol{},
            scope:     f.scope,
            value: &Value{
                data: &Data{},
            },
        }

        match {
        | p.decl.is_self():
            v.kind.kind = &TypeKind{kind: f.owner}
            v.reference = true

            if p.decl.is_ref() {
                v.ident = v.ident[1:] // Remove reference sign.
                v.kind.kind.kind = &Sptr{
                    elem: &TypeKind{
                        cpp_ident: v.kind.kind.cpp_ident,
                        kind:      v.kind.kind.kind,
                    },
                }
            }

        | p.decl.variadic:
            v.kind.kind = &TypeKind{
                kind: &Slc{
                    elem: &TypeKind{
                        cpp_ident: p.kind.cpp_ident,
                        kind:      p.kind.kind,
                    },
                },
            }

        |:
            v.kind.kind = p.kind
        }

        vars = append(vars, v)
    }

    ret vars
}

fn build_generic_type_aliases(mut &f: &FnIns): []&TypeAlias {
    let mut size = f.generics.len
    if f.decl.owner != nil {
        size += f.decl.owner.generics.len
    }

    if size == 0 {
        ret nil
    }

    let mut aliases = make([]&TypeAlias, 0, size)

    for (i, mut g) in f.generics {
        let mut decl = f.decl.generics[i]
        aliases = append(aliases, &TypeAlias{
            used:    true,
            generic: true,
            scope:   f.decl.scope,
            ident:   decl.ident,
            token:   decl.token,
            kind:    &TypeSymbol{kind: g},
        })
    }

    if f.decl.owner != nil {
        let mut owner = f.owner
        for (i, mut g) in owner.generics {
            let mut decl = owner.decl.generics[i]
            aliases = append(aliases, &TypeAlias{
                used:    true,
                generic: true,
                scope:   f.decl.scope,
                ident:   decl.ident,
                token:   decl.token,
                kind:    &TypeSymbol{kind: g},
            })
        }
    }

    ret aliases
}

fn find_file(mut &files: []&SymbolTable, &handler: &File): &SymbolTable {
    for (_, mut fl) in files {
        if fl.file == handler {
            ret fl
        }
    }
    ret nil
}

fn conditional_has_ret(mut c: &Conditional): (ok: bool, breaking: bool) {
    let mut breaked = false
    for (_, mut elif) in c.elifs {
        if elif == nil {
            ret false, false
        }
        ok, _, breaking = __has_ret(elif.scope)
        breaked = breaked || breaking
        if !ok {
            ret false, breaked
        }
    }

    if c.default == nil {
        ret false, breaked
    }

    ok, _, breaking = __has_ret(c.default.scope)
    breaked = breaked || breaking
    ret ok, breaked
}

fn match_has_ret(mut m: &Match): bool {
    if m.default == nil {
        ret false
    }

    let mut ok = true
    let mut falled = false
    let mut breaked = false
    for (_, mut c) in m.cases {
        if c == nil {
            ret false
        }
        ok, falled, breaked = __has_ret(c.scope)
        if !ok && !falled || breaked {
            ret false
        }

        match {
        | !ok:
            if !falled {
                ret false
            }
            fall

        | falled:
            if c.next == nil {
                ret false
            }
            continue
        }
        falled = false
    }

    ret has_ret(m.default.scope)
}

fn __has_ret(mut s: &Scope): (ok: bool, falled: bool, breaked: bool) {
    if s == nil {
        ret false, false, false
    }

    for (_, mut st) in s.stmts {
        match type st {
        | &FallSt:
            falled = true

        | &BreakSt:
            ret false, false, true

        | &ContSt:
            ret false, false, true

        | &InfIter:
            ok = has_ret((&InfIter)(st).scope)
            if ok {
                ret true, false, false
            }

        | &RetSt:
            ret true, falled, breaked

        | &Scope:
            ok = has_ret((&Scope)(st))
            if ok {
                ret true, false, false
            }

        | &Data:
            match type (&Data)(st).model {
            | &BuiltinPanicCallExprModel
            | &BuiltinErrorCallExprModel:
                ret true, falled, breaked
            }

        | &Conditional:
            ok, breaked = conditional_has_ret((&Conditional)(st))
            if ok {
                ret true, false, false
            }

            if breaked {
                ret false, false, breaked
            }

        | &Match:
            ok = match_has_ret((&Match)(st))
            if ok {
                ret true, false, false
            }
        }
    }

    ret false, falled, breaked
}

fn has_ret(mut s: &Scope): bool {
    let (ok, _, _) = __has_ret(s)
    ret ok
}

unsafe fn push_suggestion(mut log: *Log, fmt: LogMsg, args: ...any) {
    log.suggestion = logf(fmt, args...)
}

// Semantic analyzer for tables.
// Accepts tables as files of package.
struct Sema {
    errors: []Log
    files:  []&SymbolTable // Package files.
    file:   &SymbolTable   // Current package file.
    flags:  SemaFlag
}

impl Lookup for Sema {
    // Returns imported package by identifier.
    // Returns nil reference if not exist any package in this identifier.
    //
    // Lookups:
    //   - Current file's imported packages.
    pub fn find_package(mut self, ident: str): &ImportInfo {
        ret self.file.find_package(ident)
    }

    // Returns imported package by selector.
    // Returns nil reference if selector returns false for all packages.
    // Returns nil reference if selector is nil.
    //
    // Lookups:
    //   - Current file's imported packages.
    pub fn select_package(mut self, selector: fn(&ImportInfo): bool): &ImportInfo {
        ret self.file.select_package(selector)
    }

    // Returns variable by identifier and cpp linked state.
    // Returns nil reference if not exist any variable in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    pub fn find_var(mut self, ident: str, cpp_linked: bool): &Var {
        // Lookup package files.
        let mut v = find_var_in_package(self.files, ident, cpp_linked)
        if v != nil {
            ret v
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.imports {
            if !imp_is_lookupable(imp, ident) {
                continue
            }
            v = imp.find_var(ident, cpp_linked)
            if v != nil && self.is_accessible_define(v.public, v.token) {
                ret v
            }
        }

        ret nil
    }

    // Returns type alias by identifier and cpp linked state.
    // Returns nil reference if not exist any type alias in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    pub fn find_type_alias(mut self, ident: str, cpp_linked: bool): &TypeAlias {
        // Lookup package files.
        let mut ta = find_type_alias_in_package(self.files, ident, cpp_linked)
        if ta != nil {
            ret ta
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.imports {
            if !imp_is_lookupable(imp, ident) {
                continue
            }
            ta = imp.find_type_alias(ident, cpp_linked)
            if ta != nil && self.is_accessible_define(ta.public, ta.token) {
                ret ta
            }
        }

        ret nil
    }

    // Returns struct by identifier and cpp linked state.
    // Returns nil reference if not exist any struct in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    pub fn find_struct(mut self, ident: str, cpp_linked: bool): &Struct {
        // Lookup package files.
        let mut s = find_struct_in_package(self.files, ident, cpp_linked)
        if s != nil {
            ret s
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.imports {
            if !imp_is_lookupable(imp, ident) {
                continue
            }
            s = imp.find_struct(ident, cpp_linked)
            if s != nil && self.is_accessible_define(s.public, s.token) {
                ret s
            }
        }

        ret nil
    }

    // Returns function by identifier and cpp linked state.
    // Returns nil reference if not exist any function in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    pub fn find_fn(mut self, ident: str, cpp_linked: bool): &Fn {
        // Lookup package files.
        let mut f = find_fn_in_package(self.files, ident, cpp_linked)
        if f != nil {
            ret f
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.imports {
            if !imp_is_lookupable(imp, ident) {
                continue
            }
            f = imp.find_fn(ident, cpp_linked)
            if f != nil && self.is_accessible_define(f.public, f.token) {
                ret f
            }
        }

        ret nil
    }

    // Returns trait by identifier.
    // Returns nil reference if not exist any trait in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    pub fn find_trait(mut self, ident: str): &Trait {
        // Lookup package files.
        let mut t = find_trait_in_package(self.files, ident)
        if t != nil {
            ret t
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.imports {
            if !imp_is_lookupable(imp, ident) {
                continue
            }
            t = imp.find_trait(ident)
            if t != nil && self.is_accessible_define(t.public, t.token) {
                ret t
            }
        }

        ret nil
    }

    // Returns enum by identifier.
    // Returns nil reference if not exist any enum in this identifier.
    //
    // Lookups:
    //   - Package file's symbol table.
    //   - Current file's public denifes of imported packages.
    pub fn find_enum(mut self, ident: str): &Enum {
        // Lookup package files.
        let mut e = find_enum_in_package(self.files, ident)
        if e != nil {
            ret e
        }

        // Lookup current file's public denifes of imported packages.
        for (_, mut imp) in self.file.imports {
            if !imp_is_lookupable(imp, ident) {
                continue
            }
            e = imp.find_enum(ident)
            if e != nil && self.is_accessible_define(e.public, e.token) {
                ret e
            }
        }

        ret nil
    }
}

impl Sema {
    // Reports whether flags has given flag.
    fn is_flag(self, flags: SemaFlag): bool { ret self.flags&flags == flags }

    fn set_current_file(mut self, mut f: &SymbolTable) { self.file = f }

    fn push_err(mut self, token: Token, fmt: LogMsg, args: ...any) {
        self.errors = append(self.errors, compiler_err(token, true, fmt, args...))
    }

    // Push suggestion to last log.
    fn push_suggestion(mut self, fmt: LogMsg, args: ...any) {
        unsafe { push_suggestion(&self.errors[self.errors.len-1], fmt, args...) }
    }

    // Reports whether define is accessible in the current package.
    fn is_accessible_define(self, public: bool, token: Token): bool {
        ret public || token.file == nil || self.file.file.dir() == token.file.dir()
    }

    // Reports this identifier duplicated in package's global scope.
    // The "self" parameter represents address of exception identifier.
    // If founded identifier address equals to self, will be skipped.
    fn is_duplicated_ident(self, itself: uintptr, ident: str, cpp_linked: bool): bool {
        for _, f in self.files {
            if f.is_duplicated_ident(itself, ident, cpp_linked) {
                ret true
            }

            for _, imp in f.imports {
                for _, selected in imp.selected {
                    if selected.kind == ident {
                        ret true
                    }
                }
            }
        }
        ret false
    }

    fn check_directives(mut &self, mut &d: []&ast::Directive, mut o: any) {
        let mut dc = DirectiveChecker{
            s: self,
            d: d,
            o: o,
        }
        dc.check()
    }

    fn check_generic_quantity(mut self, required: int, given: int, error_token: Token): (ok: bool) {
        match {
        | required == 0 && given > 0:
            self.push_err(error_token, LogMsg.NotHasGenerics)
            ret false

        | required > 0 && given == 0:
            self.push_err(error_token, LogMsg.HasGenerics)
            ret false

        | required < given:
            self.push_err(error_token, LogMsg.GenericsOverflow)
            ret false

        | required > given:
            self.push_err(error_token, LogMsg.MissingGenerics)
            ret false

        |:
            ret true
        }
    }

    fn is_duplicated_import_selection(self, itself: uintptr, ident: str): bool {
        for _, imp in self.file.imports {
            if uintptr(imp) == itself {
                // Don't scan trailing imports.
                break
            }

            if imp.exist_ident(ident) {
                ret true
            }
        }

        ret false
    }

    fn get_import_def(self, ident: str, mut &imp: &ImportInfo): any {
        if find_package_builtin_def(imp.link_path, ident) != nil {
            ret true
        }

        for (_, mut f) in imp.package.files {
            const CPP_LINKED = false // C++-linked defines can't export.
            let mut def = f.def_by_ident(ident, CPP_LINKED)
            if def != nil {
                ret def
            }
        }

        ret nil
    }

    fn check_import_selections(mut self, mut &imp: &ImportInfo) {
        for _, ident in imp.selected {
            if ident.kind == TokenKind.Self {
                continue
            }

            if self.is_duplicated_import_selection(uintptr(imp), ident.kind) {
                self.push_err(ident, LogMsg.DuplicatedIdent, ident.kind)
                self.push_suggestion(LogMsg.RenameForAvoidDuplication)
                continue
            }

            let mut def = self.get_import_def(ident.kind, imp)
            match type def {
            | bool:
                // Pass, built-in.
                continue

            | &Var:
                let mut v = (&Var)(def)
                if self.is_accessible_define(v.public, v.token) {
                    continue
                }

            | &TypeAlias:
                let mut ta = (&TypeAlias)(def)
                if self.is_accessible_define(ta.public, ta.token) {
                    continue
                }

            | &Struct:
                let mut strct = (&Struct)(def)
                if self.is_accessible_define(strct.public, strct.token) {
                    continue
                }

            | &Trait:
                let mut t = (&Trait)(def)
                if self.is_accessible_define(t.public, t.token) {
                    continue
                }

            | &Enum:
                let mut e = (&Enum)(def)
                if self.is_accessible_define(e.public, e.token) {
                    continue
                }

            | &Fn:
                let mut f = (&Fn)(def)
                if self.is_accessible_define(f.public, f.token) {
                    continue
                }

            |:
                self.push_err(ident, LogMsg.IdentNotExist, ident.kind)
                continue
            }

            self.push_err(ident, LogMsg.IdentIsNotAccessible, ident.kind)
            self.push_suggestion(LogMsg.MakePubToAccess)
        }
    }

    fn is_use_alias_duplication(mut self, &imp: &ImportInfo): bool {
        if imp.alias.len == 0 {
            ret false
        }

        for (_, mut imp2) in self.file.imports {
            if imp2 == imp {
                break
            }
            if imp2.alias == imp.alias {
                ret true
            }

            // Catch identifiers of other use declarations.
            if imp2.ident == imp2.link_path && imp2.ident == imp.alias {
                ret true
            }
        }
        ret false
    }

    fn check_import(mut self, mut &imp: &ImportInfo): bool {
        if imp.cpp_linked || imp.package.files.len == 0 {
            ret true
        }

        if self.is_use_alias_duplication(imp) {
            self.push_err(imp.token, LogMsg.DuplicatedUseAlias, imp.alias)
            self.push_suggestion(LogMsg.RenameUseAliasAvoidDuplication)
        }

        if imp.duplicate {
            ret true
        }

        let mut sema = &Sema{
            flags: self.flags,
        }
        sema.check(imp.package.files)
        if sema.errors.len > 0 {
            self.errors = append(self.errors, sema.errors...)
            sema.errors = nil
            ret false
        }

        self.check_import_selections(imp)
        ret true
    }

    fn check_imports(mut self) {
        for (_, mut file) in self.files {
            self.set_current_file(file)

            for (_, mut imp) in file.imports {
                let ok = self.check_import(imp)

                // Break checking if package has error.
                if !ok {
                    self.push_err(imp.token, LogMsg.UsedPackageHasErrors, imp.link_path)
                    ret
                }
            }
        }
    }

    fn impl_file_impls(mut &self) {
        for (_, mut imp) in self.file.impls {
            self.impl_impl(imp)
        }
    }

    fn impl_impls(mut &self) {
        for (_, mut file) in self.files {
            self.set_current_file(file)
            self.impl_file_impls()
        }
    }

    fn check_enums(mut &self) {
        for (_, mut file) in self.files {
            self.set_current_file(file)
            self.check_enum_decls()
        }
    }

    // Checks type, builds result as kind and collects referred type aliases.
    // Skips already checked types.
    fn check_type_with_refers(mut &self, mut &t: &TypeSymbol,
        mut l: Lookup, mut referencer: &Referencer): (ok: bool) {
        if t.checked() {
            ret true
        }
        let mut tc = TypeChecker{
            s:          self,
            lookup:     l,
            referencer: referencer,
        }
        tc.check(t)
        ret t.checked()
    }

    // Checks type and builds result as kind.
    // Skips already checked types.
    fn check_type(mut &self, mut &t: &TypeSymbol, mut l: Lookup): bool {
        ret self.check_type_with_refers(t, l, nil)
    }

    // Builds type with type aliases for generics.
    // Returns nil if error occur or failed.
    fn build_type_with_generics(mut &self, mut &t: &ast::TypeDecl,
        mut generics: []&TypeAlias): &TypeKind {
        let mut tc = &TypeChecker{
            s:            self,
            lookup:       self,
            use_generics: generics,
        }
        ret tc.check_decl(t)
    }

    // Same as self.build_type_with_generics but not uses any generics.
    fn build_type(mut &self, mut &t: &ast::TypeDecl): &TypeKind {
        ret self.build_type_with_generics(t, nil)
    }

    // Select type with name selection.
    fn select_type(mut &self, mut &t: &ast::TypeDecl): &TypeKind {
        let mut tc = &TypeChecker{
            s:         self,
            lookup:    self,
            selection: true,
        }
        ret tc.check_decl(t)
    }

    // Returns Eval instance for configuration with
    // type prefix and checks var dependencies.
    fn evalpd(mut &self, mut l: Lookup, mut p: &TypeKind, mut owner: &Var): &Eval {
        let mut e = &Eval{
            s:      self,
            lookup: l,
            owner:  owner,
        }

        match type l {
        | &ScopeChecker:
            e.unsafety = (&ScopeChecker)(l).is_unsafe()
        }

        e.prefix = p

        ret e
    }

    // Returns Eval instance for configuration with type prefix.
    fn evalp(mut &self, mut l: Lookup, mut p: &TypeKind): &Eval {
        ret self.evalpd(l, p, nil)
    }

    // Returns Eval instance for configuration.
    fn eval(mut &self, mut l: Lookup): &Eval {
        ret self.evalp(l, nil)
    }

    fn check_assign_type(mut &self, dest_is_ref: bool, mut &dest: &TypeKind,
        mut &d: &Data, mut error_token: Token) {
        if d.decl {
            self.push_err(error_token, LogMsg.InvalidExpr)
            ret
        }
        if d.kind.variadic {
            self.push_err(error_token, LogMsg.InvalidExpr)
            ret
        }
        if dest_is_ref {
            if !dest.equals(d.kind) {
                self.push_err(error_token, LogMsg.IncompatibleTypes, dest.to_str(), d.kind.to_str())
            }
        } else {
            let mut atc = &AssignTypeChecker{
                s:           self,
                error_token: error_token,
                dest:        dest,
                d:           d,
            }
            let ok = atc.check()
            if !ok {
                ret
            }
        }

        if !d.is_const() || dest.prim() == nil {
            ret
        }

        let mut kind = dest.prim().kind

        match {
        | types::is_sig_int(kind):   d.constant.set_i64(d.constant.as_i64())
        | types::is_unsig_int(kind): d.constant.set_u64(d.constant.as_u64())
        | types::is_float(kind):     d.constant.set_f64(d.constant.as_f64())
        }
    }

    fn check_type_compatibility(mut &self, mut &dest: &TypeKind,
        mut &src: &TypeKind, mut &error_token: Token): bool {
        if src == nil {
            self.push_err(error_token, LogMsg.IncompatibleTypes,
                dest.to_str(), src.to_str())
            ret false
        }

        // Tuple to single type, always fails.
        if src.tup() != nil {
            self.push_err(error_token, LogMsg.IncompatibleTypes,
                dest.to_str(), src.to_str())
            ret false
        }

        let mut tcc = TypeCompatibilityChecker{
            s:           self,
            error_token: error_token,
            dest:        dest,
            src:         src,
        }

        if tcc.check() {
            ret true
        }

        self.push_err(error_token, LogMsg.IncompatibleTypes, dest.to_str(), src.to_str())
        ret false
    }

    // Builds non-generic types but skips generic types.
    // Builds generic identifiers as primitive type.
    //
    // Useful:
    //   - For non-generic type parsed string type kinds.
    //   - For checking non-generic types.
    fn build_non_generic_type_kind(mut &self, mut &ast: &ast::TypeDecl,
        mut &generics: []&ast::GenericDecl): &TypeKind {
        let mut tc = &TypeChecker{
            s:               self,
            lookup:          self,
            ignore_generics: generics,
        }
        ret tc.check_decl(ast)
    }

    fn build_fn_non_generic_type_kinds(mut &self, mut &f: &FnIns) {
        let mut generics: []&ast::GenericDecl = nil
        if f.decl.is_method() {
            generics = append(f.decl.generics, f.decl.owner.generics...)
        } else {
            generics = f.decl.generics
        }

        for (_, mut p) in f.params {
            if !p.decl.is_self() {
                p.kind = self.build_non_generic_type_kind(p.decl.kind.decl, generics)
            }
        }
        if !f.decl.is_void() {
            f.result = self.build_non_generic_type_kind(f.decl.result.kind.decl, generics)
        }
    }

    fn get_trait_check_fn_kind(mut &self, mut &f: &Fn): &FnIns {
        let mut ins = f.instance_force()
        self.build_fn_non_generic_type_kinds(ins)
        ret ins
    }

    fn reload_fn_ins_types(mut &self, mut &f: &FnIns): (ok: bool) {
        if f.is_builtin() || f.is_anon() {
            ret true
        }

        let mut sema = f.decl.sema

        let mut old = f.decl.sema.file
        defer { f.decl.sema.set_current_file(old) }
        let mut file = find_file(f.decl.sema.files, f.decl.token.file)
        if file != nil {
            f.decl.sema.set_current_file(file)
        }

        let mut size = f.generics.len
        if f.decl != nil && f.decl.owner != nil {
            size += f.decl.owner.generics.len
        }

        let mut generics = make([]&TypeAlias, 0, size)

        for (i, mut g) in f.generics {
            generics = append(generics, &TypeAlias{
                ident: f.decl.generics[i].ident,
                kind: &TypeSymbol{
                    kind: g,
                },
            })
        }

        if f.decl != nil && f.decl.owner != nil {
            let mut owner = f.owner
            for (i, mut g) in owner.generics {
                generics = append(generics, &TypeAlias{
                    ident: owner.decl.generics[i].ident,
                    kind: &TypeSymbol{
                        kind: g,
                    },
                })
            }
        }

        ok = true
        for (_, mut p) in f.params {
            if !p.decl.is_self() {
                p.kind = sema.build_type_with_generics(p.decl.kind.decl, generics)
                if p.kind != nil {
                    p.kind.variadic = p.decl.variadic
                    if p.decl.reference && !is_valid_for_ref(p.kind) {
                        self.push_err(p.decl.token, LogMsg.RefPointsToInvalidType, p.kind.to_str())
                    }
                } else {
                    ok = false
                }
            }
        }

        if !f.decl.is_void() {
            f.result = sema.build_type_with_generics(f.decl.result.kind.decl, generics)
            ok = f.result != nil && ok
        }

        if sema != self {
            self.errors = append(self.errors, sema.errors...)
            sema.errors = nil
        }

        ret ok
    }

    fn check_ref_validity_for_init_expr(mut &self, left_mut: bool, mut &d: &Data, mut &error_token: Token) {
        match type d.model {
        | &Var:
            // Pass.

        | &TraitSubIdentExprModel:
            let mut model = (&TraitSubIdentExprModel)(d.model)
            if !is_valid_model_for_ref(model.expr) {
                self.push_err(error_token, LogMsg.RefIsDangling, model.ident)
            }

        | &StructSubIdentExprModel:
            let mut model = (&StructSubIdentExprModel)(d.model)
            if !is_valid_model_for_ref(model.expr) {
                self.push_err(error_token, LogMsg.RefIsDangling, model.field.decl.ident)
            }

        | &CommonIdentExprModel
        | &CommonSubIdentExprModel:
            self.push_err(error_token, LogMsg.BuiltinUsedForRef)

        | &UnaryExprModel:
            let mut unary = (&UnaryExprModel)(d.model)
            if unary.op.kind == TokenKind.Star {
                if !is_valid_model_for_ref(d.model) {
                    self.push_err(error_token, LogMsg.RefIsDangling, "address from * &T")
                }
                break
            }

            fall
        |:
            self.push_err(error_token, LogMsg.RefAssignNonVar)
        }

        if left_mut && !d.mutable {
            self.push_err(error_token, LogMsg.MutRefPointsImmut)
        }
    }

    fn check_validity_for_init_expr(mut &self, left_mut: bool, left_ref: bool,
        &left_kind: &TypeKind, mut &d: &Data, mut &error_token: Token) {
        if left_mut && !d.mutable && d.kind.mutable() {
            self.push_err(error_token, LogMsg.AssignNonMutToMut)
        }
        if left_ref {
            self.check_ref_validity_for_init_expr(left_mut, d, error_token)
        }

        let mut atc = &AssignTypeChecker{
            s:           self,
            d:           d,
            error_token: error_token,
        }
        _ = atc.check_validity()
    }

    fn check_type_alias_decl_kind(mut &self, mut &ta: &TypeAlias, mut l: Lookup): (ok: bool) {
        let mut old = self.file
        defer { self.set_current_file(old) }
        let mut file = find_file(self.files, ta.token.file)
        if file != nil {
            self.set_current_file(file)
        }

        ok = self.check_type_with_refers(ta.kind, l, &Referencer{
            ident: ta.ident,
            owner: ta,
            refs:  &ta.refers,
        })
        if ok && ta.kind.kind.arr() != nil && ta.kind.kind.arr().auto {
            self.push_err(ta.kind.decl.token, LogMsg.ArrayAutoSized)
            ok = false
        }
        ret
    }

    fn check_type_alias_decl(mut &self, mut &ta: &TypeAlias, mut l: Lookup) {
        if is_ignore_ident(ta.ident) {
            self.push_err(ta.token, LogMsg.IgnoreIdent)
        }
        self.check_type_alias_decl_kind(ta, l)
    }

    // Checks type alias declaration with duplicated identifiers.
    fn check_type_alias_decl_dup(mut &self, mut &ta: &TypeAlias) {
        if self.is_duplicated_ident(uintptr(ta), ta.ident, ta.cpp_linked) {
            self.push_err(ta.token, LogMsg.DuplicatedIdent, ta.ident)
            self.push_suggestion(LogMsg.RenameForAvoidDuplication)
        }
        self.check_type_alias_decl_kind(ta, self)
    }

    // Checks current package file's type alias declarations.
    fn check_type_alias_decls(mut &self): (ok: bool) {
        for (_, mut ta) in self.file.type_aliases {
            self.check_type_alias_decl_dup(ta)

            // Break checking if type alias has error.
            if self.errors.len > 0 {
                ret false
            }
        }
        ret true
    }

    fn check_enum_items_dup(mut self, e: &Enum) {
        for _, item in e.items {
            if is_ignore_ident(item.ident) {
                self.push_err(item.token, LogMsg.IgnoreIdent)
            } else {
                for _, citem in e.items {
                    if item == citem {
                        break
                    } else if item.ident == citem.ident {
                        self.push_err(item.token, LogMsg.DuplicatedIdent, item.ident)
                        self.push_suggestion(LogMsg.RenameForAvoidDuplication)
                        break
                    }
                }
            }
        }
    }

    fn check_enum_items_str(mut &self, mut &e: &Enum) {
        for (_, mut item) in e.items {
            if item.auto_expr() {
                item.value = &Value{
                    data: &Data{
                        constant: Const.new_str(item.ident),
                    },
                }
                item.value.data.model = item.value.data.constant
            } else {
                let mut d = self.eval(self).eval_expr(item.value.expr)
                if d == nil {
                    continue
                }

                if !d.is_const() {
                    self.push_err(item.value.expr.token, LogMsg.ExprNotConst)
                }

                self.check_assign_type(false, e.kind.kind, d, item.token)
                item.value.data = d
            }
        }
    }

    fn check_enum_items_int(mut &self, mut &e: &Enum) {
        let mut max = u64(types::max(e.kind.kind.prim().to_str()))
        for (i, mut item) in e.items {
            if max == 0 {
                self.push_err(item.token, LogMsg.OverflowLimits)
            } else {
                max--
            }

            if item.auto_expr() {
                item.value = &Value{
                    data: &Data{
                        constant: Const.new_u64(max - (max - u64(i))),
                    },
                }
                item.value.data.model = item.value.data.constant
            } else {
                let mut d = self.eval(self).eval_expr(item.value.expr)
                if d == nil {
                    continue
                }

                if !d.is_const() {
                    self.push_err(item.value.expr.token, LogMsg.ExprNotConst)
                }

                self.check_assign_type(false, e.kind.kind, d, item.token)
                item.value.data = d
            }
        }
    }

    fn check_enum_decl(mut &self, mut &e: &Enum) {
        if is_ignore_ident(e.ident) {
            self.push_err(e.token, LogMsg.IgnoreIdent)
        } else if self.is_duplicated_ident(uintptr(e), e.ident, false) {
            self.push_err(e.token, LogMsg.DuplicatedIdent, e.ident)
            self.push_suggestion(LogMsg.RenameForAvoidDuplication)
        }

        if e.items.len == 0 {
            self.push_err(e.token, LogMsg.NoMemberInEnum, e.ident)
        }

        self.check_enum_items_dup(e)

        if e.kind != nil {
            if !self.check_type(e.kind, self) {
                ret
            }
        } else {
            // Set to default type.
            e.kind = &TypeSymbol{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Int),
                },
            }
        }

        let mut t = e.kind.kind.prim()
        if t == nil {
            self.push_err(e.token, LogMsg.InvalidTypeSource)
            ret
        }

        // Check items.
        match {
        | t.is_str():
            self.check_enum_items_str(e)

        | types::is_int(t.to_str()):
            self.check_enum_items_int(e)

        |:
            self.push_err(e.token, LogMsg.InvalidTypeSource)
        }
    }

    // Checks current package file's enum declarations.
    fn check_enum_decls(mut &self): (ok: bool) {
        for (_, mut e) in self.file.enums {
            self.check_enum_decl(e)

            // Break checking if type alias has error.
            if self.errors.len > 0 {
                ret false
            }
        }
        ret true
    }

    fn check_decl_generics(mut self, &generics: []&ast::GenericDecl): (ok: bool) {
        ok = true
        for i, g in generics {
            if is_ignore_ident(g.ident) {
                self.push_err(g.token, LogMsg.IgnoreIdent)
                ok = false
                continue
            }

            // Check duplications.
        duplication_lookup:
            for j, ct in generics {
                match {
                | j >= i:
                    // Skip current and following generics.
                    break duplication_lookup

                | g.ident == ct.ident:
                    self.push_err(g.token, LogMsg.DuplicatedIdent, g.ident)
                    self.push_suggestion(LogMsg.RenameForAvoidDuplication)
                    ok = false
                    break duplication_lookup
                }
            }
        }
        ret
    }

    fn check_fn_decl_params_dup(mut self, &f: &Fn): (ok: bool) {
        ok = true
    check:
        for i, p in f.params {
            // Lookup in generics.
            for _, g in f.generics {
                if p.ident == g.ident {
                    ok = false
                    self.push_err(p.token, LogMsg.DuplicatedIdent, p.ident)
                    self.push_suggestion(LogMsg.RenameForAvoidDuplication)
                    continue check
                }
            }

        params_lookup:
            for j, jp in f.params {
                match {
                | j >= i:
                    // Skip current and following parameters.
                    break params_lookup

                | is_anon_ident(p.ident) || is_anon_ident(jp.ident):
                    // Skip anonymous parameters.
                    break params_lookup

                | p.ident == jp.ident:
                    ok = false
                    self.push_err(p.token, LogMsg.DuplicatedIdent, p.ident)
                    self.push_suggestion(LogMsg.RenameForAvoidDuplication)
                    continue check
                }
            }
        }
        ret
    }

    fn check_fn_decl_result_dup(mut self, &f: &Fn): (ok: bool) {
        ok = true

        if f.is_void() {
            ret
        }

        // Check duplications.
        for i, v in f.result.idents {
            if is_ignore_ident(v.kind) {
                continue // Skip anonymous return variables.
            }

            // Lookup in generics.
            for _, g in f.generics {
                if v.kind == g.ident {
                    goto exist
                }
            }

            // Lookup in parameters.
            for _, p in f.params {
                if v.kind == p.ident {
                    goto exist
                }
            }

            // Lookup in return identifiers.
        itself_lookup:
            for j, jv in f.result.idents {
                match {
                | j >= i:
                    // Skip current and following identifiers.
                    break itself_lookup

                | jv.kind == v.kind:
                    goto exist
                }
            }
            continue
        exist:
            self.push_err(v, LogMsg.DuplicatedIdent, v.kind)
            self.push_suggestion(LogMsg.RenameForAvoidDuplication)
            ok = false
        }

        ret
    }

    fn check_fn_decl_types(mut &self, mut &f: &Fn): (ok: bool) {
        ok = true

        let mut generics = f.generics
        if f.owner != nil {
            generics = append(generics, f.owner.generics...)
        }

        for (_, mut p) in f.params {
            if !p.is_self() {
                let mut kind = self.build_non_generic_type_kind(p.kind.decl, generics)
                ok = kind != nil && ok
                p.kind.kind = kind
            }
        }

        if !f.is_void() {
            let mut kind = self.build_non_generic_type_kind(f.result.kind.decl, generics)
            ok = kind != nil && ok
            f.result.kind.kind = kind
        }

        ret ok
    }

    // Checks generics, parameters and return type.
    // Not checks scope, and other things.
    fn check_fn_decl_prototype(mut &self, mut &f: &Fn): (ok: bool) {
        if f.exceptional && f.cpp_linked {
            self.push_err(f.token, LogMsg.CDefineExceptional)
            ret false
        }

        if f.exceptional {
            if f.is_entry_point() {
                self.push_err(f.token, LogMsg.ExceptionalEntryPoint)
            } else if f.is_init() {
                self.push_err(f.token, LogMsg.ExceptionalInit)
            }
        }

        match {
        | !self.check_decl_generics(f.generics): ret false
        | !self.check_fn_decl_params_dup(f):     ret false
        | !self.check_fn_decl_result_dup(f):     ret false
        | !self.check_fn_decl_types(f):          ret false
        |:                                       ret true
        }
    }

    fn check_trait_decl_method(mut &self, mut &f: &Fn) {
        if is_ignore_ident(f.ident) {
            self.push_err(f.token, LogMsg.IgnoreIdent)
        }

        self.check_fn_decl_prototype(f)
        f.sema = self
    }

    fn check_trait_decl_methods(mut &self, mut &t: &Trait) {
        for (i, mut f) in t.methods {
            self.check_trait_decl_method(f)
            t.mutable = t.mutable || f.params[0].mutable

            // Break checking if type alias has error.
            if self.errors.len > 0 {
                ret
            }

            // Check duplications.
        duplicate_lookup:
            for j, jf in t.methods {
                // NOTE:
                //  Ignore identifier checking is unnecessary here.
                //  Because ignore identifiers logs error.
                //  Errors breaks checking, so here is unreachable code for
                //  ignore identified methods.
                match {
                | j >= i:
                    // Skip current and following methods.
                    break duplicate_lookup

                | f.ident == jf.ident:
                    self.push_err(f.token, LogMsg.DuplicatedIdent, f.ident)
                    self.push_suggestion(LogMsg.RenameForAvoidDuplication)
                    break duplicate_lookup
                }
            }
        }
    }

    fn check_trait_decl(mut &self, mut &t: &Trait) {
        if is_ignore_ident(t.ident) {
            self.push_err(t.token, LogMsg.IgnoreIdent)
        } else if self.is_duplicated_ident(uintptr(t), t.ident, false) {
            self.push_err(t.token, LogMsg.DuplicatedIdent, t.ident)
            self.push_suggestion(LogMsg.RenameForAvoidDuplication)
        }

        self.check_trait_decl_methods(t)
    }

    // Checks current package file's trait declarations.
    fn check_trait_decls(mut &self): (ok: bool) {
        for (_, mut t) in self.file.traits {
            self.check_trait_decl(t)

            // Break checking if type alias has error.
            if self.errors.len > 0 {
                ret false
            }
        }
        ret true
    }

    fn check_trait_impl_methods(mut self, mut &base: &Trait, &ipl: &Impl): (ok: bool) {
        ok = true
        for _, f in ipl.methods {
            if base.find_method(f.ident) == nil {
                self.push_err(f.token, LogMsg.TraitHaveNotIdent, base.ident, f.ident)
                ok = false
            }
        }
        ret
    }

    fn impl_to_struct(mut &self, mut &dest: &Struct, mut &ipl: &Impl): (ok: bool) {
        ok = true

        // Methods.
        for (_, mut f) in ipl.methods {
            if dest.find_method(f.ident, f.statically) != nil || dest.find_field(f.ident) != nil {
                self.push_err(f.token, LogMsg.StructAlreadyHaveIdent, dest.ident, f.ident)
                ok = false
                continue
            }

            if dest.generics.len > 0 && f.generics.len > 0 {
                for _, fg in f.generics {
                    for _, dg in dest.generics {
                        if fg.ident == dg.ident {
                            self.push_err(fg.token, LogMsg.MethodHasGenericWithSameIdent)
                            ok = false
                        }
                    }
                }
            }

            self.check_directives(f.directives, f)

            f.sema = self
            f.owner = dest
            dest.methods = append(dest.methods, f)
        }

        for (_, mut v) in ipl.statics {
            const STATIC = true
            if dest.find_method(v.ident, STATIC) != nil || dest.find_static(v.ident) != nil {
                self.push_err(v.token, LogMsg.StructAlreadyHaveIdent, dest.ident, v.ident)
                ok = false
                continue
            }

            self.check_var_decl(v, self)
            self.check_type_var(v, self)
            dest.statics = append(dest.statics, v)
        }
        ret
    }

    // Implement trait to destination.
    fn impl_trait(mut &self, mut &decl: &Impl) {
        let mut base_t = self.select_type(decl.base)
        if base_t == nil {
            ret
        }
        let mut base = base_t.trt()
        if base == nil {
            self.push_err(decl.base.token, LogMsg.ImplInvalidBase)
            self.push_suggestion(LogMsg.ExpectedTrait)
            ret
        }

        let mut dest_t = self.select_type(decl.dest)
        if dest_t == nil {
            ret
        }
        let mut dest_s = dest_t.strct()
        if dest_s == nil {
            self.push_err(decl.dest.token, LogMsg.ImplInvalidDest)
            self.push_suggestion(LogMsg.ExpectedStruct)
            ret
        }

        let mut dest = dest_s.decl

        if dest.token.file.dir() != self.file.file.dir() {
            self.push_err(decl.dest.token, LogMsg.IllegalImplOutOfPackage)
            ret
        }

        base.implemented = append(base.implemented, dest)
        dest.implements = append(dest.implements, base)

        if decl.statics.len > 0 {
            self.push_err(decl.statics[0].token, LogMsg.TraitImplHasStatic)
        }

        match {
        | !self.check_trait_impl_methods(base, decl): ret
        | !self.impl_to_struct(dest, decl):           ret
        }
    }

    fn impl_struct(mut &self, mut &decl: &Impl) {
        let mut dest_t = self.select_type(decl.dest)
        if dest_t == nil {
            ret
        }
        let mut dest_s = dest_t.strct()
        if dest_s == nil {
            self.push_err(decl.dest.token, LogMsg.ImplInvalidDest)
            self.push_suggestion(LogMsg.ExpectedStruct)
            ret
        }

        let mut dest = dest_s.decl
        if dest.token.file.dir() != self.file.file.dir() {
            self.push_err(decl.dest.token, LogMsg.IllegalImplOutOfPackage)
            ret
        }

        match {
        | !self.impl_to_struct(dest, decl):
            ret
        }
    }

    // Implement implementation.
    fn impl_impl(mut &self, mut &decl: &Impl) {
        match {
        | decl.is_trait_impl():  self.impl_trait(decl)
        | decl.is_struct_impl(): self.impl_struct(decl)
        }
    }

    // Checks variable declaration.
    // No checks duplicated identifiers.
    fn check_var_decl(mut &self, mut &decl: &Var, mut l: Lookup) {
        if is_ignore_ident(decl.ident) {
            self.push_err(decl.token, LogMsg.IgnoreIdent)
        }

        if decl.is_type_inferred() {
            if !decl.is_initialized() {
                self.push_err(decl.token, LogMsg.MissingValueForTypeInference)
            }
        } else {
            _ = self.check_type(decl.kind, l)
        }

        if decl.constant && decl.reference {
            self.push_err(decl.token, LogMsg.ConstRef)
        }

        if !decl.is_initialized() {
            if decl.constant {
                self.push_err(decl.token, LogMsg.ConstVarNotHaveExpr)
            }

            if decl.statically {
                self.push_err(decl.token, LogMsg.StaticNotHaveExpr)
            }

            if decl.reference {
                self.push_err(decl.token, LogMsg.RefNotInited)
            }
        }
    }

    // Checks variable declaration for global scope.
    // Checks duplicated identifiers by Sema.
    fn check_global_var_decl(mut &self, mut &decl: &Var) {
        if self.is_duplicated_ident(uintptr(decl), decl.ident, decl.cpp_linked) {
            self.push_err(decl.token, LogMsg.DuplicatedIdent, decl.ident)
            self.push_suggestion(LogMsg.RenameForAvoidDuplication)
        }
        if decl.cpp_linked && decl.constant {
            self.push_err(decl.token, LogMsg.CppLinkedVarIsConst)
        }
        if !decl.cpp_linked && !decl.constant && !decl.statically {
            self.push_err(decl.token, LogMsg.GlobalNotStatic)
            self.push_suggestion(LogMsg.UseStaticKeywordToDef)
        }

        self.check_directives(decl.directives, decl)

        self.check_var_decl(decl, self)
    }

    // Checks current package file's global variable declarations.
    fn check_global_decls(mut &self): (ok: bool) {
        for (_, mut decl) in self.file.vars {
            self.check_global_var_decl(decl)

            // Break checking if type alias has error.
            if self.errors.len > 0 {
                ret false
            }
        }
        ret true
    }

    fn check_struct_trait_impl(mut &self, mut &strct: &Struct, mut &trt: &Trait): (ok: bool) {
        for (_, mut tf) in trt.methods {
            let mut exist = false
            let mut sf = strct.find_method(tf.ident, tf.statically)
            let tf_k = self.get_trait_check_fn_kind(tf)
            if sf != nil {
                let mut sf_k = self.get_trait_check_fn_kind(sf)
                exist = (
                    tf_k.decl.public == sf_k.decl.public &&
                    tf_k.decl.ident == sf_k.decl.ident &&
                    tf_k.equals(&TypeKind{kind: sf_k})
                )
            }
            if exist {
                let d = find_directive(sf.directives, Directive.Deprecated)
                if d != nil {
                    self.push_err(d.tag, LogMsg.TraitImplDeprecated)
                }
                ok = false
            } else {
                const IDENT = true
                let mut s = tf_k.get_kind_str(IDENT)
                if tf.public {
                    s = "pub " + s
                }
                self.push_err(strct.token, LogMsg.NotImplTraitDef, trt.ident, s)
                ok = false
            }
        }
        ret
    }

    fn check_struct_impls(mut &self, mut &s: &Struct): (ok: bool) {
        ok = true
        for (_, mut trt) in s.implements {
            ok = self.check_struct_trait_impl(s, trt) && ok
        }
        ret ok
    }

    fn check_struct_fields(mut &self, mut &st: &Struct): (ok: bool) {
        ok = true

        let mut tc = &TypeChecker{
            s:               self,
            lookup:          self,
            ignore_generics: st.generics,
            referencer: &Referencer{
                ident: st.ident,
                owner: st,
            },
        }

        let n = st.instances.len
        for (_, mut f) in st.fields {
            f.owner = st
            f.kind.kind = tc.check_decl(f.kind.decl)
            ok = f.kind.kind != nil && ok

            for _, cf in st.fields {
                if f == cf {
                    break
                } else if f.ident == cf.ident {
                    self.push_err(f.token, LogMsg.DuplicatedIdent, f.ident)
                    self.push_suggestion(LogMsg.RenameForAvoidDuplication)
                    ok = false
                }
            }
        }

        // Save itself for legal cycles like *Struct, or &Struct.
        if ok && n != st.instances.len {
            tc.referencer = nil
            st.instances = st.instances[:n]
            for (_, mut f) in st.fields {
                f.kind.kind = tc.check_decl(f.kind.decl)
            }
        }

        ret ok
    }

    fn check_struct_decl_methods(mut &self, mut &s: &Struct): (ok: bool) {
        for (_, mut m) in s.methods {
            if !self.check_fn_decl_types(m) {
                ret false
            }
        }
        ret true
    }

    fn check_struct_decl(mut &self, mut &s: &Struct) {
        if is_ignore_ident(s.ident) {
            self.push_err(s.token, LogMsg.IgnoreIdent)
        } else if self.is_duplicated_ident(uintptr(s), s.ident, s.cpp_linked) {
            self.push_err(s.token, LogMsg.DuplicatedIdent, s.ident)
            self.push_suggestion(LogMsg.RenameForAvoidDuplication)
        }

        self.check_directives(s.directives, s)

        s.sema = self
        match {
        | !self.check_decl_generics(s.generics): ret
        | !self.check_struct_fields(s):          ret
        | !self.check_struct_decl_methods(s):    ret
        | !self.check_struct_impls(s):           ret
        }
    }

    // Checks current package file's structure declarations.
    fn check_struct_decls(mut &self): (ok: bool) {
        for (_, mut s) in self.file.structs {
            self.check_struct_decl(s)

            // Break checking if type alias has error.
            if self.errors.len > 0 {
                ret false
            }
        }

        ret true
    }

    fn check_fn_decl(mut &self, mut &f: &Fn) {
        if is_ignore_ident(f.ident) {
            self.push_err(f.token, LogMsg.IgnoreIdent)
        } else if self.is_duplicated_ident(uintptr(f), f.ident, f.cpp_linked) {
            self.push_err(f.token, LogMsg.DuplicatedIdent, f.ident)
            self.push_suggestion(LogMsg.RenameForAvoidDuplication)
        }

        self.check_directives(f.directives, f)

        f.sema = self
        _ = self.check_fn_decl_prototype(f)
    }

    // Checks current package file's function declarations.
    fn check_fn_decls(mut &self): (ok: bool) {
        for (_, mut f) in self.file.funcs {
            self.check_fn_decl(f)

            // Break checking if type alias has error.
            if self.errors.len > 0 {
                ret false
            }
        }
        ret true
    }

    fn push_cycle_error(self, &st1: &Struct, &st2: &Struct, mut &message: str) {
        const PADDING = 4

        let refers_to = logf(LogMsg.RefersTo, st1.ident, st2.ident)
        message = strings::repeat(" ", PADDING) + refers_to + "\n" + message
    }

    fn check_cross_cycle(self, &st1: &Struct, &st2: &Struct, mut &message: str): bool {
        for _, u in st2.uses {
            if u == st1 {
                self.push_cycle_error(st2, u, message)
                ret false
            }

            if !self.check_cross_cycle(st1, u, message) {
                self.push_cycle_error(st2, u, message)
                ret false
            }
        }

        ret true
    }

    fn check_struct_derive_illegal_cycles(mut self, derive: str, &st1: &Struct, mut &k: &TypeKind): (ok: bool) {
        let mut st2 = get_struct_from_kind(k)
        if st2 == nil {
            ret true
        }

        // Check illegal cycle for itself.
        // Because refers's owner is ta.
        if st1 == st2 {
            self.push_err(st1.token, LogMsg.DeriveIllegalCycleRefersItself, derive, st1.ident)
            ret false
        }

        let mut message = ""

        if !self.check_cross_cycle(st1, st2, message) {
            let mut err_msg = message
            message = ""
            self.push_cycle_error(st1, st2, message)
            err_msg = err_msg + message
            self.push_err(st1.token, LogMsg.DeriveIllegalCrossCycle, derive, err_msg)
            ret false
        }

        ret true
    }

    fn check_struct_ins_derive_clone(mut self, mut st: &StructIns): (ok: bool) {
        if !st.decl.is_derives(Derive.Clone) {
            ret true
        }

        for (_, mut f) in st.fields {
            if f.kind == nil || !f.kind.mutable() {
                continue
            }

            if !f.kind.supports_cloning() {
                self.push_err(st.decl.token, LogMsg.TypeNotCompatibleForDerive, f.kind.to_str(), Derive.Clone)
                ret false
            }

            if !self.check_struct_derive_illegal_cycles(Derive.Clone, st.decl, f.kind) {
                ret false
            }
        }

        ret true
    }

    fn check_struct_derive_clone(mut self, mut &st: &Struct): bool {
        ret self.check_struct_ins_derive_clone(st.instance())
    }

    fn check_file_derives(mut self): (ok: bool) {
        // Check derives.
        for (_, mut st) in self.file.structs {
            ok = self.check_struct_derive_clone(st)
            if !ok {
                break
            }
        }

        ret ok
    }

    fn check_package_derives(mut self) {
        for (_, mut f) in self.files {
            self.set_current_file(f)
            let ok = self.check_file_derives()
            if !ok {
                ret
            }
        }
    }

    // Checks declarations of all package files.
    // Breaks checking if checked file failed.
    fn check_package_decls(mut &self) {
        for (_, mut f) in self.files {
            self.set_current_file(f)
            if !self.check_type_alias_decls() {
                ret
            }
        }

        for (_, mut f) in self.files {
            self.set_current_file(f)
            if !self.check_trait_decls() {
                ret
            }
        }

        for (_, mut f) in self.files {
            self.set_current_file(f)
            if !self.check_global_decls() {
                ret
            }
        }

        for (_, mut f) in self.files {
            self.set_current_file(f)
            if !self.check_fn_decls() {
                ret
            }
        }

        for (_, mut f) in self.files {
            self.set_current_file(f)
            if !self.check_struct_decls() {
                ret
            }
        }

        self.check_package_derives()
    }

    fn check_data_for_type_inference(mut self, &d: &Data, &err_token: Token) {
        match {
        | d.is_nil():
            self.push_err(err_token, LogMsg.NilForTypeInference)

        | d.is_void():
            self.push_err(err_token, LogMsg.VoidForTypeInference)

        | d.kind.variadic:
            self.push_err(err_token, LogMsg.InvalidExprForTypeInference)
        }
    }

    fn check_var(mut &self, mut &v: &Var) {
        if v.cpp_linked {
            ret
        }

        if v.is_type_inferred() {
            // Build new TypeSymbol because
            // auto-type symbols are nil.
            v.kind = &TypeSymbol{kind: v.value.data.kind}

            self.check_data_for_type_inference(v.value.data, v.value.expr.token)
        } else {
            let mut arr = v.kind.kind.arr()
            if arr != nil {
                if arr.auto {
                    let data_arr = v.value.data.kind.arr()
                    if data_arr != nil {
                        arr.n = data_arr.n
                    }
                }
            }

            self.check_assign_type(v.reference, v.kind.kind, v.value.data, v.value.expr.token)
        }

        if v.reference && !is_valid_for_ref(v.kind.kind) {
            self.push_err(v.token, LogMsg.RefPointsToInvalidType, v.kind.kind.to_str())
        }

        self.check_validity_for_init_expr(
            v.mutable,
            v.reference,
            v.kind.kind,
            v.value.data,
            v.value.expr.token)

        if v.constant {
            if !v.value.data.is_const() {
                self.push_err(v.value.expr.token, LogMsg.ExprNotConst)
            }
        } else {
            v.value.data.constant = nil
        }

        // Remove kind for avoid more tuple-type errors.
        if v.kind.kind.tup() != nil {
            v.kind.kind = nil
        }
    }

    fn check_type_var(mut &self, mut &decl: &Var, mut l: Lookup) {
        if decl.cpp_linked || !decl.is_initialized() {
            ret
        }

        let mut eval = if decl.kind != nil {
            self.evalpd(l, decl.kind.kind, decl)
        } else {
            self.evalpd(l, nil, decl)
        }
        eval.immutable = !decl.mutable
        decl.value.data = eval.eval_expr(decl.value.expr)
        if decl.value.data == nil {
            ret // Skip checks if error ocurrs.
        }

        self.check_var(decl)
    }

    // Checks types of current package file's global variables.
    fn check_global_types(mut &self) {
        for (_, mut decl) in self.file.vars {
            if decl.is_initialized() && decl.value.data == nil ||
                decl.is_type_inferred() && decl.kind.kind == nil {
                self.check_type_var(decl, self)
            }
        }
    }

    fn check_type_method(mut &self, mut &strct: &StructIns, mut &f: &Fn) {
        if f.cpp_linked {
            ret
        }

        // Generic instances are checked instantly.
        if f.generics.len > 0 {
            ret
        }

        if f.instances.len == 0 {
            let mut ins = f.instance()
            ins.owner = strct
            f.append_instance(ins)
            self.reload_fn_ins_types(ins)
            ins.reloaded = true
        }

        for (_, mut ins) in f.instances {
            if ins.scope.stmts.len > 0 {
                // Checked
                continue
            }
            self.check_fn_ins(ins)
        }
    }

    fn check_field_defaults(mut &self, mut &ins: &StructIns) {
        let mut eval = self.eval(self)
        for (_, mut f) in ins.fields {
            // Skip this field if not has default value.
            if f.decl.default == nil {
                continue
            }
            eval.prefix = f.kind
            eval.field = f
            f.default = eval.eval_expr(f.decl.default)

            // Skip if eval returned nil.
            // Relevant error(s) logged by eval.
            if f.default == nil {
                continue
            }

            const REFERENCE = false // Fields cannot be reference.
            self.check_assign_type(REFERENCE, f.kind, f.default, f.decl.default.token)
        }
    }

    fn check_type_struct(mut &self, mut &strct: &Struct) {
        if strct.cpp_linked {
            ret
        }

        // Generic instances are checked instantly.
        if strct.generics.len > 0 {
            ret
        }

        if strct.instances.len == 0 {
            let mut ins = strct.instance()
            ins.checked = true
            strct.append_instance(ins)
        }

        for (_, mut ins) in strct.instances {
            self.check_field_defaults(ins)
            for (_, mut f) in ins.methods {
                self.check_type_method(ins, f)
            }
        }
    }

    fn check_struct_types(mut &self) {
        for (_, mut s) in self.file.structs {
            self.check_type_struct(s)
        }
    }

    fn check_rets(mut self, mut &f: &FnIns) {
        if f.decl.is_void() {
            ret
        }

        let ok = has_ret(f.scope)
        if !ok {
            self.push_err(f.decl.token, LogMsg.MissingRet)
        }
    }

    fn check_fn_ins_sc(mut self, mut &f: &FnIns, mut &sc: &ScopeChecker) {
        if f.decl.cpp_linked {
            ret
        }

        let mut vars = build_ret_vars(f)

        sc.table.vars = append(sc.table.vars, vars...)
        sc.table.vars = append(sc.table.vars, build_param_vars(f)...)
        sc.table.type_aliases = append(sc.table.type_aliases, build_generic_type_aliases(f)...)

        sc.check(f.decl.scope, f.scope)

        // Append return variables.
        if vars.len > 0 {
            let mut stmts = make([]St, 0, f.scope.stmts.len+vars.len)
            for (_, mut v) in vars {
                stmts = append(stmts, v)
            }

            stmts = append(stmts, f.scope.stmts...)
            f.scope.stmts = stmts
        }

        self.check_rets(f)
    }

    fn check_fn_ins(mut &self, mut &f: &FnIns) {
        if f.decl.cpp_linked {
            ret
        }

        let mut old = f.decl.sema.file
        defer { f.decl.sema.set_current_file(old) }
        let mut file = find_file(f.decl.sema.files, f.decl.token.file)
        if file != nil {
            f.decl.sema.set_current_file(file)
        }

        let mut sc = new_scope_checker(f.decl.sema, f)
        self.check_fn_ins_sc(f, sc)

        if f.decl.sema != self {
            self.errors = append(self.errors, f.decl.sema.errors...)
            f.decl.sema.errors = nil
        }
    }

    fn check_type_fn(mut &self, mut &f: &Fn) {
        if f.cpp_linked {
            ret
        }

        // Generic instances are checked instantly.
        if f.generics.len > 0 {
            ret
        }

        for (_, mut ins) in f.instances {
            self.check_fn_ins(ins)
        }
    }

    fn check_test_fn(mut self, mut &f: &FnIns) {
        if f.decl.public {
            self.push_err(f.decl.token, LogMsg.PubTestFn)
            self.push_suggestion(LogMsg.RemovePubModifier)
            ret
        }

        if f.params.len != 1 || f.result != nil {
            self.push_err(f.decl.token, LogMsg.WrongTestFnDecl)
            self.push_suggestion(LogMsg.UseExpectedTestFnDecl)
            ret
        }

        let mut sptr = f.params[0].kind.sptr()
        if sptr == nil {
            self.push_err(f.decl.token, LogMsg.WrongTestFnDecl)
            self.push_suggestion(LogMsg.UseExpectedTestFnDecl)
            ret
        }

        let s = sptr.elem.strct()
        if s == nil || !is_std_package(s.decl.token.file.path(), "testing") {
            self.push_err(f.decl.token, LogMsg.WrongTestFnDecl)
            self.push_suggestion(LogMsg.UseExpectedTestFnDecl)
            ret
        }
    }

    fn precheck_type_fn(mut &self, mut &f: &Fn) {
        if f.cpp_linked {
            ret
        }

        // Generic instances are checked instantly.
        if f.generics.len > 0 {
            ret
        }

        if f.instances.len == 0 {
            let mut ins = f.instance()
            f.instances = append(f.instances, ins)
            self.reload_fn_ins_types(ins)
            ins.reloaded = true

            if has_directive(f.directives, Directive.Test) {
                self.check_test_fn(ins)
            }
        }
    }

    // Prechecks types of current package file's functions.
    fn precheck_fn_types(mut &self) {
        for (_, mut decl) in self.file.funcs {
            self.precheck_type_fn(decl)
        }
    }

    // Checks types of current package file's functions.
    fn check_fn_types(mut &self) {
        for (_, mut decl) in self.file.funcs {
            self.check_type_fn(decl)
        }
    }

    // Checks all types of all package files.
    // Breaks checking if checked file failed.
    fn check_package_types(mut &self) {
        for (_, mut f) in self.files {
            self.set_current_file(f)
            self.check_global_types()
        }

        for (_, mut f) in self.files {
            self.set_current_file(f)
            self.precheck_fn_types()
        }

        for (_, mut f) in self.files {
            self.set_current_file(f)
            self.check_fn_types()
        }

        for (_, mut f) in self.files {
            self.set_current_file(f)
            self.check_struct_types()
        }
    }

    fn set_file_sema_fields(mut &self) {
        for (_, mut f) in self.file.funcs {
            f.sema = self
        }

        for (_, mut st) in self.file.structs {
            st.sema = self
        }
    }

    fn set_sema_fields(mut &self) {
        for (_, mut file) in self.files {
            self.set_current_file(file)
            self.set_file_sema_fields()
        }
    }

    fn check(mut &self, mut &files: []&SymbolTable) {
        self.files = files

        self.check_imports()
        // Break checking if imports has error.
        if self.errors.len > 0 {
            ret
        }

        self.check_enums()
        // Break checking if enums has error.
        if self.errors.len > 0 {
            ret
        }

        self.set_sema_fields()

        self.impl_impls()
        // Break checking if imports has error.
        if self.errors.len > 0 {
            ret
        }

        self.check_package_decls()

        // Break checking if imports has error.
        if self.errors.len > 0 {
            ret
        }

        self.check_package_types()
    }
}
