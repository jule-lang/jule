// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::jule::ast::{
    self,
    Expr,
    ScopeTree,
    TypeAliasDecl,
    VarDecl,
    NodeData,
    AssignSt,
    FnCallExpr,
    WhileKind,
    RangeKind,
    Iter,
    Comment,
    LabelSt,
    TupleExpr,
    UnsafeExpr,
    AssignLeft,
    MatchCase,
    CoExpr,
    UseExpr,
}
use std::jule::build::{LogMsg}
use std::jule::constant::{Const}
use std::jule::lex::{
    Token,
    TokenId,
    TokenKind,
    is_ignore_ident,
    is_anon_ident,
    is_postfix_op,
}
use types for std::jule::types

// Statement type.
pub type St: any

fn new_scope_checker_base(mut &s: &Sema, mut owner: &FnIns): &ScopeChecker {
    ret &ScopeChecker{
        s:     s,
        owner: owner,
        table: &SymbolTable{},
    }
}

fn new_scope_checker(mut &s: &Sema, mut owner: &FnIns): &ScopeChecker {
    let mut base = new_scope_checker_base(s, owner)
    base.labels = new([]&ScopeLabel, nil)
    base.gotos = new([]&ScopeGoto, nil)
    ret base
}

// Returns label by identifier.
// Returns nil if not exist any label in this identifier.
// Lookups given scope and parent scopes.
fn find_label_parent(ident: str, mut scope: &ScopeChecker): &ScopeLabel {
    let mut label = scope.find_label_scope(ident)
    for label == nil {
        if scope.parent == nil || scope.owner != nil {
            ret nil
        }

        scope = scope.parent
        label = scope.find_label_scope(ident)
    }

    ret label
}

fn stmt_is_goto_scope(&stmt: any, &sc: &Scope): bool {
    match type stmt {
    | &Scope:
        ret (&Scope)(stmt) == sc

    | &InfIter:
        ret (&InfIter)(stmt).scope == sc

    | &RangeIter:
        ret (&RangeIter)(stmt).scope == sc

    | &WhileIter:
        ret (&WhileIter)(stmt).scope == sc

    | &Match:
        let m = (&Match)(stmt)
        for _, c in m.cases {
            if c.scope == sc {
                ret true
            }
        }
        ret m.default != nil && m.default.scope == sc

    | &Conditional:
        let c = (&Conditional)(stmt)
        for _, elif in c.elifs {
            if elif.scope == sc {
                ret true
            }
        }
        ret c.default != nil && c.default.scope == sc

    |:
        ret false
    }
}

fn count_match_type(&m: &Match, &t: &TypeKind): int {
    let mut n = 0
    let kind = t.to_str()
loop:
    for _, c in m.cases {
        if c == nil {
            continue
        }

        for _, expr in c.exprs {
            // Break loop because this expression is not parsed yet.
            // So, parsed cases finished.
            if expr == nil {
                break loop
            }

            if kind == (&TypeKind)(expr.model).to_str() {
                n++
            }
        }
    }
    ret n
}

fn get_datas_from_tuple_data(mut &d: &Data): []&Data {
    if d.kind.tup() != nil {
        match type d.model {
        | &TupleExprModel:
            ret (&TupleExprModel)(d.model).datas

        |:
            let mut t = d.kind.tup()
            let mut r = make([]&Data, 0, t.types.len)
            for (_, mut kind) in t.types {
                r = append(r, &Data{
                    mutable: true, // Function return.
                    kind:    kind,
                })
            }
            ret r
        }
    } else {
        ret [d]
    }
}

fn get_expr_models(mut &m: ExprModel): []ExprModel {
    match type m {
    | &TupleExpr:
        let mut tup = (&TupleExpr)(m)
        let mut models = make([]ExprModel, 0, tup.expr.len)
        for (_, mut expr) in tup.expr {
            models = append(models, expr.kind)
        }
        ret models

    |:
        ret [m]
    }
}

fn check_mut(mut &s: &Sema, &left: &Data, mut right: &Data, error_token: Token): (ok: bool) {
    match {
    | !left.mutable:
        s.push_err(error_token, LogMsg.AssignToNonMut)
        ret false

    | right != nil && !right.mutable && right.kind.mutable():
        s.push_err(error_token, LogMsg.AssignNonMutToMut)
        ret false

    |:
        ret true
    }
}

fn check_assign(mut &s: &Sema, mut &left: &Data, mut right: &Data, error_token: Token): (ok: bool) {
    let f = left.kind.fnc()
    if f != nil && f.decl != nil && f.decl.global {
        s.push_err(error_token, LogMsg.AssignTypeNotSupportValue)
        ret false
    }

    match {
    | left.is_const():
        s.push_err(error_token, LogMsg.AssignConst)
        s.push_suggestion(LogMsg.RemoveConstToAssign)
        ret false

    | !left.lvalue:
        s.push_err(error_token, LogMsg.AssignRequireLvalue)
        ret false

    | !check_mut(s, left, right, error_token):
        ret false

    |:
        ret true
    }
}

fn is_valid_ast_st_for_next_st(mut &n: NodeData): bool {
    match type n {
    | &AssignSt:
        ret !(&AssignSt)(n).declarative

    | &FnCallExpr
    | &Expr:
        ret true

    |:
        ret false
    }
}

fn is_valid_st_for_next_st(&st: St): bool {
    match type st {
    | &FnCallExprModel
    | &Postfix
    | &Assign
    | &MultiAssign:
        ret true

    | &Data:
        match type (&Data)(st).model {
        | &FnCallExprModel: ret true
        |:                  ret false
        }

    |:
        ret false
    }
}

fn st_is_def(&st: St): bool {
    match type st {
    | &Var: ret true
    |:      ret false
    }
}

// Scope.
pub struct Scope {
    pub parent:   &Scope
    pub unsafety: bool
    pub deferred: bool
    pub stmts:    []St
}

// Chain conditional node.
pub struct If {
    pub expr:  ExprModel
    pub scope: &Scope
}

// Default scope of conditional chain.
pub struct Else {
    pub scope: &Scope
}

// Conditional chain.
pub struct Conditional {
    pub elifs:   []&If // First not is root condition.
    pub default: &Else
}

// Infinity iteration.
pub struct InfIter {
    pub scope: &Scope
}

// While iteration.
pub struct WhileIter {
    pub expr:  ExprModel // Can be nil if iteration is while-next kind.
    pub next:  St        // Nil if iteration is not while-next kind.
    pub scope: &Scope
}

impl WhileIter {
    // Reports whether iteration is while-next kind.
    pub fn is_while_next(self): bool { ret self.next != nil }
}

// Range iteration.
pub struct RangeIter {
    pub expr:  &Data
    pub scope: &Scope
    pub key_a: &Var
    pub key_b: &Var
}

// Continue statement.
pub struct ContSt {
    pub it: uintptr
}

// Break statement.
pub struct BreakSt {
    pub it:   uintptr
    pub mtch: uintptr
}

// Label.
pub struct Label {
    pub ident: str
}

// Goto statement.
pub struct GotoSt {
    pub ident: str
}

// Postfix assignment.
pub struct Postfix {
    pub expr: ExprModel
    pub op:   str
}

// Assigment.
pub struct Assign {
    pub l:  &OperandExprModel
    pub r:  &OperandExprModel
    pub op: Token
}

// Multi-declarative assignment.
pub struct MultiAssign {
    pub l: []ExprModel // Nil models represents ingored expressions.
    pub r: ExprModel
}

// Match-Case.
pub struct Match {
    pub expr:       &Data
    pub type_match: bool
    pub cases:      []&Case
    pub default:    &Case
}

impl Match {
    // Reports whether match is type-match for generic type.
    pub fn is_generic_type_match(self): bool {
        ret self.type_match && self.expr != nil && self.expr.kind.generic
    }
}

// Match-Case case.
pub struct Case {
    pub owner: &Match
    pub scope: &Scope
    pub exprs: []&Data
    pub next:  &Case
}

impl Case {
    // Reports whether case is default.
    fn is_default(self): bool { ret self.exprs == nil }
}

// Fall statement.
pub struct FallSt {
    pub dest_case: uintptr
}

// Return statement.
pub struct RetSt {
    pub func: &FnIns
    pub vars: []&Var // Used "_" identifier to pass ignored vars for ordering.
    pub expr: ExprModel
}

struct ScopeLabel {
    token: Token
    label: &Label
    pos:   int
    scope: &ScopeChecker
    used:  bool
}

struct ScopeGoto {
    gt:    &std::jule::ast::GotoSt
    scope: &ScopeChecker
    pos:   int
}

// Scope checker.
struct ScopeChecker {
    s:           &Sema
    owner:       &FnIns // See developer reference (1).
    parent:      &ScopeChecker
    child_index: int // Index of child scope.
    table:       &SymbolTable
    scope:       &Scope
    tree:        &ScopeTree
    result:      &TypeKind // Result type for last statement.
    it:          uintptr
    cse:         uintptr
    labels:      &[]&ScopeLabel // All labels of all scopes.
    gotos:       &[]&ScopeGoto  // All gotos of all scopes.
    i:           int
}

impl Lookup for ScopeChecker {
    // Returns imported package by identifier.
    // Returns nil reference if not exist any package in this identifier.
    //
    // Lookups:
    //   - Sema.
    pub fn find_package(mut self, ident: str): &ImportInfo {
        ret self.s.find_package(ident)
    }

    // Returns imported package by selector.
    // Returns nil reference if selector returns false for all packages.
    // Returns nil reference if selector is nil.
    //
    // Lookups:
    //   - Sema.
    pub fn select_package(mut self, selector: fn(&ImportInfo): bool): &ImportInfo {
        ret self.s.select_package(selector)
    }

    // Returns variable by identifier and cpp linked state.
    // Returns nil reference if not exist any variable in this identifier.
    //
    // Lookups:
    //   - Current scope.
    //   - Parent scopes.
    //   - Sema.
    pub fn find_var(mut self, ident: str, cpp_linked: bool): &Var {
        // Search reverse for correct shadowing.
        const REVERSE = true
        let mut v = self.table.__find_var(ident, cpp_linked, REVERSE)
        if v != nil {
            ret v
        }

        let mut parent = self.parent
        for parent != nil {
            v = parent.table.__find_var(ident, cpp_linked, REVERSE)
            if v != nil {
                ret v
            }
            parent = parent.parent
        }

        ret self.s.find_var(ident, cpp_linked)
    }

    // Returns type alias by identifier and cpp linked state.
    // Returns nil reference if not exist any type alias in this identifier.
    //
    // Lookups:
    //   - Current scope.
    //   - Parent scopes.
    //   - Sema.
    pub fn find_type_alias(mut self, ident: str, cpp_linked: bool): &TypeAlias {
        // Search reverse for correct shadowing.
        const REVERSE = true
        let mut ta = self.table.__find_type_alias(ident, cpp_linked, REVERSE)
        if ta != nil {
            ret ta
        }

        let mut parent = self.parent
        for parent != nil {
            ta = parent.table.__find_type_alias(ident, cpp_linked, REVERSE)
            if ta != nil {
                ret ta
            }
            parent = parent.parent
        }

        ret self.s.find_type_alias(ident, cpp_linked)
    }

    // Returns struct by identifier and cpp linked state.
    // Returns nil reference if not exist any struct in this identifier.
    //
    // Lookups:
    //   - Sema.
    pub fn find_struct(mut self, ident: str, cpp_linked: bool): &Struct {
        ret self.s.find_struct(ident, cpp_linked)
    }

    // Returns function by identifier and cpp linked state.
    // Returns nil reference if not exist any function in this identifier.
    //
    // Lookups:
    //   - Sema.
    pub fn find_fn(mut self, ident: str, cpp_linked: bool): &Fn {
        ret self.s.find_fn(ident, cpp_linked)
    }

    // Returns trait by identifier.
    // Returns nil reference if not exist any trait in this identifier.
    //
    // Lookups:
    //   - Sema.
    pub fn find_trait(mut self, ident: str): &Trait {
        ret self.s.find_trait(ident)
    }

    // Returns enum by identifier.
    // Returns nil reference if not exist any enum in this identifier.
    //
    // Lookups:
    //   - Sema.
    pub fn find_enum(mut self, ident: str): &Enum {
        ret self.s.find_enum(ident)
    }
}

impl ScopeChecker {
    // Reports whether scope is unsafe.
    fn is_unsafe(mut &self): bool {
        let mut scope = self

    iter:
        if scope.scope.unsafety {
            ret true
        }

        if scope.parent != nil {
            scope = scope.parent
            goto iter
        }

        ret false
    }

    // Reports scope is root.
    // Accepts anonymous functions as root.
    fn is_root(self): bool {
        ret self.parent == nil || self.owner != nil
    }

    // Stop checking.
    fn stop(mut self) {
        self.i = -1
    }

    // Reports whether checking is stopped.
    fn stopped(self): bool {
        ret self.i == -1
    }

    // Reports scope is deferred.
    fn is_deferred(mut &self): bool {
        let mut scope = self

    iter:
        if scope.scope.deferred {
            ret true
        }

        if scope.parent != nil {
            scope = scope.parent
            goto iter
        }

        ret false
    }

    // Returns root scope.
    // Accepts anonymous functions as root.
    fn get_root(mut &self): &ScopeChecker {
        let mut root = self
        for root.parent != nil && root.owner == nil {
            root = root.parent
        }
        ret root
    }

    // Returns hard root scope, owner always represents root function of this scope.
    // Not accepts anonymous functions as root.
    fn get_hard_root(mut &self): &ScopeChecker {
        let mut root = self
        for root.parent != nil {
            root = root.parent
        }
        ret root
    }

    // Returns label by identifier.
    // Returns nil if not exist any label in this identifier.
    // Just lookups current scope.
    fn find_label(mut self, ident: str): &Label {
        for (_, mut st) in self.scope.stmts {
            match type st {
            | &Label:
                let mut label = (&Label)(st)
                if label.ident == ident {
                    ret label
                }
            }
        }
        ret nil
    }

    // Returns label by identifier.
    // Returns nil if not exist any label in this identifier.
    // Just lookups current scope.
    fn find_label_scope(mut &self, ident: str): &ScopeLabel {
        let mut label = self.find_label_all(ident)
        if label != nil && label.scope == self {
            ret label
        }

        ret nil
    }

    // Returns label by identifier.
    // Returns nil if not exist any label in this identifier.
    // Lookups all labels.
    fn find_label_all(mut self, ident: str): &ScopeLabel {
        for (_, mut lbl) in *self.labels {
            if lbl.label.ident == ident {
                ret lbl
            }
        }
        ret nil
    }

    // Reports this identifier duplicated in scope.
    // The "self" parameter represents address of exception identifier.
    // If founded identifier address equals to self, will be skipped.
    fn is_duplicated_ident(mut self, itself: uintptr, ident: str): bool {
        let v = self.find_var(ident, false)
        if v != nil && uintptr(v) != itself {
            if v.scope == nil { // Ignore globals.
                ret false
            }
            ret v.scope == self.scope || !self.s.is_flag(SemaFlag.Shadowing)
        }

        let ta = self.find_type_alias(ident, false)
        if ta != nil && uintptr(ta) != itself {
            if ta.scope == nil { // Ignore globals.
                ret false
            }
            ret ta.scope == self.tree || !self.s.is_flag(SemaFlag.Shadowing)
        }

        ret false
    }

    fn check_var_decl(mut &self, mut decl: &VarDecl) {
        let mut v = build_var(decl)
        v.scope = self.scope

        defer {
            self.table.vars = append(self.table.vars, v)
            self.scope.stmts = append(self.scope.stmts, v)
        }

        if self.is_duplicated_ident(uintptr(v), v.ident) {
            self.s.push_err(v.token, LogMsg.DuplicatedIdent, v.ident)
            self.s.push_suggestion(LogMsg.RenameForAvoidDuplication)
            self.stop()
            ret
        }

        self.s.check_var_decl(v, self)
        if !v.is_type_inferred() && (v.kind == nil || v.kind.kind == nil) {
            ret
        }

        self.s.check_type_var(v, self)
    }

    fn check_type_alias_decl(mut &self, mut decl: &TypeAliasDecl) {
        let mut ta = build_type_alias(decl)
        if self.is_duplicated_ident(uintptr(ta), ta.ident) {
            self.s.push_err(ta.token, LogMsg.DuplicatedIdent, ta.ident)
            self.s.push_suggestion(LogMsg.RenameForAvoidDuplication)
            self.stop()
            ret
        }
        self.s.check_type_alias_decl(ta, self)

        self.table.type_aliases = append(self.table.type_aliases, ta)

        // Stop immediately if destination type is could not evaluated.
        if ta.kind.kind == nil {
            self.stop()
        }
    }

    fn get_child(mut self): &Scope {
        ret &Scope{
            parent: self.scope,
        }
    }

    fn check_child_ssc(mut &self, mut &tree: &ScopeTree, mut &s: &Scope, mut &ssc: &ScopeChecker) {
        ssc.parent = self
        ssc.check(tree, s)
    }

    fn check_child_sc(mut &self, mut &tree: &ScopeTree, mut &ssc: &ScopeChecker): &Scope {
        let mut s = self.get_child()
        self.check_child_ssc(tree, s, ssc)
        ret s
    }

    fn check_child(mut &self, mut &tree: &ScopeTree): &Scope {
        let mut ssc = self.new_child_checker()
        ret self.check_child_sc(tree, ssc)
    }

    fn check_anon_scope(mut &self, mut tree: &ScopeTree) {
        let mut s = self.check_child(tree)
        self.scope.stmts = append(self.scope.stmts, s)
    }

    fn process_error_call(mut &self, mut &m: &BuiltinErrorCallExprModel, err: Token) {
        if self.is_deferred() {
            self.s.push_err(err, LogMsg.ErrorInDeferred)
        }

        let mut root = self.get_root()
        if !root.owner.decl.exceptional {
            self.s.push_err(err, LogMsg.ErrorWithNonExceptional)
            self.s.push_suggestion(LogMsg.DeclareExceptional)
        }
        m.func = root.owner
    }

    fn check_expr(mut &self, mut expr: &Expr) {
        let mut eval = self.s.eval(self)
        eval.ignored = true
        let mut d = eval.eval_expr(expr)
        if d == nil {
            ret
        }

        match type d.model {
        | &BuiltinErrorCallExprModel:
            let mut m = (&BuiltinErrorCallExprModel)(d.model)
            self.process_error_call(m, expr.token)
            self.scope.stmts = append(self.scope.stmts, d)

        | &BackendEmitExprModel
        | &BuiltinAppendCallExprModel
        | &BuiltinCloneCallExprModel
        | &BuiltinOutCallExprModel
        | &BuiltinOutlnCallExprModel
        | &BuiltinPanicCallExprModel
        | &BuiltinAssertCallExprModel
        | &FreeExprModel
        | &FnCallExprModel:
            self.scope.stmts = append(self.scope.stmts, d)

        |:
            self.s.push_err(expr.token, LogMsg.InvalidSyntax)
        }
    }

    fn check_co_expr(mut &self, mut expr: &CoExpr) {
        let mut eval = self.s.eval(self)
        eval.ignored = true
        let mut d = eval.eval_expr(expr.expr)
        if d == nil {
            ret
        }

        match type d.model {
        | &FnCallExprModel:
            let mut model = (&FnCallExprModel)(d.model)
            if model.func.decl.exceptional {
                self.s.push_err(expr.token, LogMsg.CoForExceptional)
                self.s.push_suggestion(LogMsg.HandleInFn)
            }
            model.is_co = true
            eval.check_fn_of_concurrent_call(model.func, expr.expr.token)
            self.scope.stmts = append(self.scope.stmts, d)

        |:
            self.s.push_err(expr.token, LogMsg.ExprNotFnCall)
            ret
        }

    }

    fn check_if(mut &self, mut i: &std::jule::ast::If): &If {
        let mut s = self.check_child(i.scope)

        let mut d = self.s.eval(self).eval_expr(i.expr)
        if d == nil {
            ret nil
        }

        let mut prim = d.kind.prim()
        if prim == nil || !prim.is_bool() {
            self.s.push_err(i.expr.token, LogMsg.IfRequireBoolExpr)
            ret nil
        }

        ret &If{
            expr:  d.model,
            scope: s,
        }
    }

    fn check_else(mut &self, mut e: &std::jule::ast::Else): &Else {
        ret &Else{
            scope: self.check_child(e.scope),
        }
    }

    fn check_conditional(mut &self, mut conditional: &std::jule::ast::Conditional) {
        let mut c = &Conditional{}
        self.scope.stmts = append(self.scope.stmts, c)

        c.elifs = make([]&If, 0, conditional.tail.len+1)

        c.elifs = append(c.elifs, self.check_if(conditional.head))
        for (_, mut elif) in conditional.tail {
            c.elifs = append(c.elifs, self.check_if(elif))
        }

        if conditional.default != nil {
            c.default = self.check_else(conditional.default)
        }
    }

    fn check_iter_scope_sc(mut &self, it :uintptr, mut tree: &ScopeTree, mut ssc: &ScopeChecker): &Scope {
        ssc.it = it
        ret self.check_child_sc(tree, ssc)
    }

    fn check_iter_scope(mut &self, it: uintptr, mut &tree: &ScopeTree): &Scope {
        let mut ssc = self.new_child_checker()
        ret self.check_iter_scope_sc(it, tree, ssc)
    }

    fn check_inf_iter(mut &self, mut &it: &Iter) {
        let mut kind = &InfIter{}

        self.scope.stmts = append(self.scope.stmts, kind)

        kind.scope = self.check_iter_scope(uintptr(kind), it.scope)
    }

    fn check_while_iter(mut &self, mut &it: &Iter) {
        let mut wh = (&WhileKind)(it.kind)
        if wh.expr == nil && wh.next == nil {
            self.check_inf_iter(it)
            ret
        }

        let mut kind = &WhileIter{}

        self.scope.stmts = append(self.scope.stmts, kind)

        kind.scope = self.check_iter_scope(uintptr(kind), it.scope)

        if wh.expr != nil {
            let mut d = self.s.eval(self).eval_expr(wh.expr)
            if d == nil {
                ret
            }

            let prim = d.kind.prim()
            if prim == nil {
                self.s.push_err(it.token, LogMsg.IterWhileRequireBoolExpr)
                ret
            }

            if !prim.is_bool() {
                self.s.push_err(it.token, LogMsg.IterWhileRequireBoolExpr)
                ret
            }

            kind.expr = d.model
        }

        if wh.is_while_next() {
            if !is_valid_ast_st_for_next_st(wh.next) {
                self.s.push_err(wh.next_token, LogMsg.InvalidStmtForNext)
                ret
            }

            let n = self.scope.stmts.len
            self.check_node(wh.next)
            if n < self.scope.stmts.len {
                let mut st = self.scope.stmts[n]
                self.scope.stmts = self.scope.stmts[:n] // Remove trailing statements.
                if !is_valid_st_for_next_st(st) {
                    self.s.push_err(wh.next_token, LogMsg.InvalidStmtForNext)
                }

                kind.next = st
            }
        }
    }

    fn check_range_iter(mut &self, mut &it: &Iter) {
        let mut rang = (&RangeKind)(it.kind)

        let mut d = self.s.eval(self).eval_expr(rang.expr)
        if d == nil {
            ret
        }

        let mut kind = &RangeIter{
            expr: d,
        }

        let mut rc = RangeChecker{
            sc:   self,
            kind: kind,
            rang: rang,
            d:    d,
        }
        let ok = rc.check()
        if !ok {
            ret
        }

        self.scope.stmts = append(self.scope.stmts, kind)

        let mut ssc = self.new_child_checker()

        if kind.key_a != nil {
            if !self.s.is_flag(SemaFlag.Shadowing) && self.is_duplicated_ident(0, kind.key_a.ident) {
                self.s.push_err(kind.key_a.token, LogMsg.DuplicatedIdent, kind.key_a.ident)
                self.s.push_suggestion(LogMsg.RenameForAvoidDuplication)
            }
            ssc.table.vars = append(ssc.table.vars, kind.key_a)
        }

        if kind.key_b != nil {
            if !self.s.is_flag(SemaFlag.Shadowing) && self.is_duplicated_ident(0, kind.key_b.ident) {
                self.s.push_err(kind.key_b.token, LogMsg.DuplicatedIdent, kind.key_b.ident)
                self.s.push_suggestion(LogMsg.RenameForAvoidDuplication)
            }
            ssc.table.vars = append(ssc.table.vars, kind.key_b)
        }

        kind.scope = self.check_iter_scope_sc(uintptr(kind), it.scope, ssc)
    }

    fn check_iter(mut &self, mut it: &Iter) {
        if it.is_inf() {
            self.check_inf_iter(it)
            ret
        }

        match type it.kind {
        | &WhileKind: self.check_while_iter(it)
        | &RangeKind: self.check_range_iter(it)
        |:            outln("error <unimplemented iteration kind>")
        }
    }

    fn check_valid_cont_label(mut &self, it: uintptr): bool {
        let mut scope = self

    iter:
        if scope.it == it {
            ret true
        }

        if scope.parent != nil {
            scope = scope.parent
            goto iter
        }

        ret false
    }

    fn check_valid_break_label(mut &self, ptr: uintptr): bool {
        let mut scope = self

    iter:
        if scope.it == ptr {
            ret true
        }

        if scope.cse != 0 {
            let mtch = unsafe { uintptr((*Case)(scope.cse).owner) }
            if mtch == ptr {
                ret true
            }
        }

        if scope.parent != nil {
            scope = scope.parent
            goto iter
        }

        ret false
    }

    fn check_cont_valid_scope(mut &self, c: &std::jule::ast::ContSt): &ContSt {
        if self.is_deferred() {
            self.s.push_err(c.token, LogMsg.ContinueAtOutOfValidScope)
            ret nil
        }

        if c.label.id != TokenId.Na {
            ret &ContSt{}
        }

        let mut scope = self
    iter:
        match {
        | scope.it == 0 && scope.parent != nil && scope.owner == nil:
            scope = scope.parent
            goto iter

        | scope.it != 0:
            ret &ContSt{it: scope.it}
        }

        self.s.push_err(c.token, LogMsg.ContinueAtOutOfValidScope)
        ret nil
    }

    fn check_cont(mut &self, c: &std::jule::ast::ContSt) {
        let mut cont = self.check_cont_valid_scope(c)
        if cont == nil {
            ret
        }

        if c.label.id != TokenId.Na { // Label given.
            let mut label = find_label_parent(c.label.kind, self.parent)
            if label == nil {
                self.s.push_err(c.label, LogMsg.LabelNotExist, c.label.kind)
                ret
            }

            label.used = true

            if label.pos+1 >= label.scope.scope.stmts.len {
                self.s.push_err(c.label, LogMsg.InvalidLabel, c.label.kind)
                ret
            }

            let i = label.pos + 1
            if i >= label.scope.scope.stmts.len {
                self.s.push_err(c.label, LogMsg.InvalidLabel)
            } else {
                let mut st = label.scope.scope.stmts[i]
                match type st {
                | &InfIter:   cont.it = uintptr((&InfIter)(st))
                | &RangeIter: cont.it = uintptr((&RangeIter)(st))
                | &WhileIter: cont.it = uintptr((&WhileIter)(st))
                |:            self.s.push_err(c.label, LogMsg.InvalidLabel, c.label.kind)
                }
            }
        }

        if cont.it != 0 {
            if !self.check_valid_cont_label(cont.it) {
                self.s.push_err(c.label, LogMsg.InvalidLabel, c.label.kind)
            }
        }

        self.scope.stmts = append(self.scope.stmts, cont)
    }

    fn check_label(mut &self, mut l: &LabelSt) {
        if self.find_label(l.ident) != nil {
            self.s.push_err(l.token, LogMsg.LabelExist, l.ident)
            ret
        }

        let mut label = &Label{
            ident: l.ident,
        }

        self.scope.stmts = append(self.scope.stmts, label)
        *self.labels = append(*self.labels, &ScopeLabel{
            token: l.token,
            label: label,
            pos:   self.scope.stmts.len - 1,
            scope: self,
        })
    }

    fn push_goto(mut &self, mut gt: &std::jule::ast::GotoSt) {
        self.scope.stmts = append(self.scope.stmts, &GotoSt{
            ident: gt.label.kind,
        })

        *self.gotos = append(*self.gotos, &ScopeGoto{
            gt:    gt,
            pos:   self.scope.stmts.len - 1,
            scope: self,
        })
    }

    fn check_postfix(mut &self, mut a: &AssignSt) {
        if a.left.len > 1 {
            self.s.push_err(a.setter, LogMsg.InvalidSyntax)
            ret
        }

        let mut expr = a.left[0].expr
        let mut d = self.s.eval(self).eval_expr(expr)
        if d == nil {
            ret
        }

        _ = check_assign(self.s, d, nil, a.setter)

        if d.kind.ptr() != nil {
            let mut ptr = d.kind.ptr()
            if ptr.is_unsafe() {
                self.s.push_err(a.setter, LogMsg.OperatorNotForJuleType, a.setter.kind, d.kind.to_str())
                ret
            }
        } else {
            if d.kind.prim() == nil || !types::is_num(d.kind.prim().kind) {
                self.s.push_err(a.setter, LogMsg.OperatorNotForJuleType, a.setter.kind, d.kind.to_str())
                ret
            }
        }

        self.scope.stmts = append(self.scope.stmts, &Postfix{
            expr: d.model,
            op:   a.setter.kind,
        })
    }

    fn is_new_assign_ident(mut self, ident: str): bool {
        if is_ignore_ident(ident) || ident == "" {
            ret false
        }

        ret self.table.def_by_ident(ident, false) == nil
    }

    fn check_single_assign(mut &self, mut &a: &AssignSt) {
        let mut l: &Data = nil

        if !is_ignore_ident(a.left[0].ident) {
            let mut expr = a.left[0].expr
            l = self.s.eval(self).eval_expr(expr)
            if l == nil {
                ret
            }
        }

        let mut eval = if l != nil {
            self.s.evalp(self, l.kind)
        } else {
            self.s.eval(self)
        }
        let mut r = eval.eval_expr(a.right)
        if r == nil {
            ret
        }

        if l == nil {
            if r.kind.void() {
                self.s.push_err(a.right.token, LogMsg.InvalidExpr)
            }

            self.scope.stmts = append(self.scope.stmts, r)
            ret
        }

        if !check_assign(self.s, l, r, a.setter) {
            ret
        }

        if r.kind.tup() != nil {
            self.s.push_err(a.setter, LogMsg.MissingMultiAssignIdents)
            ret
        }

        self.scope.stmts = append(self.scope.stmts, &Assign{
            l:  &OperandExprModel{
                kind: l.kind,
                model: l.model,
            },
            r:  &OperandExprModel{
                kind: r.kind,
                model: r.model,
            },
            op: a.setter,
        })

        if a.setter.kind != TokenKind.Eq {
            a.setter.kind = a.setter.kind[:a.setter.kind.len-1]

            let mut solver = BinaryEval.new(&Eval{
                    s:        self.s,
                    lookup:   self,
                    unsafety: self.is_unsafe(),
                }, a.setter)

            r = solver.solve_explicit(l, r)
            if r == nil {
                ret
            }
            a.setter.kind += str(TokenKind.Eq)
            ret
        }

        let mut checker = AssignTypeChecker{
            s:           self.s,
            dest:        l.kind,
            d:           r,
            error_token: a.setter,
        }
        checker.check()
    }

    fn __process_end_part_of_multi_assign(mut self, mut st: &MultiAssign,
        mut a: &AssignSt, mut lexpr: &AssignLeft, mut l: &Data, mut r: &Data) {
        if is_ignore_ident(lexpr.ident) {
            if r.kind.void() {
                self.s.push_err(a.right.token, LogMsg.InvalidExpr)
            }

            st.l = append(st.l, nil)
            ret
        }

        if a.declarative && self.is_new_assign_ident(lexpr.ident) {
            // Add new variable declaration statement.
            let mut v = &Var{
                ident:     lexpr.ident,
                token:     lexpr.token,
                mutable:   lexpr.mutable,
                reference: lexpr.reference,
                scope:     self.scope,
                value: &Value{
                    expr: a.right,
                    data: r,
                },
            }

            self.s.check_var(v)

            st.l = append(st.l, v)
            self.table.vars = append(self.table.vars, v)
            self.scope.stmts = append(self.scope.stmts, v)

            ret
        }

        if lexpr.mutable || lexpr.reference {
            self.s.push_err(lexpr.token, LogMsg.DuplicatedIdent, lexpr.ident)
            self.s.push_suggestion(LogMsg.RenameForAvoidDuplication)
        }

        if !check_assign(self.s, l, r, a.setter) {
            ret
        }

        // Set reference false because this is normal assigment.
        // So, we don't need to check reference assignment should using lvalue.
        const REFERENCE = false
        self.s.check_validity_for_init_expr(l.mutable, REFERENCE, l.kind, r, a.setter)

        let mut checker = AssignTypeChecker{
            s:           self.s,
            dest:        l.kind,
            d:           r,
            error_token: a.setter,
        }
        checker.check()

        st.l = append(st.l, l.model)
    }

    fn check_ret_multi_assign(mut &self, mut &a: &AssignSt) {
        let mut rd = self.s.eval(self).eval_expr(a.right)
        if rd == nil {
            ret
        }

        let mut r = get_datas_from_tuple_data(rd)

        match {
        | a.left.len > r.len:
            self.s.push_err(a.setter, LogMsg.OverflowMultiAssignIdents)
            ret

        | a.left.len < r.len:
            self.s.push_err(a.setter, LogMsg.MissingMultiAssignIdents)
            ret
        }

        let mut st = &MultiAssign{
            r: rd.model,
        }

        if rd.kind.tup() == nil {
            st.r = &TupleExprModel{datas: r}
        }

        for i in a.left {
            let mut lexpr = a.left[i]
            let mut l: &Data = nil

            if !is_ignore_ident(lexpr.ident) &&
                (!a.declarative || !self.is_new_assign_ident(lexpr.ident)) {
                l = self.s.eval(self).eval_expr(lexpr.expr)
                if l == nil {
                    continue
                }
            }

            self.__process_end_part_of_multi_assign(st, a, lexpr, l, r[i])
        }

        self.scope.stmts = append(self.scope.stmts, st)
    }

    fn check_multi_assign(mut &self, mut &a: &AssignSt) {
        match type a.right.kind {
        | &FnCallExpr:
            self.check_ret_multi_assign(a)
            ret

        | &UnsafeExpr:
            match type (&UnsafeExpr)(a.right.kind).expr {
            | &FnCallExpr:
                self.check_ret_multi_assign(a)
                ret
            }
        }

        let mut right = get_expr_models(a.right.kind)

        match {
        | a.left.len > right.len:
            self.s.push_err(a.setter, LogMsg.OverflowMultiAssignIdents)
            ret

        | a.left.len < right.len:
            self.s.push_err(a.setter, LogMsg.MissingMultiAssignIdents)
            ret
        }

        let mut right_tuple = &TupleExprModel{}

        let mut st = &MultiAssign {
            r: right_tuple,
        }

        for i in a.left {
            let mut lexpr = a.left[i]
            let mut l: &Data = nil

            if !is_ignore_ident(lexpr.ident) &&
                (!a.declarative || !self.is_new_assign_ident(lexpr.ident)) {
                l = self.s.eval(self).eval_expr(lexpr.expr)
                if l == nil {
                    continue
                }
            }

            let mut expr = &Expr{kind: right[i], token: a.right.token}
            let mut eval = if l != nil {
                self.s.evalp(self, l.kind)
            } else {
                self.s.eval(self)
            }
            let mut r = eval.eval_expr(expr)
            if r == nil {
                continue
            }

            right_tuple.datas = append(right_tuple.datas, r)

            self.__process_end_part_of_multi_assign(st, a, lexpr, l, r)
        }

        self.scope.stmts = append(self.scope.stmts, st)
    }

    fn check_assign_st(mut &self, mut a: &AssignSt) {
        if is_postfix_op(a.setter.kind) {
            self.check_postfix(a)
            ret
        }

        if a.left.len == 1 && !a.declarative {
            self.check_single_assign(a)
            ret
        }

        self.check_multi_assign(a)
    }

    fn check_case_scope(mut &self, &c: &Case, mut &tree: &ScopeTree): &Scope {
        let mut ssc = self.new_child_checker()
        ssc.cse = uintptr(c)
        ret self.check_child_sc(tree, ssc)
    }

    fn check_case(mut &self, mut m: &Match, i: int, mut c: &std::jule::ast::Case, mut expr: &Data): &Case {
        let mut _case = m.cases[i]
        _case.exprs = make([]&Data, 0, c.exprs.len)
        let mut generic_matched = false

        for (_, mut e) in c.exprs {
            if m.type_match {
                let mut eval = &Eval{
                    s:      self.s,
                    lookup: self,
                }

                let mut d = eval.eval(e)
                if d != nil {
                    _case.exprs = append(_case.exprs, d)
                    if count_match_type(m, d.kind) > 1 {
                        self.s.push_err(e.token, LogMsg.DuplicateMatchType, d.kind.to_str())
                    }
                }

                if expr.kind.generic {
                    generic_matched = generic_matched || expr.kind.equals(d.kind)
                } else {
                    let trt = expr.kind.trt()
                    if trt != nil {
                        _ = self.s.check_type_compatibility(expr.kind, d.kind, e.token)
                    }
                }

                continue
            }

            let mut d = self.s.eval(self).eval_expr(e)
            if d == nil {
                continue
            }

            _case.exprs = append(_case.exprs, d)

            let mut checker = AssignTypeChecker{
                s:           self.s,
                dest:        expr.kind,
                d:           d,
                error_token: e.token,
            }
            checker.check()
        }

        if !m.type_match || !expr.kind.generic || generic_matched {
            _case.scope = self.check_case_scope(_case, c.scope)
        }
        ret _case
    }

    fn check_cases(mut &self, mut &m: &MatchCase, mut rm: &Match, mut expr: &Data) {
        rm.cases = make([]&Case, m.cases.len)
        for i in m.cases {
            let mut _case = &Case{
                owner: rm,
            }

            if i > 0 {
                rm.cases[i-1].next = _case
            }

            rm.cases[i] = _case
        }

        if rm.default != nil && m.cases.len > 0 {
            rm.cases[rm.cases.len-1].next = rm.default
        }

        for (i, mut c) in m.cases {
            self.check_case(rm, i, c, expr)
        }
    }

    fn check_default(mut &self, mut m: &Match, mut d: &std::jule::ast::Else): &Case {
        let mut def = &Case{
            owner: m,
        }
        def.scope = self.check_case_scope(def, d.scope)
        ret def
    }

    fn check_comptime_panic(mut self, &s: &Scope, error_token: Token) {
        if s.stmts.len != 1 {
            ret
        }

        let stmt = s.stmts[0]
        match type stmt {
        | &Data:
            let d = (&Data)(stmt)
            match type d.model {
            | &BuiltinPanicCallExprModel:
                let m = (&BuiltinPanicCallExprModel)(d.model)
                match type m.expr {
                | &Const:
                    let c = (&Const)(m.expr)
                    if c.is_str() {
                        self.s.push_err(error_token, LogMsg.ComptimePanic, c.read_str())
                    }
                }
            }
        }
    }

    fn push_type_match(mut &self, mut tm: &Match, &m: &MatchCase) {
        // Type kind is generic.
        // Match cases by kind.
        if tm.expr.kind.generic {
            for (i, mut c) in tm.cases {
                if c.scope != nil {
                    tm.cases = nil
                    tm.default = c
                    self.check_comptime_panic(c.scope, m.cases[i].token)
                    goto push
                }
            }
            if tm.default != nil {
                self.check_comptime_panic(tm.default.scope, m.default.token)
            }
            tm.cases = nil
        }

    push:
        self.scope.stmts = append(self.scope.stmts, tm)
    }

    fn check_type_match(mut &self, mut &m: &MatchCase) {
        let mut d = self.s.eval(self).eval(m.expr)
        if d == nil {
            ret
        }

        if !d.kind.generic &&
            !((d.kind.prim() != nil && d.kind.prim().is_any()) || d.kind.trt() != nil) {
            self.s.push_err(m.expr.token, LogMsg.TypeCaseHasNotValidExpr)
            ret
        }

        let mut tm = &Match{
            type_match: true,
            expr:       d,
        }

        if m.default != nil {
            tm.default = self.check_default(tm, m.default)
        }
        self.check_cases(m, tm, d)

        self.push_type_match(tm, m)
    }

    fn check_common_match(mut &self, mut &m: &MatchCase) {
        let mut d: &Data = nil
        if m.expr == nil {
            d = &Data{
                constant: Const.new_bool(true),
                kind:     &TypeKind{kind: build_prim_type(PrimKind.Bool)},
            }
            d.model = d.constant
        } else {
            d = self.s.eval(self).eval_expr(m.expr)
            if d == nil {
                ret
            }
        }

        let mut mc = &Match{
            expr: d,
        }

        self.scope.stmts = append(self.scope.stmts, mc)

        if m.default != nil {
            mc.default = self.check_default(mc, m.default)
        }
        self.check_cases(m, mc, d)
    }

    fn check_match(mut &self, mut m: &MatchCase) {
        if m.type_match {
            self.check_type_match(m)
            ret
        }
        self.check_common_match(m)
    }

    fn check_fall(mut &self, f: &std::jule::ast::FallSt) {
        if self.cse == 0 ||
            self.scope.stmts.len+1 < self.scope.stmts.len ||
            self.is_deferred() {
            self.s.push_err(f.token, LogMsg.FalltroughWrongUse)
            ret
        }

        let mut _case = unsafe { (*Case)(self.cse) }
        if unsafe { _case.next } == nil {
            self.s.push_err(f.token, LogMsg.FallthroughIntoFinalCase)
            self.s.push_suggestion(LogMsg.RemoveFallthroughFromFinalCase)
            ret
        }

        self.scope.stmts = append(self.scope.stmts, &FallSt{
            dest_case: unsafe { uintptr(_case.next) },
        })
    }

    fn check_break_with_label(mut &self, b: &std::jule::ast::BreakSt): &BreakSt {
        let mut brk = self.check_plain_break(b)
        if brk == nil {
            ret nil
        }

        // Set pointer to zero.
        // Pointer will set by label.
        brk.it = 0
        brk.mtch = 0

        let mut label = find_label_parent(b.label.kind, self.parent)
        if label == nil {
            self.s.push_err(b.label, LogMsg.LabelNotExist, b.label.kind)
            ret nil
        }

        label.used = true

        if label.pos+1 >= label.scope.scope.stmts.len {
            self.s.push_err(b.label, LogMsg.InvalidLabel, b.label.kind)
            ret nil
        }

        let i = label.pos + 1
        if i >= label.scope.scope.stmts.len {
            self.s.push_err(b.label, LogMsg.InvalidLabel, b.label.kind)
        } else {
            let mut st = label.scope.scope.stmts[i]
            match type st {
            | &InfIter:   brk.it = uintptr((&InfIter)(st))
            | &RangeIter: brk.it = uintptr((&RangeIter)(st))
            | &WhileIter: brk.it = uintptr((&WhileIter)(st))
            | &Match:     brk.mtch = uintptr((&Match)(st))
            |:            self.s.push_err(b.label, LogMsg.InvalidLabel, b.label.kind)
            }
        }

        if brk.it != 0 {
            if !self.check_valid_break_label(brk.it) {
                self.s.push_err(b.label, LogMsg.InvalidLabel, b.label.kind)
            }
        }

        if brk.mtch != 0 {
            if !self.check_valid_break_label(brk.mtch) {
                self.s.push_err(b.label, LogMsg.InvalidLabel, b.label.kind)
            }
        }

        ret brk
    }

    fn check_plain_break(mut &self, b: &std::jule::ast::BreakSt): &BreakSt {
        if self.is_deferred() {
            self.s.push_err(b.token, LogMsg.BreakAtOutOfValidScope)
            ret nil
        }

        let mut scope = self
    iter:
        match {
        | scope.it == 0 && scope.cse == 0 && scope.parent != nil && scope.owner == nil:
            scope = scope.parent
            goto iter

        | scope.it != 0:
            ret &BreakSt{it: scope.it}

        | scope.cse != 0:
            ret &BreakSt{mtch: unsafe { uintptr((*Case)(scope.cse).owner) }}
        }

        self.s.push_err(b.token, LogMsg.BreakAtOutOfValidScope)
        ret nil
    }

    fn check_break(mut &self, b: &std::jule::ast::BreakSt) {
        if b.label.id != TokenId.Na { // Label given.
            let mut brk = self.check_break_with_label(b)
            self.scope.stmts = append(self.scope.stmts, brk)
            ret
        }

        let mut brk = self.check_plain_break(b)
        self.scope.stmts = append(self.scope.stmts, brk)
    }

    fn check_ret(mut &self, mut r: &std::jule::ast::RetSt) {
        if self.is_deferred() {
            self.s.push_err(r.token, LogMsg.RetInDeferred)
        }

        let mut rt = &RetSt{
            func: self.get_root().owner,
        }
        self.scope.stmts = append(self.scope.stmts, rt)

        let mut rtc = &RetTypeChecker{
            sc:          self,
            f:           rt.func,
            error_token: r.token,
        }
        let ok = rtc.check(r.expr)
        if !ok {
            ret
        }

        if r.expr == nil && rtc.vars.len == 0 {
            ret
        }

        rt.vars = rtc.vars

        if r.expr != nil {
            rt.expr = rtc.model
        }
    }

    fn check_use_expr(mut &self, ue: &UseExpr) {
        if self.result == nil {
            self.s.push_err(ue.token, LogMsg.UseExprOutOfScope)
            ret
        }

        if self.is_deferred() {
            self.s.push_err(ue.token, LogMsg.UseExprInDeferred)
        }

        if self.i+1 < self.tree.stmts.len {
            self.s.push_err(ue.token, LogMsg.UseExprNotLast)
        }

        // Validated at end of scope's analysis.
    }

    fn check_node(mut &self, mut &node: NodeData) {
        match type node {
        | &Comment:                     break // Ignore.
        | &ScopeTree:                   self.check_anon_scope((&ScopeTree)(node))
        | &VarDecl:                     self.check_var_decl((&VarDecl)(node))
        | &TypeAliasDecl:               self.check_type_alias_decl((&TypeAliasDecl)(node))
        | &Expr:                        self.check_expr((&Expr)(node))
        | &CoExpr:                      self.check_co_expr((&CoExpr)(node))
        | &std::jule::ast::Conditional: self.check_conditional((&std::jule::ast::Conditional)(node))
        | &Iter:                        self.check_iter((&Iter)(node))
        | &std::jule::ast::ContSt:      self.check_cont((&std::jule::ast::ContSt)(node))
        | &LabelSt:                     self.check_label((&LabelSt)(node))
        | &std::jule::ast::GotoSt:      self.push_goto((&std::jule::ast::GotoSt)(node))
        | &AssignSt:                    self.check_assign_st((&AssignSt)(node))
        | &MatchCase:                   self.check_match((&MatchCase)(node))
        | &std::jule::ast::FallSt:      self.check_fall((&std::jule::ast::FallSt)(node))
        | &std::jule::ast::BreakSt:     self.check_break((&std::jule::ast::BreakSt)(node))
        | &std::jule::ast::RetSt:       self.check_ret((&std::jule::ast::RetSt)(node))
        | &UseExpr:                     self.check_use_expr((&UseExpr)(node))
        |:                              outln("error <unimplemented scope node>")
        }
    }

    fn check_result(mut &self) {
        let mut stmt = self.tree.stmts[self.tree.stmts.len-1]
        match type stmt {
        | &UseExpr:
            let mut ue = (&UseExpr)(stmt)
            let mut d = self.s.eval(self).eval_expr(ue.expr)
            if d == nil {
                ret
            }

            self.scope.stmts = append(self.scope.stmts, d)

            let mut rtc = &RetTypeChecker{
                sc:          self,
                error_token: ue.expr.token,
                types:       get_result_types(self.result),
            }
            _ = rtc.check(ue.expr)

        | &Expr:
            let mut expr = (&Expr)(stmt)
            let mut d = self.s.eval(self).eval_expr(expr)
            if d == nil {
                ret
            }

            self.scope.stmts = append(self.scope.stmts, d)

            match type d.model {
            | &BuiltinErrorCallExprModel:
                let mut m = (&BuiltinErrorCallExprModel)(d.model)
                self.process_error_call(m, expr.token)

            |:
                ret
            }

        | &std::jule::ast::GotoSt
        | &std::jule::ast::BreakSt
        | &std::jule::ast::ContSt
        | &std::jule::ast::RetSt:
            self.check_node(stmt)

        |:
            self.check_node(stmt)
            ret
        }

        // Set result to nil, it is a mark for whether result is processed.
        self.result = nil
    }

    fn check_tree(mut &self) {
        self.i = 0
        for self.i < self.tree.stmts.len; self.i++ {
            let mut stmt = self.tree.stmts[self.i]
            self.check_node(stmt)
            if self.stopped() {
                ret
            }
        }
        if self.result != nil && self.tree.stmts.len != 0 {
            self.check_result()
        }
    }

    fn check_goto(mut self, mut &gt: &ScopeGoto, mut &label: &ScopeLabel) {
        let mut gtsc = gt.scope
        for gtsc.child_index-1 > label.scope.child_index {
            gtsc = gtsc.parent
        }

        let mut n = 0

        if gtsc.scope == label.scope.scope {
            // Scopes are same and label at above, so safe.
            if gt.pos > label.pos {
                ret
            }

            // Limit controlling to goto's position.
            // Label and goto is in same scope.
            n = gt.pos
        }

        let mut i = label.pos - 1

        if n == 0 {
            for j, stmt in label.scope.scope.stmts {
                // Break if position reached to goto's scope.
                if stmt_is_goto_scope(stmt, gtsc.scope) {
                    n = j
                    break
                }
            }
        }

        for i >= n; i-- {
            let mut stmt = label.scope.scope.stmts[i]
            if st_is_def(stmt) {
                self.s.push_err(gt.gt.token, LogMsg.GotoJumpsDeclarations, gt.gt.label.kind)
                ret
            }
        }
    }

    fn check_gotos(mut self) {
        for (_, mut gt) in *self.gotos {
            let mut label = self.find_label_all(gt.gt.label.kind)
            if label == nil {
                self.s.push_err(gt.gt.token, LogMsg.LabelNotExist, gt.gt.label.kind)
                continue
            }

            label.used = true
            self.check_goto(gt, label)
        }
    }

    fn check_labels(mut self) {
        for _, l in *self.labels {
            if !l.used {
                self.s.push_err(l.token, LogMsg.DeclaredButNotUsed, l.label.ident)
            }
        }
    }

    fn check_vars(mut self) {
        for _, v in self.table.vars {
            if !v.used && !is_ignore_ident(v.ident) && !is_anon_ident(v.ident) && v.ident != TokenKind.Self {
                self.s.push_err(v.token, LogMsg.DeclaredButNotUsed, v.ident)
            }
        }
    }

    fn check_aliases(mut self) {
        for _, a in self.table.type_aliases {
            if !a.used && !is_ignore_ident(a.ident) && !is_anon_ident(a.ident) {
                self.s.push_err(a.token, LogMsg.DeclaredButNotUsed, a.ident)
            }
        }
    }

    // Checks scope tree.
    fn check(mut &self, mut &tree: &ScopeTree, mut &s: &Scope) {
        s.deferred = tree.deferred
        s.unsafety = tree.unsafety

        let errors = self.s.errors.len

        self.tree = tree
        self.scope = s

        self.check_tree()

        // If we have new errors, don't check unused declarations.
        if errors == self.s.errors.len {
            self.check_vars()
            self.check_aliases()

            if self.is_root() {
                self.check_gotos()
                self.check_labels()
            }
        }
    }

    fn new_child_checker(mut &self): &ScopeChecker {
        let mut base = new_scope_checker_base(self.s, nil)
        base.parent = self
        base.labels = self.labels
        base.gotos = self.gotos
        base.child_index = self.child_index + 1
        ret base
    }
}
