// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::jule::ast::{GenericDecl, IdentTypeDecl}
use std::jule::build::{LogMsg}
use std::jule::lex::{Token}
use types for std::jule::types

enum builtinConstraint: str {
    Signed: "signed",
    Unsigned: "unsigned",
    Float: "float",
    Numeric: "numeric",
    Immutable: "immutable",
    Mutable: "mutable",
    Ordered: "ordered",
    Comparable: "comparable",
}

static builtinConstraints = [
    builtinConstraint.Signed,
    builtinConstraint.Unsigned,
    builtinConstraint.Float,
    builtinConstraint.Numeric,
    builtinConstraint.Mutable,
    builtinConstraint.Immutable,
    builtinConstraint.Ordered,
    builtinConstraint.Comparable,
]

struct constraintChecker {
    mut s: &Sema

    // Declarations of generics.
    mut genericsD: []&GenericDecl

    // Generics of instance.
    mut generics: []&InsGeneric

    // Type aliases for generics.
    // It can be nil if environment is not guaranteed.
    // It will be used for guaranteed environments.
    mut genericsA: []&TypeAlias

    // Functions instance.
    // If this field is not nil, process will be executed by functions.
    mut fi: &FnIns

    // Structure instance.
    // If this field is not nil, process will be executed by structures.
    mut si: &StructIns

    // Error that will use as error token.
    mut et: &Token

    // Whether instance is unique.
    mut uniq: bool
}

impl constraintChecker {
    fn readyFn(mut &self): fn(mut &sema: &Sema, mut &generics: []&TypeAlias): bool {
        ret fn(mut &sema: &Sema, mut &generics: []&TypeAlias): bool {
            for (i, mut g) in self.genericsD {
                let mut generic = self.generics[i]
                if g.Constraint == nil || g.Constraint.Mask.len == 0 {
                    continue
                }
                generic.Constraint = make([]&TypeKind, 0, g.Constraint.Mask.len)
                for (_, mut mask) in g.Constraint.Mask {
                    let n = sema.errors.len
                    let mut kind = sema.buildTypeWithRefers(mask, sema, generics, nil)
                    if kind == nil {
                        match type mask.Kind {
                        | &IdentTypeDecl:
                            let mut itd = (&IdentTypeDecl)(mask.Kind)
                            if itd.Generics.len == 0 && isBuiltinConstraint(itd.Ident) {
                                kind = &TypeKind{Kind: buildPrimType(itd.Ident)}
                                sema.errors = sema.errors[:n]
                                goto success
                            }
                        }
                        ret false
                    }
                success:
                    generic.Constraint = append(generic.Constraint, kind)
                }
            }
            ret true
        }
    }

    // Functions will be checked in their environment, because environment is not guaranteed.
    fn readyFi(mut &self): bool {
        self.genericsD = self.fi.Decl.Generics
        self.generics = self.fi.Generics
        ret !self.uniq || self.s.fnEnvironment(self.fi, self.readyFn())
    }

    // Structure will be checked in current environment, because environment should be guaranteed.
    fn readySi(mut &self): bool {
        self.genericsD = self.si.Decl.Generics
        self.generics = self.si.Generics
        ret !self.uniq || self.readyFn()(self.s, self.genericsA)
    }

    fn ready(mut &self): bool {
        if self.fi != nil {
            ret self.readyFi()
        }
        ret self.readySi()
    }

    fn check(mut &self): bool {
        if !self.ready() {
            ret false
        }
    lookup:
        for (i, mut g) in self.generics {
            if g.Constraint == nil {
                continue
            }
            for (_, mut c2) in g.Constraint {
                let mut prim = c2.Prim()
                if prim != nil && prim.IsConstraint() {
                    if matchConstraint(prim.Kind, g.Kind) {
                        continue lookup
                    }
                    continue
                }
                if c2.Equals(g.Kind) {
                    continue lookup
                }
            }
            self.s.pushErr(self.et, LogMsg.ConstraintFailed, g.Kind.Str(), self.genericsD[i].Ident)
            ret false
        }
        ret true
    }
}

fn matchConstraint(&c: str, mut &g: &TypeKind): bool {
    match c {
    | builtinConstraint.Signed:
        let prim = g.Prim()
        if prim == nil {
            ret false
        }
        ret types::IsSigNum(prim.Kind)
    | builtinConstraint.Unsigned:
        let prim = g.Prim()
        if prim == nil {
            ret false
        }
        ret types::IsUnsigInt(prim.Kind)
    | builtinConstraint.Float:
        let prim = g.Prim()
        if prim == nil {
            ret false
        }
        ret types::IsFloat(prim.Kind)
    | builtinConstraint.Numeric:
        let prim = g.Prim()
        if prim == nil {
            ret false
        }
        ret types::IsNum(prim.Kind)
    | builtinConstraint.Mutable:
        ret g.Mutable()
    | builtinConstraint.Immutable:
        ret !g.Mutable()
    | builtinConstraint.Comparable:
        ret true
    | builtinConstraint.Ordered:
        let prim = g.Prim()
        if prim != nil {
            ret types::IsNum(prim.Kind) || prim.IsStr()
        }
        if g.Ptr() != nil {
            ret true
        }
        let s = g.Struct()
        if s != nil {
            ret s.Operators.Gt != nil &&
                s.Operators.GtEq != nil &&
                s.Operators.Lt != nil &&
                s.Operators.LtEq != nil
        }
        let enm = g.Enum()
        if enm != nil {
            ret types::IsNum(enm.Kind.Kind.Str())
        }
        ret false
    |:
        ret false
    }
}

fn isBuiltinConstraint(&ident: str): bool {
    for _, bc in builtinConstraints {
        if ident == bc {
            ret true
        }
    }
    ret false
}