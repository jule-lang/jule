// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use integ for std::jule::integrated

use std::conv::{ConvError, parse_float, parse_int, parse_uint}
use path for std::fs::path
use std::jule::ast::{
    self,
    Expr,
    LitExpr,
    IdentExpr,
    VariadicExpr,
    UnaryExpr,
    UnsafeExpr,
    SliceExpr,
    ExprData,
    FnDecl,
    BinopExpr,
    BraceLit,
    TupleExpr,
    SubIdentExpr,
    IndexingExpr,
    NsSelectionExpr,
    TypeDecl,
    FnCallExpr,
    SlicingExpr,
    CastExpr,
    StructLit,
    KeyValPair,
    IdentTypeDecl,
    TernaryExpr,
    NamespaceTypeDecl,
}
use std::jule::build::{LogMsg, Directive, PATH_STDLIB, logf}
use std::jule::constant::{Const}
use lit for std::jule::constant::lit
use lex for std::jule::lex::{
    self,
    Token,
    TokenId,
    TokenKind,
    is_str,
    is_bool,
    is_rune,
    is_raw_str,
}
use types for std::jule::types
use strings for std::strings

// Returns directive if exist.
fn find_directive(mut &directives: []&std::jule::ast::Directive, d: Directive): &std::jule::ast::Directive {
    for (_, mut dr) in directives {
        if dr.tag.kind == d {
            ret dr
        }
    }
    ret nil
}

fn find_builtins_import(ident: str, imp: &ImportInfo): any {
    ret find_package_builtin_def(imp.link_path, ident)
}

fn make_struct_lit_alloc(mut &d: &Data, mut &lit: &StructLitExprModel) {
    d.kind = &TypeKind{
        kind: &Sptr{
            elem: &TypeKind{kind: lit.strct},
        },
    }
    d.model = &AllocStructLitExprModel{
        lit: lit,
    }
}

fn build_error_var(mut &s: &Scope, mut &fc: &FnCallExpr): &Var {
    ret &Var{
        used:      true,
        reference: false,
        mutable:   true,
        ident:     "error",
        token:     fc.token,
        kind:      &TypeSymbol{
            kind: &TypeKind{
                kind: build_prim_type(PrimKind.Any),
            },
        },
        scope: s,
        value: &Value{
            data: &Data{},
        },
    }
}

fn find_builtins_sema(ident: str, mut s: &Sema): any {
    for (_, mut imp) in s.file.imports {
        if imp.import_all || imp.exist_ident(ident) {
            let mut def = find_builtins_import(ident, imp)
            if def != nil {
                ret def
            }
        }
    }

    // If package is std, check for internal builtin defines.
    let mut ppath = s.file.file.dir()
    if strings::has_prefix(ppath, PATH_STDLIB) {
        // Remove STDLIB directory path.
        ppath = ppath[PATH_STDLIB.len:]
        // Add "std" to beginning without separator
        // because path has separator at beginning.
        ppath = "std" + strings::replace(ppath, str(path::SEPARATOR), "::", -1)

        ret find_package_builtin_def(ppath, ident)
    }

    ret nil
}

fn is_ok_for_shifting(mut &d: &Data): bool {
    if d.is_const() {
        match {
        | d.constant.is_i64():
            ret d.constant.read_i64() >= 0
        | d.constant.is_u64():
            ret true
        | d.constant.is_f64():
            ret d.constant.read_f64() >= 0
        |:
            ret false
        }
    }
    let prim = d.kind.prim()
    ret prim != nil && types::is_int(prim.to_str())
}

fn is_instanced_struct(s: &StructIns): bool {
    ret s.decl.generics.len == s.generics.len
}

fn is_ptr_arithmetic_compatible_int(mut &d: &Data): bool {
    if d.is_const() {
        ret int_assignable(types::TypeKind.Int, d)
    }
    let mut tcc = TypeCompatibilityChecker{
        dest:        &TypeKind{kind: build_prim_type(types::TypeKind.Int)},
        src:         d.kind,
    }
    ret tcc.check()
}

fn normalize_type(mut &d: &Data) {
    match {
    | int_assignable(PrimKind.Int, d):
        d.kind.kind = build_prim_type(PrimKind.Int)
        d.constant.set_i64(i64(d.constant.as_f64()))
    | int_assignable(PrimKind.Uint, d):
        d.kind.kind = build_prim_type(PrimKind.Uint)
        d.constant.set_u64(u64(d.constant.as_f64()))
    }
}

// Fit constant value to type.
fn fit_type(mut &d: &Data) {
    if !d.is_const() {
        ret
    }

    let p = d.kind.prim()
    if p == nil {
        ret
    }

    let k = p.kind
    match {
    | types::is_float(k):     d.constant.set_f64(d.constant.as_f64())
    | types::is_sig_int(k):   d.constant.set_i64(d.constant.as_i64())
    | types::is_unsig_int(k): d.constant.set_u64(d.constant.as_u64())
    }
}

fn apply_cast_kind_model(mut &d: &Data) {
    d.model = &CastingExprModel{
        expr:      d.model,
        kind:      d.cast_kind,
        expr_kind: d.kind,
    }
}

fn apply_cast_kind(mut &d: &Data) {
    if d.cast_kind == nil {
        ret
    }

    apply_cast_kind_model(d)
    d.kind = d.cast_kind
    d.cast_kind = nil // Ignore, because model added.
}

fn build_void_data(): &Data {
    ret &Data{
        mutable:  false,
        lvalue:   false,
        decl:     false,
        kind: &TypeKind{
            kind: build_prim_type("void"),
        },
    }
}

fn kind_by_bitsize(expr: any): str {
    match type expr {
    | f64:
        let x = f64(expr)
        ret types::float_from_bits(types::bitsize_of_float(x))

    | i64:
        let x = i64(expr)
        ret types::int_from_bits(types::bitsize_of_int(x))

    | u64:
        let x = u64(expr)
        ret types::uint_from_bits(types::bitsize_of_uint(x))

    |:
        ret ""
    }
}

fn check_data_for_integer_indexing(mut &d: &Data): (err_fmt: LogMsg) {
    if d == nil {
        ret LogMsg.Empty
    }

    match {
    | d.kind.prim() == nil:
        ret LogMsg.InvalidTypeForIndexing

    | !types::is_int(d.kind.prim().to_str()):
        ret LogMsg.InvalidTypeForIndexing

    | d.is_const():
        if d.constant.as_f64() < 0 {
            ret LogMsg.OverflowLimits
        }

    | d.kind.prim() == nil
    | d.is_const()
    | types::real_kind_of(d.kind.prim().to_str()) != types::real_kind_of(PrimKind.Int):
        d.cast_kind = &TypeKind{kind: build_prim_type(PrimKind.Int)}
        apply_cast_kind(d)
    }
    ret LogMsg.Empty
}

// Applies casting model to data by enum.
// This is necessary to keep exact same type of enum's field type.
// The parameter d should be constant data.
fn apply_cast_model_by_enum(mut &d: &Data, mut e: &Enum) {
    if e == nil {
        ret
    }
    let p = e.kind.kind.prim()
    if p.is_str() {
        ret
    }
    d.cast_kind = e.kind.kind
    apply_cast_kind_model(d)
    d.cast_kind = nil
}

// Value data.
pub struct Data {
    pub kind:      &TypeKind
    pub cast_kind: &TypeKind // This expression should be cast to this kind.
    pub mutable:   bool
    pub reference: bool
    pub lvalue:    bool
    pub is_rune:   bool
    pub model:     ExprModel

    // True if kind is declaration such as:
    //  - &Enum
    //  - &Struct
    //  - int type
    //  - bool type
    pub decl: bool

    // Constant expression data.
    pub constant: &Const
}

impl Data {
    // Reports whether Data is nil literal.
    pub fn is_nil(self): bool { ret self.kind.is_nil() }

    // Reports whether Data is void.
    pub fn is_void(self): bool { ret self.kind.void() }

    // Reports whether Data is constant expression.
    pub fn is_const(self): bool { ret self.constant != nil }

    // Reports left and right operand is good order.
    // If reports false, left and right operand should be swapped.
    // Accepts itself as left operand.
    pub fn good_operand(self, mut &other: &Data): bool {
        ret (other.kind.prim() == nil || !other.kind.prim().is_any()) &&
            other.kind.trt() == nil &&
            !self.kind.is_nil()
    }
}

// Value.
pub struct Value {
    pub expr: &Expr
    pub data: &Data
}

// Evaluator.
struct Eval {
    s:             &Sema // Used for error logging.
    lookup:        Lookup
    prefix:        &TypeKind
    unsafety:      bool
    immutable:     bool // This expression will assigned to immutable memory.
    ignored:       bool // Evaluated expression is not for assignment or something else.
    dis_builtin:   bool // Disallow/suppress Jule's built-in defines.
    owner:         &Var
    field:         &FieldIns // Field of this default expression. Used for checking cycles.
}

impl Eval {
    fn push_err(mut self, token: Token, fmt: LogMsg, args: ...any) {
        self.s.push_err(token, fmt, args...)
    }

    // Push suggestion to last log.
    fn push_suggestion(mut self, fmt: LogMsg, args: ...any) {
        self.s.push_suggestion(fmt, args...)
    }

    fn allow_builtin(mut self) { self.dis_builtin = false }
    fn disallow_builtin(mut self) { self.dis_builtin = true }

    // Reports whether evaluation in unsafe scope.
    fn is_unsafe(self): bool { ret self.unsafety }

    // Reports whether evaluated expression is in global scope.
    fn is_global(self): bool {
        match type self.lookup {
        | &Sema: ret true
        |:       ret false
        }
    }

    fn apply_numeric_prefix(mut self, mut &d: &Data) {
        if d == nil || d.cast_kind != nil || !d.is_const() || d.kind.prim() == nil {
            ret
        }
        if self.prefix == nil || self.prefix.prim() == nil {
            ret
        }

        let pk = self.prefix.prim().kind
        match {
        | types::is_float(pk):
            d.kind = new(TypeKind, *self.prefix)
            d.constant.set_f64(d.constant.as_f64())
        | types::is_sig_int(pk):
            if !int_assignable(pk, d) {
                break
            }
            d.kind = new(TypeKind, *self.prefix)
            d.constant.set_i64(d.constant.as_i64())
        | types::is_unsig_int(pk):
            if !int_assignable(pk, d) {
                break
            }
            d.kind = new(TypeKind, *self.prefix)
            d.constant.set_u64(d.constant.as_u64())
        }
    }

    fn lit_nil(self): &Data {
        // Return new Data with nil kind.
        // Nil kind represents "nil" literal.

        let mut constant = Const.new_nil()
        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: constant,
            decl:     false,
            kind:     &TypeKind{kind: nil},
            model:    constant,
        }
    }

    fn lit_str(self, &l: &LitExpr): &Data {
        let mut s = l.value[1 : l.value.len-1] // Remove quotes.
        if is_raw_str(l.value) {
            s = lit::to_raw_str([]byte(s))
        } else {
            s = lit::to_str([]byte(s))
        }
        let mut constant = Const.new_str(s)

        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: constant,
            decl:     false,
            kind: &TypeKind{
                kind: build_prim_type(PrimKind.Str),
            },
            model: constant,
        }
    }

    fn lit_bool(self, &l: &LitExpr): &Data {
        let mut constant = Const.new_bool(l.value == TokenKind.True)
        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: constant,
            decl:     false,
            kind: &TypeKind{
                kind: build_prim_type(PrimKind.Bool),
            },
            model: constant,
        }
    }

    fn lit_rune(self, &l: &LitExpr): &Data {
        const BYTE_KIND: str = PrimKind.U8
        const RUNE_KIND: str = PrimKind.I32

        let lt = l.value[1 : l.value.len-1] // Remove quotes.
        let r = lit::to_rune([]byte(lt))
        let mut data = &Data{
            lvalue:   false,
            mutable:  false,
            constant: Const.new_i64(i64(r)),
            decl:     false,
        }

        let is_ascii = lit::is_ascii(r)
        if is_ascii {
            data.kind = &TypeKind{
                kind: build_prim_type(BYTE_KIND),
            }
        } else {
            data.kind = &TypeKind{
                kind: build_prim_type(RUNE_KIND),
            }
        }

        data.model = &RuneExprModel{code: r}
        data.is_rune = true
        ret data
    }

    fn lit_float(self, &l: &LitExpr): &Data {
        const FLOAT_KIND: str = PrimKind.F64

        let (f, _) = parse_float(l.value, 64)
        let mut constant = Const.new_f64(f)

        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: constant,
            decl:     false,
            kind: &TypeKind{
                kind: build_prim_type(FLOAT_KIND),
            },
            model: constant,
        }
    }

    fn lit_int(mut self, &l: &LitExpr): &Data {
        const BIT_SIZE = 0b01000000

        let mut lit = l.value
        let mut base = 0

        match {
        | strings::has_prefix(lit, "0x"): // Hexadecimal
            lit = lit[2:]
            base = 0b00010000

        | strings::has_prefix(lit, "0b"): // Binary
            lit = lit[2:]
            base = 0b10

        | strings::has_prefix(lit, "0o"): // Ocatal
            lit = lit[2:]
            base = 0b1000

        | lit[0] == '0' && lit.len > 1: // Octal
            lit = lit[1:]
            base = 0b1000

        |: // Decimal
            base = 0b1010
        }

        let mut d = &Data{
            lvalue:  false,
            mutable: false,
            decl:    false,
        }

        let (sig, err) = parse_int(lit, base, BIT_SIZE)
        if err == ConvError.Ok {
            d.constant = Const.new_i64(sig)
            d.kind = &TypeKind{
                kind: build_prim_type(PrimKind.Int),
            }
        } else {
            let (unsig, err) = parse_uint(lit, base, BIT_SIZE)
            if err != ConvError.Ok {
                self.push_err(l.token, LogMsg.InvalidNumericRange)
                self.push_suggestion(LogMsg.TryFloatingPoint)
            }
            d.constant = Const.new_u64(unsig)
            d.kind = &TypeKind{
                kind: build_prim_type(PrimKind.Uint),
            }
        }

        d.model = d.constant

        // Apply prefix.
        self.apply_numeric_prefix(d)

        ret d
    }

    fn lit_num(mut self, &l: &LitExpr): &Data {
        match {
        | lex::is_float(l.value):
            ret self.lit_float(l)
        |:
            ret self.lit_int(l)
        }
    }

    fn eval_lit(mut self, lit: &LitExpr): &Data {
        match {
        | lit.is_nil():
            ret self.lit_nil()
        | is_str(lit.value):
            ret self.lit_str(lit)
        | is_bool(lit.value):
            ret self.lit_bool(lit)
        | is_rune(lit.value):
            ret self.lit_rune(lit)
        | lex::is_num(lit.value):
            ret self.lit_num(lit)
        |:
            ret nil
        }
    }

    fn find_builtins(mut self, ident: str): any {
        match type self.lookup {
        | &ImportInfo:
            let mut def = find_builtins_import(ident, (&ImportInfo)(self.lookup))
            if def != nil {
                ret def
            }

        | &Sema:
            let mut def = find_builtins_sema(ident, (&Sema)(self.lookup))
            if def != nil {
                ret def
            }

        | &ScopeChecker:
            let mut def = find_builtins_sema(ident, (&ScopeChecker)(self.lookup).s)
            if def != nil {
                ret def
            }
        }

        ret if self.dis_builtin { nil } else { find_builtin_def(ident) }
    }

    fn get_def(mut self, ident: str, cpp_linked: bool): any {
        if !cpp_linked {
            let mut enm = self.lookup.find_enum(ident)
            if enm != nil {
                ret enm
            }
        }

        let mut v = self.lookup.find_var(ident, cpp_linked)
        if v != nil {
            ret v
        }

        let mut f = self.lookup.find_fn(ident, cpp_linked)
        if f != nil {
            ret f
        }

        let mut s = self.lookup.find_struct(ident, cpp_linked)
        if s != nil {
            ret s
        }

        let mut ta = self.lookup.find_type_alias(ident, cpp_linked)
        if ta != nil {
            ret ta
        }

        ret self.find_builtins(ident)
    }

    fn push_reference(mut self, mut &references: &ReferenceStack) {
        match type self.lookup {
        | &ScopeChecker:
            let mut sc = (&ScopeChecker)(self.lookup).get_root()
            if !references.exist[FnIns](sc.owner) {
                references.push(sc.owner)
            }

        |:
            if self.owner != nil && !references.exist[Var](self.owner) {
                references.push(self.owner)
            }
        }
    }

    fn push_reference_to_fn(mut self, mut &f: &FnIns) {
        match type self.lookup {
        | &ScopeChecker:
            let mut sc = (&ScopeChecker)(self.lookup).get_root()
            if sc.owner.decl.is_init() && !sc.owner.references.exist[FnIns](f) {
                sc.owner.refers.push(f)
            }
        }
        self.push_reference(f.references)
    }

    fn push_reference_to_var(mut self, mut &v: &Var) {
        if v.references == nil {
            ret
        }

        match type self.lookup {
        | &ScopeChecker:
            let mut sc = (&ScopeChecker)(self.lookup).get_root()
            if sc.owner.decl.is_init() && !sc.owner.references.exist[Var](v) {
                sc.owner.refers.push(v)
            }
        }

        self.push_reference(v.references)
    }

    fn push_reference_to_struct(mut self, mut &s: &StructIns) {
        match type self.lookup {
        | &ScopeChecker:
            let mut sc = (&ScopeChecker)(self.lookup).get_root()
            if sc.owner.decl.is_init() && !sc.owner.references.exist[StructIns](s) {
                sc.owner.refers.push(s)
            }
        }
        self.push_reference(s.references)
    }

    fn __eval_enum(self, mut enm: &Enum): &Data {
        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: nil,
            decl:     true,
            kind: &TypeKind{
                kind: enm,
            },
        }
    }

    fn eval_enum(mut self, mut enm: &Enum, error_token: Token): &Data {
        if !self.s.is_accessible_define(enm.public, enm.token) {
            self.push_err(error_token, LogMsg.IdentIsNotAccessible, enm.ident)
            self.push_suggestion(LogMsg.MakePubToAccess)
            ret nil
        }

        ret self.__eval_enum(enm)
    }

    fn __eval_struct(self, mut s: &StructIns): &Data {
        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: nil,
            decl:     true,
            kind: &TypeKind{
                kind: s,
            },
            model: s,
        }
    }

    fn eval_struct(mut self, mut s: &StructIns, error_token: Token): &Data {
        if !self.s.is_accessible_define(s.decl.public, s.decl.token) {
            self.push_err(error_token, LogMsg.IdentIsNotAccessible, s.decl.ident)
            self.push_suggestion(LogMsg.MakePubToAccess)
            ret nil
        }

        self.check_deprecated(s.decl.directives, error_token)

        ret self.__eval_struct(s)
    }

    fn eval_fn_ins(self, mut f: &FnIns): &Data {
        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: nil,
            decl:     false,
            kind: &TypeKind{
                kind: f,
            },
            model: f,
        }
    }

    fn check_deprecated(mut self, mut &directives: []&std::jule::ast::Directive, tok: Token) {
        if self.is_unsafe() {
            ret
        }

        let d = find_directive(directives, Directive.Deprecated)
        if d != nil {
            if d.args.len == 0 {
                self.push_err(tok, LogMsg.UsingDeprecated, "this code is deprecated")
            } else {
                self.push_err(tok, LogMsg.UsingDeprecated, d.args[0].kind)
            }
            self.push_suggestion(LogMsg.UseUnsafeForDeprecated)
        }
    }

    fn eval_fn(mut self, mut f: &Fn, error_token: Token): &Data {
        if !self.s.is_accessible_define(f.public, f.token) {
            self.push_err(error_token, LogMsg.IdentIsNotAccessible, f.ident)
            self.push_suggestion(LogMsg.MakePubToAccess)
            ret nil
        }

        self.check_deprecated(f.directives, error_token)

        let mut ins = f.instance()
        self.push_reference_to_fn(ins)
        ret self.eval_fn_ins(ins)
    }

    fn push_illegal_cycle_error(mut self, &v1: &Var, &v2: &Var, mut &message: str) {
        const PADDING = 4

        let refers_to = logf(LogMsg.RefersTo, v1.ident, v2.ident)
        message = strings::repeat(" ", PADDING) + refers_to + "\n" + message
    }

    fn check_cross_cycle(mut self, &v: &Var, mut &message: str): bool {
        for _, d in v.depends {
            if d == self.owner {
                self.push_illegal_cycle_error(v, d, message)
                ret false
            }

            if !self.check_cross_cycle(d, message) {
                self.push_illegal_cycle_error(v, d, message)
                ret false
            }
        }

        ret true
    }

    // Checks owner illegal cycles.
    // Appends depend to depends if there is no illegal cycle.
    // Returns true if e.owner is nil.
    fn check_illegal_cycles(mut self, mut &v: &Var, decl_token: Token): (ok: bool) {
        if self.owner == nil {
            ret true
        }

        // Check illegal cycle for itself.
        // Because refers's owner is ta.
        if self.owner == v {
            self.push_err(self.owner.token, LogMsg.IllegalCycleRefersItself, self.owner.ident)
            ret false
        }

        let mut message = ""

        if !self.check_cross_cycle(v, message) {
            let mut err_msg = message
            message = ""
            self.push_illegal_cycle_error(self.owner, v, message)
            err_msg = err_msg + message
            self.push_err(decl_token, LogMsg.IllegalCrossCycle, err_msg)
            ret false
        }

        self.owner.depends = append(self.owner.depends, v)
        ret true
    }

    fn eval_var(mut self, mut v: &Var, error_token: Token): &Data {
        if !self.s.is_accessible_define(v.public, v.token) {
            self.push_err(error_token, LogMsg.IdentIsNotAccessible, v.ident)
            self.push_suggestion(LogMsg.MakePubToAccess)
            ret nil
        }

        self.check_deprecated(v.directives, error_token)

        v.used = true

        match type self.lookup {
        | &Sema:
            // Check cycles for global scope.
            let ok = self.check_illegal_cycles(v, error_token)
            if !ok {
                ret nil
            }

        | &ScopeChecker:
            if !v.reference || self.is_unsafe() {
                break
            }

            let mut s = (&ScopeChecker)(self.lookup)
            for s.owner == nil && s.parent != nil {
                s = s.parent
            }
            if s.owner != nil && s.owner.anon && v.scope != s.owner.scope {
                self.push_err(error_token, LogMsg.UsedRefInAnonFnFromParentScope, v.ident)
            }
        }

        self.push_reference_to_var(v)

        if !v.cpp_linked && (v.value == nil || v.value.data == nil) {
            if v.constant {
                // Eval constant dependent variable.
                self.s.check_type_var(v, self.s)
                if v.value.data == nil {
                    // Skip error.
                    ret nil
                }
            }
        }

        // Kind is nil, no determined.
        // In other word, not analyzed yet.
        // But this variable is dependency, therefore check this for eval.
        if v.kind == nil || v.kind.kind == nil {
            // Just necessary for global scope, therefore
            // execute if only scope is nil aka variable is not in global scope.
            if v.scope != nil {
                ret nil
            }

            self.s.check_type_var(v, self.lookup)

            // Ignore eval, because analyze is failed.
            if v.kind == nil || v.kind.kind == nil {
                ret nil
            }
        }

        let mut d = &Data{
            lvalue:    !v.constant,
            mutable:   v.mutable,
            reference: v.reference,
            kind:      v.kind.kind,
            model:     v,
        }

        if !v.cpp_linked && v.is_initialized() && v.value.data != nil {
            d.is_rune = v.value.data.is_rune
        }

        if v.constant && v.value.data.constant != nil {
            d.constant = new(Const, *v.value.data.constant)
            d.model = d.constant
        }

        if d.kind.fnc() != nil {
            let mut f = d.kind.fnc()
            if f.decl != nil {
                // Ignore identifier for non-anonymous
                // (because has an identifier via variable).
                f.decl.ident = v.ident
            }
        }

        if d.is_const() {
            self.apply_numeric_prefix(d)
        }

        ret d
    }

    fn eval_type_alias(mut self, mut ta: &TypeAlias, error_token: Token): &Data {
        if !self.s.is_accessible_define(ta.public, ta.token) {
            self.push_err(error_token, LogMsg.IdentIsNotAccessible, ta.ident)
            self.push_suggestion(LogMsg.MakePubToAccess)
            ret nil
        }

        ta.used = true

        let mut kind = ta.kind.kind.kind
        match type kind {
        | &StructIns:
            ret self.__eval_struct((&StructIns)(kind))
        | &Enum:
            ret self.__eval_enum((&Enum)(kind))
        |:
            let mut d = &Data{
                decl: true,
                kind: &TypeKind{
                    generic:   ta.generic,
                    cpp_ident: if ta.cpp_linked { ta.ident } else { ta.kind.kind.cpp_ident },
                    kind:      ta.kind.kind.kind,
                },
            }
            d.model = d.kind
            ret d
        }
    }

    fn eval_def(mut self, mut def: any, ident: Token): &Data {
        match type def {
        | &Var:
            ret self.eval_var((&Var)(def), ident)
        | &Enum:
            ret self.eval_enum((&Enum)(def), ident)
        | &Struct:
            ret self.eval_struct((&Struct)(def).instance(), ident)
        | &Fn:
            ret self.eval_fn((&Fn)(def), ident)
        | &FnIns:
            ret self.eval_fn_ins((&FnIns)(def))
        | &TypeAlias:
            ret self.eval_type_alias((&TypeAlias)(def), ident)
        |:
            self.push_err(ident, LogMsg.IdentNotExist, ident.kind)
            ret nil
        }
    }

    fn eval_ident(mut self, ident: &IdentExpr): &Data {
        let mut def = self.get_def(ident.ident, ident.cpp_linked)
        ret self.eval_def(def, ident.token)
    }

    fn eval_unary(mut &self, mut u: &UnaryExpr): &Data {
        let mut unary = UnaryEval.new(self)
        ret unary.eval(u)
    }

    fn eval_variadic(mut &self, mut v: &VariadicExpr): &Data {
        if v.expr == nil {
            self.push_err(v.token, LogMsg.InvalidExpr)
            ret nil
        }

        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        let mut d = self.eval_expr_kind(v.expr)
        if d == nil {
            ret nil
        }

        if !d.kind.variadicable() {
            self.push_err(v.token, LogMsg.VariadicWithNonVariadicable, d.kind.to_str())
            ret nil
        }

        let slc = d.kind.slc()
        d.kind = &TypeKind{
            variadic:  true,
            generic:   slc.elem.generic,
            cpp_ident: slc.elem.cpp_ident,
            kind:      slc.elem.kind,
        }
        ret d
    }

    fn eval_unsafe(mut &self, mut u: &UnsafeExpr): &Data {
        let unsafety = self.unsafety
        self.unsafety = true

        let mut d = self.eval_expr_kind(u.expr)

        self.unsafety = unsafety

        ret d
    }

    fn eval_arr(mut &self, mut s: &SliceExpr): &Data {
        // Arrays always has type prefixes.
        let mut pt = self.prefix.arr()

        let mut arr = &Arr{
            auto: false,
            n:    0,
            elem: pt.elem,
        }

        let mut filled = false

        if s.elems.len == 2 {
            match type s.elems[1] {
            | &VariadicExpr:
                if (&VariadicExpr)(s.elems[1]).expr != nil {
                    break
                }
                // Filled.

                if pt.auto {
                    self.push_err(s.token, LogMsg.AutoSizedArrFilled)
                    ret nil
                }

                filled = true
                s.elems = s.elems[:1]
            }
        }

        arr.n = s.elems.len
        if !pt.auto {
            if arr.n > pt.n {
                self.push_err(s.token, LogMsg.OverflowLimits)
            } else if arr.n < pt.n {
                arr.n = pt.n
            }
        }

        let mut model = &ArrayExprModel{
            kind:  arr,
            elems: make([]ExprModel, 0, if filled { 2 } else { s.elems.len }),
        }

        let mut prefix = self.prefix
        self.prefix = arr.elem
        for (_, mut elem) in s.elems {
            let mut d = self.eval_expr_kind(elem)
            if d == nil {
                continue
            }

            self.s.check_assign_type(false, arr.elem, d, s.token)
            model.elems = append(model.elems, d.model)
        }
        self.prefix = prefix

        if filled {
            // Fill mark.
            model.elems = append(model.elems, nil)
        }

        ret &Data{
            mutable: true,
            kind: &TypeKind{
                kind: arr,
            },
            model: model,
        }
    }

    fn eval_exp_slc(mut &self, mut s: &SliceExpr, mut elem_type: &TypeKind): &Data {
        let mut slc = &Slc{
            elem: elem_type,
        }

        let mut model = &SliceExprModel{
            elem_kind: elem_type,
            elems:     make([]ExprModel, 0, s.elems.len),
        }

        let mut prefix = self.prefix
        self.prefix = slc.elem
        for (_, mut elem) in s.elems {
            let mut d = self.eval_expr_kind(elem)
            if d == nil {
                continue
            }

            self.s.check_assign_type(false, slc.elem, d, s.token)
            model.elems = append(model.elems, d.model)
        }
        self.prefix = prefix

        ret &Data{
            mutable: true,
            kind: &TypeKind{
                kind: slc,
            },
            model: model,
        }
    }

    fn eval_slice_expr(mut &self, mut s: &SliceExpr): &Data {
        if self.prefix != nil {
            match {
            | self.prefix.arr() != nil:
                ret self.eval_arr(s)

            | self.prefix.slc() != nil:
                let mut pt = self.prefix.slc()
                ret self.eval_exp_slc(s, pt.elem)
            }
        }

        let mut prefix = self.prefix
        self.prefix = nil

        if s.elems.len == 0 {
            self.push_err(s.token, LogMsg.DynamicTypeAnnotationFailed)
            ret nil
        }

        let mut first_elem = self.eval_expr_kind(s.elems[0])
        if first_elem == nil {
            ret nil
        }

        let mut d = self.eval_exp_slc(s, first_elem.kind)

        self.prefix = prefix
        ret d
    }

    fn check_integer_indexing_by_data(mut self, mut &d: &Data, token: Token) {
        let err_key = check_data_for_integer_indexing(d)
        match err_key {
        | LogMsg.Empty:
            ret

        | LogMsg.InvalidTypeForIndexing:
            self.push_err(token, err_key, d.kind.to_str())

        |:
            self.push_err(token, err_key)
        }
    }

    fn indexing_ptr(mut self, mut &d: &Data, mut &index: &Data, &i: &IndexingExpr) {
        self.check_integer_indexing_by_data(index, i.token)

        let mut ptr = d.kind.ptr()
        match {
        | ptr.is_unsafe():
            self.push_err(i.token, LogMsg.UnsafePtrIndexing)
            ret

        | !self.is_unsafe():
            self.push_err(i.token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
        }

        d.kind = ptr.elem
    }

    fn indexing_arr(mut self, mut &d: &Data, mut &index: &Data, &i: &IndexingExpr) {
        let mut arr = d.kind.arr()
        d.kind = arr.elem
        self.check_integer_indexing_by_data(index, i.token)
        if index.is_const() && index.constant.as_f64() >= f64(arr.n) {
            self.push_err(i.token, LogMsg.OverflowLimits)
        }
    }

    fn indexing_slc(mut self, mut &d: &Data, mut &index: &Data, &i: &IndexingExpr) {
        let mut slc = d.kind.slc()
        d.kind = slc.elem
        self.check_integer_indexing_by_data(index, i.token)

        // Check compile-time bounds.
        if !index.is_const() {
            ret
        }
        match type d.model {
        | &SliceExprModel:
            let mut m = (&SliceExprModel)(d.model)
            let indx = index.constant.as_f64()
            if indx >= f64(m.elems.len) {
                self.push_err(i.token, LogMsg.OverflowLimits)
            } else {
                d.model = m.elems[u64(indx)]
                d.decl = true // Set model flag.
            }
        }
    }

    fn indexing_map(mut self, mut &d: &Data, mut &index: &Data, mut &i: &IndexingExpr) {
        if index == nil {
            ret
        }

        let mut m = d.kind.map()
        let mut atc = AssignTypeChecker{
            s:           self.s,
            dest:        m.key,
            d:           index,
            error_token: i.token,
        }
        _ = atc.check()

        d.kind = m.val
    }

    fn indexing_str(mut self, mut &d: &Data, mut &index: &Data, &i: &IndexingExpr) {
        const BYTE_KIND: str = PrimKind.U8
        d.kind = &TypeKind{kind: build_prim_type(BYTE_KIND)}

        if index == nil {
            ret
        }

        self.check_integer_indexing_by_data(index, i.token)

        if !index.is_const() {
            d.constant = nil
            ret
        }

        if d.is_const() {
            let error_token = i.token
            let j = index.constant.as_i64()
            let s = d.constant.read_str()
            if int(j) >= s.len {
                self.push_err(error_token, LogMsg.OverflowLimits)
            } else {
                d.constant.set_u64(u64(s[j]))
            }
        }
    }

    fn to_indexing(mut self, mut &d: &Data, mut &index: &Data, mut &i: &IndexingExpr) {
        match {
        | d.kind.ptr() != nil:
            self.indexing_ptr(d, index, i)
            ret

        | d.kind.arr() != nil:
            self.indexing_arr(d, index, i)
            ret

        | d.kind.slc() != nil:
            self.indexing_slc(d, index, i)
            ret

        | d.kind.map() != nil:
            self.indexing_map(d, index, i)
            ret

        | d.kind.prim() != nil:
            let prim = d.kind.prim()
            match {
            | prim.is_str():
                self.indexing_str(d, index, i)
                ret
            }
        }

        self.push_err(i.token, LogMsg.NotSupportsIndexing, d.kind.to_str())
    }

    fn push_generics_from_index_data(mut &self, mut &decl: &IdentTypeDecl, mut &i: &IndexingExpr): bool {
        match type i.index {
        | &UnaryExpr:
            // Unary eval catches type declarations.
            // Therefore use unary eval algorithm for eval related type declarations.
            let mut d = self.eval_unary((&UnaryExpr)(i.index))
            if !d.decl {
                self.push_err(i.token, LogMsg.InvalidSyntax)
                ret false
            }
            decl.generics = append(decl.generics, &TypeDecl{
                kind: d.kind,
            })
        | &TypeDecl:
            decl.generics = append(decl.generics, (&TypeDecl)(i.index))
        | &IdentExpr:
            let mut expr = (&IdentExpr)(i.index)
            decl.generics = append(decl.generics, &TypeDecl{
                kind: &IdentTypeDecl{
                    token: expr.token,
                    ident: expr.ident,
                }
            })
        | &TupleExpr:
            for (_, mut expr) in (&TupleExpr)(i.index).expr {
                match type expr.kind {
                | &TypeDecl:
                    decl.generics = append(decl.generics, (&TypeDecl)(expr.kind))
                | &IdentExpr:
                    let mut expr = (&IdentExpr)(expr.kind)
                    decl.generics = append(decl.generics, &TypeDecl{
                        kind: &IdentTypeDecl{
                            token: expr.token,
                            ident: expr.ident,
                        },
                    })
                }
            }
        |:
            self.push_err(i.token, LogMsg.InvalidSyntax)
            ret false
        }
        ret true
    }

    fn eval_ident_decl_from_indexing(mut &self, mut &d: &Data, mut &i: &IndexingExpr): &Data {
        let mut tdecl = &TypeDecl{}
        let mut decl: &IdentTypeDecl = nil
        match type i.expr {
        | &IdentExpr:
            let mut expr = (&IdentExpr)(i.expr)
            decl = &IdentTypeDecl{
                token: expr.token,
                ident: expr.ident,
            }
            tdecl.kind = decl
        | &NsSelectionExpr:
            let mut expr = (&NsSelectionExpr)(i.expr)
            decl = &IdentTypeDecl{
                token: expr.ident,
                ident: expr.ident.kind,
            }
            tdecl.kind = &NamespaceTypeDecl{
                idents: expr.ns,
                kind:   decl,
            }
        |:
            self.push_err(i.token, LogMsg.InvalidSyntax)
            ret nil
        }
        if !self.push_generics_from_index_data(decl, i) {
            ret nil
        }
        ret self.eval_type(tdecl)
    }

    fn eval_indexing(mut &self, mut i: &IndexingExpr): &Data {
        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        let mut d = self.eval_expr_kind(i.expr)
        if d == nil {
            ret nil
        }

        // Catch types.
        if d.decl {
            ret self.eval_ident_decl_from_indexing(d, i)
        }

        let mut old_d = *d

        let mut index = self.eval_expr_kind(i.index)
        if index == nil {
            ret nil
        }

        // Set decl to true. It's a kind of flag.
        // If decl is true after indexing eval, do not touch model.
        // Setted by indexing eval.
        d.decl = false

        self.to_indexing(d, index, i)
        if d.is_const() {
            d.decl = false
            d.model = d.constant
        } else if d.decl {
            d.decl = false
        } else {
            d.model = &IndexingExprModel{
                token: i.token,
                expr:  new(Data, old_d),
                index: index,
            }
        }

        ret d
    }

    // Returns left and right index values.
    // Returns zero integer expression if slicing have not left index.
    // So, left index always represents an expression.
    // Left data is nil if expression eval failed.
    fn eval_slicing_exprs(mut &self, mut &s: &SlicingExpr): (&Data, &Data) {
        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        let mut l: &Data = nil
        let mut r: &Data = nil

        if s.start != nil {
            l = self.eval_expr_kind(s.start)
            if l != nil {
                self.check_integer_indexing_by_data(l, s.token)
            } else {
                ret nil, nil
            }
        } else {
            l = &Data{
                constant: Const.new_i64(0),
                kind:     &TypeKind{kind: build_prim_type(PrimKind.Int)},
            }
            l.model = l.constant
        }

        if s.to != nil {
            r = self.eval_expr_kind(s.to)
            if r != nil {
                self.check_integer_indexing_by_data(r, s.token)
            } else {
                ret nil, nil
            }
        }

        ret l, r
    }

    fn slicing_arr(self, mut &d: &Data) {
        let mut elem_type = d.kind.arr().elem
        d.kind = &TypeKind{
            kind: &Slc{
                elem: elem_type,
            },
        }

        d.lvalue = false

        // Keep mutability id already mutable.
        // Be mutable, if element is not mutable-type.
        d.mutable = d.mutable || !elem_type.mutable()
    }

    fn slicing_slc(self, mut &d: &Data) {
        d.lvalue = false
    }

    fn slicing_str(self, mut &d: &Data, &l: &Data, &r: &Data) {
        d.lvalue = false
        d.mutable = true
        if !d.is_const() {
            ret
        }

        if l == nil || r == nil {
            d.constant = nil
            ret
        }

        if l.is_const() && r.is_const() {
            let left = l.constant.as_i64()
            if left < 0 {
                ret
            }

            let s = d.constant.read_str()
            let mut right: i64 = 0
            if r == nil {
                right = i64(s.len)
            } else {
                right = r.constant.as_i64()
            }

            if left > right {
                ret
            }
            d.constant.set_str(s[left:right])
            d.decl = true // Set model flag.
        } else {
            d.constant = nil
        }
    }

    fn check_slicing(mut self, mut &d: &Data, &l: &Data, &r: &Data, &s: &SlicingExpr) {
        match {
        | d.kind.arr() != nil:
            self.slicing_arr(d)
            ret
        | d.kind.slc() != nil:
            self.slicing_slc(d)
            ret
        | d.kind.prim() != nil:
            let prim = d.kind.prim()
            match {
            | prim.is_str():
                self.slicing_str(d, l, r)
                ret
            }
        }

        self.push_err(s.token, LogMsg.NotSupportsSlicing, d.kind.to_str())
    }

    fn eval_slicing(mut &self, mut s: &SlicingExpr): &Data {
        let mut d = self.eval_expr_kind(s.expr)
        if d == nil {
            ret nil
        }

        let (mut l, mut r) = self.eval_slicing_exprs(s)
        if l == nil {
            ret d
        }

        // Set decl to true. It's a kind of flag.
        // If decl is true after indexing eval, do not touch model.
        // Setted by indexing eval.
        d.decl = false

        self.check_slicing(d, l, r, s)
        d.cast_kind = nil

        if d.is_const() {
            d.decl = false
            d.model = d.constant
        } else if d.decl {
            d.decl = false
        } else {
            let mut model = &SlicingExprModel{
                token: s.token,
                expr: d.model,
                left: l.model,
            }

            if r != nil {
                model.right = r.model
            }

            d.model = model
        }

        ret d
    }

    fn cast_ptr(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        let sptr = d.kind.sptr()
        if sptr != nil {
            if !t.ptr().elem.equals(sptr.elem) {
                self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
            }
            ret
        }

        if !self.is_unsafe() {
            self.push_err(error_token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            ret
        }

        let prim = d.kind.prim()
        if d.kind.ptr() == nil && (prim == nil || !types::is_int(prim.to_str())) {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
        }

        d.constant = nil
    }

    fn cast_struct(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        let mut tr = d.kind.trt()
        if tr == nil {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
            ret
        }

        let mut s = t.strct()
        self.push_reference_to_struct(s)

        if !s.decl.is_implements(tr) {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
        }
    }

    fn cast_ref(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        let mut sptr = t.sptr()

        let mut ptr = d.kind.ptr()
        if ptr != nil && sptr.elem.equals(ptr.elem) {
            if !self.is_unsafe() {
               self.push_err(error_token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            }

            // Ok.
            ret
        }

        // For traits.
        if sptr.elem.strct() != nil {
            self.cast_struct(sptr.elem, d, error_token)
            ret
        }

        self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
    }

    fn cast_slc(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        if d.kind.enm() != nil {
            if d.kind.enm().kind.kind.prim() == nil || !d.kind.enm().kind.kind.prim().is_str() {
                self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
                ret
            }
        } else if d.kind.prim() == nil || !d.kind.prim().is_str() {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
            ret
        }

        t = t.slc().elem
        let prim = t.prim()
        if prim == nil || (!prim.is_u8() && !prim.is_i32()) {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
        }
    }

    fn cast_str(mut self, mut d: &Data, error_token: Token) {
        if d.kind.enm() != nil {
            let mut e = d.kind.enm()
            if e.kind.kind.prim() != nil && e.kind.kind.prim().is_str() {
                ret
            }
        }

        if d.kind.prim() != nil {
            let prim = d.kind.prim()
            if !prim.is_u8() && !prim.is_i32() {
                self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, PrimKind.Str, d.kind.to_str())
            }
            ret
        }

        if d.kind.slc() == nil {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, PrimKind.Str, d.kind.to_str())
            ret
        }

        let mut t = d.kind.slc().elem
        let prim = t.prim()
        if prim == nil || (!prim.is_u8() && !prim.is_i32()) {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, PrimKind.Str, d.kind.to_str())
        }
    }

    fn cast_int(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        if d.is_const() {
            let prim = t.prim()
            match {
            | types::is_sig_int(prim.kind):
                d.constant.set_i64(d.constant.as_i64())

            | types::is_unsig_int(prim.kind):
                d.constant.set_u64(d.constant.as_u64())
            }
        }

        if d.kind.enm() != nil {
            let e = d.kind.enm()
            if types::is_num(e.kind.kind.to_str()) {
                ret
            }
        }

        if d.kind.sptr() != nil {
            let prim = t.prim()
            if !prim.is_uintptr() {
                self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
            }
            ret
        }
        if d.kind.ptr() != nil {
            let prim = t.prim()
            if prim.is_uintptr() {
                // Ignore case.
            } else if !self.is_unsafe() {
                self.push_err(error_token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            } else if !prim.is_i32() && !prim.is_i64() && !prim.is_u16() && !prim.is_u32() && !prim.is_u64() {
                self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
            }
            ret
        }

        let prim = d.kind.prim()
        if prim != nil && types::is_num(prim.to_str()) {
            ret
        }

        self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
    }

    fn cast_num(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        if d.is_const() {
            let prim = t.prim()
            match {
            | types::is_float(prim.kind):
                d.constant.set_f64(d.constant.as_f64())

            | types::is_sig_int(prim.kind):
                d.constant.set_i64(d.constant.as_i64())

            | types::is_unsig_int(prim.kind):
                d.constant.set_u64(d.constant.as_u64())
            }
        }

        if d.kind.enm() != nil {
            let e = d.kind.enm()
            if types::is_num(e.kind.kind.to_str()) {
                ret
            }
        }

        let prim = d.kind.prim()
        if prim != nil && types::is_num(prim.to_str()) {
            ret
        }

        self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
    }

    fn cast_prim(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        let prim = t.prim()
        match {
        | prim.is_any():
            // The any type supports casting to any data type.

        | prim.is_str():
            self.cast_str(d, error_token)

        | types::is_int(prim.to_str()):
            self.cast_int(t, d, error_token)

        | types::is_num(prim.to_str()):
            self.cast_num(t, d, error_token)

        |:
            self.push_err(error_token, LogMsg.TypeNotSupportsCasting, t.to_str())
        }
    }

    fn cast_constant(mut self, mut &t: &TypeKind, mut &d: &Data) {
        let prim = t.prim()
        if prim == nil || !d.is_const() {
            ret
        }

        match {
        | types::is_sig_int(prim.kind):
            d.constant.set_i64(d.constant.as_i64())

        | types::is_unsig_int(prim.kind):
            d.constant.set_u64(d.constant.as_u64())

        | types::is_float(prim.kind):
            d.constant.set_f64(d.constant.as_f64())
        }

        d.model = d.constant
    }

    fn eval_cast_by_type_n_data(mut self, mut t: &TypeKind, mut d: &Data, mut error_token: Token): &Data {
        if d != nil && d.decl {
            self.push_err(error_token, LogMsg.InvalidExpr)
            ret nil
        }

        match {
        | d.kind.prim() != nil && d.kind.prim().is_any():
            if t.enm() != nil {
                self.push_err(error_token, LogMsg.EnumCastedFromAny)
                self.push_suggestion(LogMsg.CastToEnumTypeInsteadOfEnum)
            }

        | t.ptr() != nil:
            self.cast_ptr(t, d, error_token)

        | t.sptr() != nil:
            self.cast_ref(t, d, error_token)

        | t.slc() != nil:
            self.cast_slc(t, d, error_token)

        | t.strct() != nil:
            self.cast_struct(t, d, error_token)

        | t.prim() != nil:
            self.cast_prim(t, d, error_token)

        |:
            self.push_err(error_token, LogMsg.TypeNotSupportsCasting, t.to_str())
            d = nil
        }

        if d == nil {
            ret nil
        }

        // Keep mutability if data is already mutable.
        // Even if the data is not mutable, set as mutable if the type is not mutable-type.
        d.mutable = d.mutable || (!d.kind.mutable() && t.mutable())

        d.lvalue = false
        d.decl = false
        self.cast_constant(t, d)

        if d.kind.enm() == nil || !d.kind.enm().kind.kind.equals(t) {
            d.cast_kind = t
            apply_cast_kind(d)
            (&CastingExprModel)(d.model).token = error_token
        } else {
            d.kind = t
        }

        ret d
    }

    fn eval_cast(mut &self, mut c: &CastExpr): &Data {
        let mut t = build_type(c.kind)
        let ok = self.s.check_type(t, self.lookup)
        if !ok {
            ret nil
        }

        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        let mut d = self.eval_expr_kind(c.expr)
        if d == nil {
            ret nil
        }

        ret self.eval_cast_by_type_n_data(t.kind, d, c.kind.token)
    }

    fn eval_ns_selection(mut self, s: &NsSelectionExpr): &Data {
        let path = build_link_path_by_tokens(s.ns)
        let mut imp = self.lookup.select_package(fn(imp: &ImportInfo): bool {
            if s.ns.len == 1 && imp.alias == path {
                ret true
            }
            ret imp.link_path == path && imp.is_accessible_via_selection()
        })

        if imp == nil {
            self.push_err(s.ident, LogMsg.NamespaceNotExist, path)
            ret nil
        }

        let mut lookup = self.lookup
        self.lookup = imp

        const CPP_LINKED = false
        self.disallow_builtin()
        let mut def = self.get_def(s.ident.kind, CPP_LINKED)
        self.allow_builtin()
        self.lookup = lookup

        let mut d = self.eval_def(def, s.ident)

        ret d
    }

    fn eval_struct_lit_explicit(mut &self, mut s: &StructIns,
        mut exprs: []ExprData, mut error_token: Token): &Data {
        let ok = self.s.check_generic_quantity(s.decl.generics.len, s.generics.len, error_token)
        if !ok {
            ret nil
        }
        // NOTICE: Instance already checked (just fields) if generic quantity passes.

        if self.field != nil && self.field.decl.owner == s.decl {
            self.push_err(error_token, LogMsg.IllegalCycleRefersItself, s.decl.ident)
        }

        self.push_reference_to_struct(s)
        self.check_deprecated(s.decl.directives, error_token)

        let mut slc = StructLitChecker{
            e:           self,
            error_token: error_token,
            s:           s,
        }
        slc.check(exprs)

        ret &Data{
            mutable: !self.immutable,
            kind:    &TypeKind{
                kind: s,
            },
            model: &StructLitExprModel{
                token: error_token,
                strct: s,
                args:  slc.args,
            },
        }
    }

    fn eval_struct_lit(mut &self, mut lit: &StructLit): &Data {
        let mut t = build_type(lit.kind)
        let ok = self.s.check_type(t, self.lookup)
        if !ok {
            ret nil
        }

        let mut s = t.kind.strct()
        if s == nil {
            if t.kind.sptr() != nil {
                s = t.kind.sptr().elem.strct()
                if s != nil {
                    goto eval
                }
            }
            self.push_err(lit.kind.token, LogMsg.InvalidSyntax)
            ret nil
        }

    eval:
        let mut d = self.eval_struct_lit_explicit(s, lit.exprs, lit.kind.token)
        if t.kind.sptr() != nil {
            let mut model = (&StructLitExprModel)(d.model)
            make_struct_lit_alloc(d, model)
        }
        ret d
    }

    fn eval_type(mut self, mut t: &TypeDecl): &Data {
        let mut tk = build_type(t)
        let ok = self.s.check_type(tk, self.lookup)
        if !ok {
            ret nil
        }
        ret &Data{
            decl:  true,
            kind:  tk.kind,
            model: tk.kind,
        }
    }

    fn call_type_fn(mut &self, mut &fc: &FnCallExpr, mut &d: &Data) {
        if fc.generics.len > 0 {
            self.push_err(fc.token, LogMsg.TypeNotSupportsGenerics, d.kind.to_str())
        } else if fc.args.len < 1 {
            self.push_err(fc.token, LogMsg.MissingExprFor, "v")
        } else if fc.args.len > 1 {
            self.push_err(fc.args[1].token, LogMsg.ArgumentOverflow)
        }

        if fc.args.len > 0 {
            let mut prefix = self.prefix
            self.prefix = nil
            let mut arg = self.eval_expr_kind(fc.args[0].kind)
            self.prefix = prefix

            if arg != nil {
                d = self.eval_cast_by_type_n_data(d.kind, arg, fc.args[0].token)
            }
        }

        if d != nil {
            d.decl = false
        }
    }

    fn check_fn_call_generics(mut self, mut f: &FnIns,
        mut fc: &FnCallExpr): (ok: bool, dynamic_annotation: bool) {
        match {
        | f.decl.generics.len > 0 && fc.generics.len == 0 && f.params.len > 0:
            dynamic_annotation = true
            // Make empty types to generics for ordering.
            f.generics = make([]&TypeKind, f.decl.generics.len)
            ret true, true

        | !self.s.check_generic_quantity(f.decl.generics.len, fc.generics.len, fc.token):
            ret false, false

        |:
            // Build real kinds of generic types.
            f.generics = make([]&TypeKind, 0, f.decl.generics.len)
            for (_, mut g) in fc.generics {
                let mut k = build_type(g)
                ok = self.s.check_type(k, self.lookup)
                if !ok {
                    ret false, false
                }
                f.generics = append(f.generics, k.kind)
            }

            ret true, false
        }
    }

    fn call_builtin_fn(mut &self, mut &fc: &FnCallExpr, mut &d: &Data) {
        d = find_builtin_caller(d.kind.fnc().caller)(self, fc, d)
        if d == nil {
            ret
        }

        d.mutable = true
    }

    fn check_fn_of_concurrent_call(mut self, &f: &FnIns, error_token: Token) {
        if self.is_unsafe() {
            ret
        }

        for _, p in f.params {
            if p.decl.reference {
                self.push_err(error_token, LogMsg.ConcurrenctCallWithRefParam)
                ret
            }
        }
    }

    fn process_exceptional_handler(mut self, mut &f: &FnIns, mut &fc: &FnCallExpr, mut &d: &Data) {
        let result_needed = !f.decl.is_void() && !self.ignored
        let mut csc: &ScopeChecker = nil
        let mut ch: &Scope = nil

        let mut model = (&FnCallExprModel)(d.model)

        match type self.lookup {
        | &Sema:
            let mut s = (&Sema)(self.lookup)
            csc = new_scope_checker(s, nil)
            if result_needed {
                csc.result = f.result
            }
            ch = &Scope{}
            csc.table.vars = append(csc.table.vars, build_error_var(ch, fc))
            csc.check(fc.exception, ch)

        | &ScopeChecker:
            let mut sc = (&ScopeChecker)(self.lookup)
            csc = sc.new_child_checker()
            if result_needed {
                csc.result = f.result
            }
            ch = sc.get_child()
            csc.table.vars = append(csc.table.vars, build_error_var(ch, fc))
            sc.check_child_ssc(fc.exception, ch, csc)
        }

        model.assigned = result_needed
        model.except = ch

        if result_needed && csc.result != nil {
            self.push_err(fc.token, LogMsg.MissingAssignRet)
        }
    }

    fn call_fn(mut &self, mut &fc: &FnCallExpr, mut &d: &Data) {
        let mut f = d.kind.fnc()
        if f.is_builtin() {
            self.call_builtin_fn(fc, d)
            ret
        }

        if !f.decl.is_method() && has_directive(f.decl.directives, Directive.Test) {
            self.push_err(fc.token, LogMsg.TestCalled)
            d = nil
            ret
        }

        if !d.mutable && f.decl.is_method() && !f.decl.statically && f.decl.params[0].mutable {
            self.push_err(fc.token, LogMsg.MutOperationOnImmut)
        } else if !self.is_unsafe() && f.decl.unsafety {
            self.push_err(fc.token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
        }

        let (mut ok, dynamic_annotation) = self.check_fn_call_generics(f, fc)
        if !ok {
            d = nil
            ret
        }

        let mut old = self.s
        if f.decl.owner != nil {
            self.s = f.decl.owner.sema
        }

        defer {
            if old != self.s {
                old.errors = append(old.errors, self.s.errors...)
                self.s.errors = nil
            }
            self.s = old
        }

        if !dynamic_annotation {
            if !f.reloaded {
                ok = self.s.reload_fn_ins_types(f)
                if !ok {
                    d = nil
                    ret
                }
                f.reloaded = true
            }
        } else {
            self.s.build_fn_non_generic_type_kinds(f)
        }

        let mut fcac = FnCallArgChecker{
            e:                  self,
            f:                  f,
            args:               fc.args,
            dynamic_annotation: dynamic_annotation,
            error_token:        fc.token,
        }
        if f.decl.owner != nil {
            old, self.s = self.s, old // Save current Sema.
            ok = fcac.check()
            old, self.s = self.s, old // Save owner Sema.
        } else {
            ok = fcac.check()
        }

        if !ok && dynamic_annotation {
            d = nil
            ret
        }

        let (is_unique_ins, pos) = f.decl.append_instance(f)
        if !is_unique_ins {
            f = f.decl.instances[pos]
        }

        let mut call_model = d.model

        if f.decl.is_void() {
            d = build_void_data()
        } else {
            if dynamic_annotation {
                ok = self.s.reload_fn_ins_types(f)
                if !ok {
                    d = nil
                    ret
                }
                f.reloaded = true
            }

            d.kind = f.result
            d.lvalue = false
        }

        d.mutable = true
        d.model = &FnCallExprModel{
            token: fc.token,
            func:  f,
            expr:  call_model,
            args:  fcac.arg_models,
        }

        if f.decl.exceptional {
            match {
            | fc.unhandled():
                self.push_err(fc.token, LogMsg.UnhandledExceptional)
                self.push_suggestion(LogMsg.HandleExceptional)

            | fc.ignored():
                // Ok.

            |: // Handled with scope.
                self.process_exceptional_handler(f, fc, d)
            }
        } else if !fc.unhandled() {
            self.push_err(fc.token, LogMsg.HandledUnexceptional)
        }

        if f.generics.len > 0 && is_unique_ins {
            // Check generic function instance instantly.
            self.s.check_fn_ins(f)
        }
    }

    fn eval_fn_call(mut &self, mut fc: &FnCallExpr): &Data {
        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        match type fc.expr.kind {
        | &IdentExpr:
            // Use fc.expr.token.kind instead of casting.
            // Same thing, but more efficient and performant.
            if fc.expr.token.kind == TokenKind.Error {
                ret builtin_caller_error(self, fc)
            }
        }

        let mut d = self.eval_expr_kind(fc.expr.kind)
        if d == nil {
            ret nil
        }

        if d.decl {
            self.call_type_fn(fc, d)
            ret d
        }

        if d.kind.fnc() == nil {
            self.push_err(fc.token, LogMsg.InvalidSyntax)
            ret nil
        }

        self.call_fn(fc, d)
        ret d
    }

    fn eval_enum_static(mut self, mut enm: &Enum, ident: Token): &Data {
        let mut d = &Data{
            lvalue:  false,
            decl:    false,
            mutable: false,
            kind:    &TypeKind{
                kind: enm,
            },
        }

        let mut item = enm.find_item(ident.kind)
        if item == nil {
            self.push_err(ident, LogMsg.ObjHaveNotIdent, enm.ident, ident.kind)
        } else {
            d.constant = new(Const, *item.value.data.constant)
            d.model = d.constant
            apply_cast_model_by_enum(d, enm)
        }

        ret d
    }

    fn eval_struct_static(mut self, mut s: &StructIns, ident: Token): &Data {
        let mut d = &Data{
            lvalue:  false,
            decl:    false,
            mutable: false,
        }

        // Method.
        const STATIC = true
        let mut method = s.find_method(ident.kind, STATIC)
        if method != nil {
            if !self.s.is_accessible_define(method.public, method.token) {
                self.push_err(ident, LogMsg.IdentIsNotAccessible, ident.kind)
                self.push_suggestion(LogMsg.MakePubToAccess)
            }

            let mut ins = method.instance()
            ins.owner = s
            self.push_reference_to_fn(ins)
            d.model = &StructStaticIdentExprModel{
                structure: s,
                expr:      d.model,
                method:    ins,
            }
            d.kind = &TypeKind{kind: ins}
            ret d
        }

        let mut sttc = s.decl.find_static(ident.kind)
        if sttc != nil {
            ret self.eval_var(sttc, ident)
        }

        self.push_err(ident, LogMsg.ObjHaveNotIdent, s.decl.ident, ident.kind)
        ret nil
    }

    fn eval_trait_sub_ident(mut self, mut d: &Data, mut trt: &Trait, mut ident: Token): &Data {
        let mut f = trt.find_method(ident.kind)
        if f == nil {
            self.push_err(ident, LogMsg.ObjHaveNotIdent, trt.ident, ident.kind)
            ret nil
        }

        ret &Data{
            lvalue:  false,
            decl:    false,
            mutable: false,
            kind:    &TypeKind{kind: f.instance()},
            model:   &TraitSubIdentExprModel{
                token: ident,
                expr:  d.model,
                ident: ident.kind,
            },
        }
    }

    fn eval_struct_sub_ident(mut self, mut d: &Data, mut s: &StructIns, si: &SubIdentExpr, ref: bool): &Data {
        let mut f = s.find_field(si.ident.kind)
        if f != nil {
            if !self.s.is_accessible_define(f.decl.public, f.decl.token) {
                self.push_err(si.ident, LogMsg.IdentIsNotAccessible, f.decl.ident)
                self.push_suggestion(LogMsg.MakePubToAccess)
            }

            let mut model = &StructSubIdentExprModel{
                expr_kind: d.kind,
                expr:      d.model,
                field:     f,
            }
            d.model = model
            d.kind = f.kind
            d.lvalue = true

            if f.decl.mutable && !d.mutable {
                // Interior mutability.
                match type self.lookup {
                | &ScopeChecker:
                    let scope = (&ScopeChecker)(self.lookup).get_root()
                    d.mutable = scope.owner != nil && scope.owner.owner == s
                    if d.mutable {
                        let mut field = (&Var)(model.expr)
                        let mut v = &Var{
                            scope:      field.scope,
                            token:      field.token,
                            ident:      field.ident,
                            cpp_linked: field.cpp_linked,
                            constant:   field.constant,
                            kind:       field.kind,
                            value:      field.value,
                        }
                        v.mutable = true
                        model.expr = v
                    }
                }
            }

            ret d
        }

        const STATIC = false
        let mut m = s.find_method(si.ident.kind, STATIC)
        if m == nil {
            self.push_err(si.ident, LogMsg.ObjHaveNotIdent, s.decl.ident, si.ident.kind)
            ret nil
        }
        if !self.s.is_accessible_define(m.public, m.token) {
            self.push_err(si.ident, LogMsg.IdentIsNotAccessible, m.ident)
            self.push_suggestion(LogMsg.MakePubToAccess)
        }

        if m.params[0].is_ref() && !ref {
            self.push_err(si.ident, LogMsg.RefMethodUsedWithNotRefInstance)
        }

        self.check_deprecated(m.directives, si.ident)

        let mut ins = m.instance()
        ins.owner = s
        self.push_reference_to_fn(ins)
        d.model = &StructSubIdentExprModel{
            expr_kind: d.kind,
            expr:      d.model,
            method:    ins,
        }
        d.kind = &TypeKind{kind: ins}
        ret d
    }

    fn eval_slice_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
        match ident.kind {
        | "len":
            ret &Data{
                mutable: false,
                kind:    &TypeKind{kind: build_prim_type(PrimKind.Int)},
                model:   &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "len()",
                },
            }
    
        | "cap":
            ret &Data{
                mutable: false,
                kind:    &TypeKind{kind: build_prim_type(PrimKind.Int)},
                model:   &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "cap()",
                },
            }

        | "swap":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: BUILTIN_CALLER_COMMON_MUT,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "i",
                                },
                                kind: &TypeKind{kind: build_prim_type(PrimKind.Int)},
                            },
                            &ParamIns{
                                decl: &Param{
                                    ident: "j",
                                },
                                kind: &TypeKind{kind: build_prim_type(PrimKind.Int)},
                            },
                        ],
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "swap",
                },
            }

        |:
            self.push_err(ident, LogMsg.ObjHaveNotIdent, d.kind.to_str(), ident.kind)
            ret nil
        }
    }

    fn eval_array_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
        match ident.kind {
        | "len":
            let mut c = Const.new_i64(i64(d.kind.arr().n))
            ret &Data{
                constant: c,
                mutable:  false,
                kind:     &TypeKind{kind: build_prim_type(PrimKind.Int)},
                model:    c,
            }

        | "swap":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: BUILTIN_CALLER_COMMON_MUT,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "i",
                                },
                                kind: &TypeKind{kind: build_prim_type(PrimKind.Int)},
                            },
                            &ParamIns{
                                decl: &Param{
                                    ident: "j",
                                },
                                kind: &TypeKind{kind: build_prim_type(PrimKind.Int)},
                            },
                        ],
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "swap",
                },
            }

        |:
            self.push_err(ident, LogMsg.ObjHaveNotIdent, d.kind.to_str(), ident.kind)
            ret nil
        }
    }

    fn eval_map_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
        let mut map_kind = d.kind.map()

        match ident.kind {
        | "len":
            ret &Data{
                mutable: false,
                kind:    &TypeKind{kind: build_prim_type(PrimKind.Int)},
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "len()",
                },
            }

        | "clear":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: BUILTIN_CALLER_COMMON_MUT,
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "clear",
                },
            }

        | "keys":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: BUILTIN_CALLER_COMMON_MUT,
                        result: &TypeKind{
                            kind: &Slc{
                                elem: map_kind.key,
                            },
                        },
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "keys",
                },
            }

        | "values":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: BUILTIN_CALLER_COMMON_MUT,
                        result: &TypeKind{
                            kind: &Slc{
                                elem: map_kind.val,
                            },
                        },
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "values",
                },
            }

        | "has":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: BUILTIN_CALLER_COMMON,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "key",
                                },
                                kind: map_kind.key,
                            },
                        ],
                        result: &TypeKind{kind: build_prim_type(PrimKind.Bool)},
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "has",
                },
            }

        | "del":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: BUILTIN_CALLER_COMMON_MUT,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "key",
                                },
                                kind: map_kind.key,
                            },
                        ],
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "del",
                },
            }

        |:
            self.push_err(ident, LogMsg.ObjHaveNotIdent, map_kind.to_str(), ident.kind)
            ret nil
        }
    }

    fn eval_str_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
        let mut str_kind = &TypeKind{kind: build_prim_type(PrimKind.Str)}
        match ident.kind {
        | "len":
            let mut sd = &Data{
                kind:    &TypeKind{kind: build_prim_type(PrimKind.Int)},
            }
            if d.is_const() {
                sd.constant = Const.new_i64(i64(d.constant.read_str().len))
                sd.model = sd.constant
            } else {
                sd.model = &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "len()",
                }
            }
            ret sd

        |:
            self.push_err(ident, LogMsg.ObjHaveNotIdent, str_kind.to_str(), ident.kind)
            ret nil
        }
    }

    fn eval_int_type_static(mut self, ident: Token): &Data {
        const kind: str = PrimKind.Int

        match ident.kind {
        | "MAX":
            let mut c = Const.new_i64(i64(types::max(kind)))
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_i64(i64(types::min(kind)))
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_uint_type_static(mut self, ident: Token): &Data {
        const kind: str = PrimKind.Uint

        match ident.kind {
        | "MAX":
            let mut c = Const.new_u64(u64(types::max(kind)))
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_i8_type_static(mut self, ident: Token): &Data {
        const kind: str = PrimKind.I8
        const min = types::MIN_I8
        const max = types::MAX_I8

        match ident.kind {
        | "MAX":
            let mut c = Const.new_i64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_i64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_i16_type_static(mut self, ident: Token): &Data {
        const kind: str = PrimKind.I16
        const min = types::MIN_I16
        const max = types::MAX_I16

        match ident.kind {
        | "MAX":
            let mut c = Const.new_i64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_i64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_i32_type_static(mut self, ident: Token): &Data {
        const kind: str = PrimKind.I32
        const min = types::MIN_I32
        const max = types::MAX_I32

        match ident.kind {
        | "MAX":
            let mut c = Const.new_i64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_i64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_i64_type_static(mut self, ident: Token): &Data {
        const kind: str = PrimKind.I64
        const min = types::MIN_I64
        const max = types::MAX_I64

        match ident.kind {
        | "MAX":
            let mut c = Const.new_i64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_i64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_u8_type_static(mut self, ident: Token): &Data {
        const kind: str = PrimKind.U8
        const max = types::MAX_U8

        match ident.kind {
        | "MAX":
            let mut c = Const.new_u64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_u16_type_static(mut self, ident: Token): &Data {
        const kind: str = PrimKind.U16
        const max = types::MAX_U16

        match ident.kind {
        | "MAX":
            let mut c = Const.new_u64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_u32_type_static(mut self, ident: Token): &Data {
        const kind: str = PrimKind.U32
        const max = types::MAX_U32

        match ident.kind {
        | "MAX":
            let mut c = Const.new_u64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_u64_type_static(mut self, ident: Token): &Data {
        const kind: str = PrimKind.U64
        const max = types::MAX_U64

        match ident.kind {
        | "MAX":
            let mut c = Const.new_u64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_f32_type_tatic(mut self, ident: Token): &Data {
        const kind = PrimKind.F32
        const max = types::MAX_F32
        const min = types::MIN_F32
        const smallest_non_zero = types::SMALLEST_NON_ZERO_F32

        match ident.kind {
        | "MAX":
            let mut c = Const.new_f64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_f64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "SMALLEST_NON_ZERO":
            let mut c = Const.new_f64(smallest_non_zero)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)}
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_f64_type_static(mut self, ident: Token): &Data {
        const kind = PrimKind.F64
        const max = types::MAX_F64
        const min = types::MIN_F64
        const smallest_non_zero = types::SMALLEST_NON_ZERO_F64

        match ident.kind {
        | "MAX":
            let mut c = Const.new_f64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_f64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "SMALLEST_NON_ZERO":
            let mut c = Const.new_f64(smallest_non_zero)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)}
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_prim_static(mut self, kind: str, ident: Token): &Data {
        match kind {
        | PrimKind.Int:  ret self.eval_int_type_static(ident)
        | PrimKind.Uint: ret self.eval_uint_type_static(ident)
        | PrimKind.I8:   ret self.eval_i8_type_static(ident)
        | PrimKind.I16:  ret self.eval_i16_type_static(ident)
        | PrimKind.I32:  ret self.eval_i32_type_static(ident)
        | PrimKind.I64:  ret self.eval_i64_type_static(ident)
        | PrimKind.U8:   ret self.eval_u8_type_static(ident)
        | PrimKind.U16:  ret self.eval_u16_type_static(ident)
        | PrimKind.U32:  ret self.eval_u32_type_static(ident)
        | PrimKind.U64:  ret self.eval_u64_type_static(ident)
        | PrimKind.F32:  ret self.eval_f32_type_tatic(ident)
        | PrimKind.F64:  ret self.eval_f64_type_static(ident)
        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret nil
        }
    }

    fn eval_type_static(mut self, mut d: &Data, mut si: &SubIdentExpr): &Data {
        match {
        | d.kind.prim() != nil:
            ret self.eval_prim_static(d.kind.prim().to_str(), si.ident)

        | d.kind.enm() != nil:
            ret self.eval_enum_static(d.kind.enm(), si.ident)

        | d.kind.strct() != nil:
            ret self.eval_struct_static(d.kind.strct(), si.ident)

        |:
            self.push_err(si.ident, LogMsg.TypeNotSupportSubFields, d.kind.to_str())
            ret nil
        }
    }

    fn eval_obj_sub_ident(mut self, mut d: &Data, mut si: &SubIdentExpr): &Data {
        let mut kind = d.kind
        if d.kind.ptr() != nil {
            let ptr = d.kind.ptr()
            if !ptr.is_unsafe() {
                if !si.is_self && !self.is_unsafe() {
                    self.push_err(si.ident, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
                }
                kind = d.kind.ptr().elem
                let mut model = new(Data, *d)

                // Append dereferencing model for pointer.
                let mut token = si.ident
                token.id = TokenId.Op
                token.kind = TokenKind.Star
                d.model = &UnaryExprModel{
                   expr: model,
                   op:   token,
                }
            }
        } else if d.kind.sptr() != nil {
            kind = d.kind.sptr().elem

            // Append dereferencing model for pointer.
            let mut model = new(Data, *d)
            let mut token = si.ident
            token.id = TokenId.Op
            token.kind = TokenKind.Star
            d.model = &UnaryExprModel{
               expr: model,
               op:   token,
            }
        }

        match {
        | d.kind.trt() != nil:
            ret self.eval_trait_sub_ident(d, d.kind.trt(), si.ident)

        | kind.strct() != nil:
            let s = kind.strct()
            if is_instanced_struct(s) {
                let mut used_reference_elem = d.kind.sptr() != nil
                ret self.eval_struct_sub_ident(d, kind.strct(), si, used_reference_elem)
            }

        | kind.slc() != nil:
            ret self.eval_slice_sub_ident(d, si.ident)

        | kind.arr() != nil:
            ret self.eval_array_sub_ident(d, si.ident)

        | kind.map() != nil:
            ret self.eval_map_sub_ident(d, si.ident)

        | kind.prim() != nil:
            let p = kind.prim()
            match p.kind {
            | PrimKind.Str:
                ret self.eval_str_sub_ident(d, si.ident)
            }
        }

        self.push_err(si.ident, LogMsg.ObjNotSupportSubFields, d.kind.to_str())
        ret nil
    }

    fn eval_sub_ident(mut &self, mut si: &SubIdentExpr): &Data {
        let mut prefix = self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        let mut d = self.eval_expr_kind(si.expr)
        if d == nil {
            ret nil
        }

        if d.decl {
            ret self.eval_type_static(d, si)
        }

        ret self.eval_obj_sub_ident(d, si)
    }

    fn eval_tuple(mut &self, mut tup: &TupleExpr): &Data {
        let mut tup_t = &Tuple{}
        tup_t.types = make([]&TypeKind, 0, tup.expr.len)

        let mut model = &TupleExprModel{
            datas: make([]&Data, 0, tup.expr.len),
        }

        let mut ok = true
        for (_, mut expr) in tup.expr {
            let mut d = self.eval_expr_kind(expr.kind)
            if d == nil {
                ok = false
                continue
            }
            tup_t.types = append(tup_t.types, d.kind)
            model.datas = append(model.datas, d)
        }

        if !ok {
            ret nil
        }

        ret &Data{
            kind:  &TypeKind{kind: tup_t},
            model: model,
        }
    }

    fn eval_map(mut &self, mut m: &Map, mut lit: &BraceLit): &Data {
        let mut model = &MapExprModel{
            key_kind: m.key,
            val_kind: m.val,
        }

        for (_, mut expr) in lit.exprs {
            match type expr {
            | &KeyValPair:
                // Ok.

            |:
                self.push_err(lit.token, LogMsg.InvalidSyntax)
                ret nil
            }

            let mut pair = (&KeyValPair)(expr)

            let mut key = self.eval_expr_kind(pair.key)
            if key == nil {
                ret nil
            }

            let mut val = self.eval_expr_kind(pair.val)
            if val == nil {
                ret nil
            }

            self.s.check_assign_type(false, m.key, key, pair.colon)
            self.s.check_assign_type(false, m.val, val, pair.colon)

            model.entries = append(model.entries, &KeyValPairExprModel{
                key: key.model,
                val: val.model,
            })
        }

        ret &Data{
            mutable:    true,
            kind:       &TypeKind{kind: m},
            model:      model,
        }
    }

    fn eval_brace_lit(mut &self, mut lit: &BraceLit): &Data {
        match {
        | self.prefix == nil:
            self.push_err(lit.token, LogMsg.InvalidSyntax)
            ret nil
        | self.prefix.map() != nil:
            ret self.eval_map(self.prefix.map(), lit)
        | self.prefix.strct() != nil:
            ret self.eval_struct_lit_explicit(self.prefix.strct(), lit.exprs, lit.token)
        |:
            self.push_err(lit.token, LogMsg.InvalidSyntax)
            ret nil
        }
    }

    fn eval_anon_fn(mut self, mut decl: &FnDecl): &Data {
        let mut tc = TypeChecker{
            s:      self.s,
            lookup: self.lookup,
        }
        let mut ins = tc.build_fn(decl)
        ins.anon = true

        match type self.lookup {
        | &ScopeChecker:
            let mut sc = (&ScopeChecker)(self.lookup)
            let mut scc = sc.new_child_checker()
            scc.labels = new([]&ScopeLabel, nil)
            scc.gotos = new([]&ScopeGoto, nil)
            scc.owner = nil
            scc.child_index = 0
            scc.it = 0
            scc.cse = 0
            scc.owner = ins
            self.s.check_fn_ins_sc(ins, scc)

        |:
            self.s.check_fn_ins(ins)
        }

        ret &Data{
            kind: &TypeKind{kind: ins},
            model: &AnonFnExprModel{
                func:   ins,
                global: self.is_global(),
            },
        }
    }

    fn eval_binop(mut &self, mut op: &BinopExpr): &Data {
        let mut bs = BinaryEval.new_plain(self)

        // Apply prefix for just numericals.
        if self.prefix != nil {
            let prim = self.prefix.prim()
            if prim == nil || !types::is_num(prim.to_str()) {
                let mut prefix = self.prefix
                self.prefix = nil
                defer { self.prefix = prefix }
                ret bs.eval(op)
            }
        }

        ret bs.eval(op)
    }

    fn eval_ternary(mut &self, mut ter: &TernaryExpr): &Data {
        let mut d = self.eval_expr_kind(ter.condition)
        if d == nil {
            ret nil
        }

        let prim = d.kind.prim()
        if prim == nil || !prim.is_bool() {
            self.push_err(ter.token, LogMsg.IfRequireBoolExpr)
            ret nil
        }

        let mut td = self.eval_expr_kind(ter.true_expr)
        if td == nil {
            ret nil
        }
        self.apply_numeric_prefix(td)

        if td.kind.void() {
            self.push_err(ter.token, LogMsg.VoidUsedForTernary)
            ret nil
        }

        let mut prefix = self.prefix
        self.prefix = td.kind

        let mut fd = self.eval_expr_kind(ter.false_expr)
        self.apply_numeric_prefix(fd)

        self.prefix = prefix
        if fd == nil {
            ret nil
        }

        let mut ac = AssignTypeChecker{
            s:           self.s,
            error_token: ter.token,
        }
        if td.is_const() && !fd.is_const() {
            ac.dest = fd.kind
            ac.d = td
        } else {
            ac.dest = td.kind
            ac.d = fd
        }
        if !ac.check() {
            self.push_suggestion(LogMsg.UseCompatibleValuesForTernary)
        }

        if d.is_const() {
            if d.constant.read_bool() {
                ret td
            }
            ret fd
        }

        let mut r = &Data{}
        r.kind = ac.dest
        r.lvalue = false
        r.mutable = r.kind.mutable()
        r.model = &TernaryExprModel{
            condition:  d.model,
            true_expr:  td.model,
            false_expr: fd.model,
        }
        ret r
    }

    fn eval_expr_kind(mut &self, mut kind: ExprData): &Data {
        let mut d: &Data = nil
        match type kind {
        | &LitExpr:
            d = self.eval_lit((&LitExpr)(kind))
        | &IdentExpr:
            d = self.eval_ident((&IdentExpr)(kind))
        | &UnaryExpr:
            d = self.eval_unary((&UnaryExpr)(kind))
        | &VariadicExpr:
            d = self.eval_variadic((&VariadicExpr)(kind))
        | &UnsafeExpr:
            d = self.eval_unsafe((&UnsafeExpr)(kind))
        | &SliceExpr:
            d = self.eval_slice_expr((&SliceExpr)(kind))
        | &IndexingExpr:
            d = self.eval_indexing((&IndexingExpr)(kind))
        | &SlicingExpr:
            d = self.eval_slicing((&SlicingExpr)(kind))
        | &CastExpr:
            d = self.eval_cast((&CastExpr)(kind))
        | &NsSelectionExpr:
            d = self.eval_ns_selection((&NsSelectionExpr)(kind))
        | &StructLit:
            d = self.eval_struct_lit((&StructLit)(kind))
        | &TypeDecl:
            d = self.eval_type((&TypeDecl)(kind))
        | &FnCallExpr:
            d = self.eval_fn_call((&FnCallExpr)(kind))
        | &SubIdentExpr:
            d = self.eval_sub_ident((&SubIdentExpr)(kind))
        | &TupleExpr:
            d = self.eval_tuple((&TupleExpr)(kind))
        | &BraceLit:
            d = self.eval_brace_lit((&BraceLit)(kind))
        | &FnDecl:
            d = self.eval_anon_fn((&FnDecl)(kind))
        | &BinopExpr:
            d = self.eval_binop((&BinopExpr)(kind))
        | &TernaryExpr:
            d = self.eval_ternary((&TernaryExpr)(kind))
        }

        if d == nil {
            ret nil
        }
        if d.kind == nil {
            ret d
        }

        if !d.decl && self.prefix != nil {
            if !d.kind.cpp_linked() &&
                d.cast_kind == nil &&
                !d.kind.variadic &&
                !d.lvalue &&
                !d.is_const() &&
                d.kind.prim() != nil &&
                types::is_num(d.kind.prim().kind) {
                d.cast_kind = d.kind
            }

            apply_cast_kind(d)

            if d.kind.prim() == nil || !d.kind.prim().is_any() {
                if self.prefix.prim() != nil && self.prefix.prim().is_any() {
                    d.cast_kind = self.prefix
                    apply_cast_kind_model(d)
                    d.cast_kind = nil
                }
            }
        }

        ret d
    }

    // Returns value data of evaluated expression.
    // Returns nil if error occurs.
    fn eval(mut &self, mut expr: &Expr): &Data {
        let mut d = self.eval_expr_kind(expr.kind)
        if d == nil || d.kind == nil {
            ret nil
        }

        match {
        | d.kind.fnc() != nil:
            let mut f = d.kind.fnc()
            if f.is_builtin() {
                break
            }
            if f.generics.len != f.decl.generics.len {
                self.s.push_err(expr.token, LogMsg.HasGenerics)
            }
            if f.decl.is_method() {
                self.s.push_err(expr.token, LogMsg.MethodNotInvoked)
            }
        }

        ret d
    }

    // Returns value data of evaluated expression.
    // Returns nil if error occurs.
    // Accepts decls as invalid expression.
    fn eval_expr(mut &self, mut expr: &Expr): &Data {
        let mut d = self.eval(expr)
        match {
        | d == nil:
            ret nil
        | d.decl:
            self.push_err(expr.token, LogMsg.InvalidExpr)
            ret nil
        |:
            ret d
        }
    }
}

struct UnaryEval {
    e: &Eval
    d: &Data
    u: &UnaryExpr
}

impl UnaryEval {
    static fn new(mut e: &Eval): UnaryEval {
        ret UnaryEval{
            e: e,
        }
    }

    fn eval_minus(mut self) {
        let t = self.d.kind.prim()
        if t == nil || !types::is_num(t.to_str()) {
            self.d = nil
            ret
        }

        if self.d.is_const() {
            match {
            | self.d.constant.is_f64():
                self.d.constant.set_f64(-self.d.constant.read_f64())
            | self.d.constant.is_i64():
                self.d.constant.set_f64(-self.d.constant.as_f64())
            | self.d.constant.is_u64():
                self.d.constant.set_f64(-self.d.constant.as_f64())
            }
        }

        self.d.lvalue = false
        self.d.model = &UnaryExprModel{
            expr: new(Data, *self.d),
            op:   self.u.op,
        }
    }

    fn eval_plus(mut self) {
        let t = self.d.kind.prim()
        if t == nil || !types::is_num(t.to_str()) {
            self.d = nil
            ret
        }

        if self.d.is_const() {
            match {
            | self.d.constant.is_f64():
                self.d.constant.set_f64(+self.d.constant.read_f64())
            | self.d.constant.is_i64():
                self.d.constant.set_f64(+self.d.constant.as_f64())
            | self.d.constant.is_u64():
                self.d.constant.set_f64(+self.d.constant.as_f64())
            }
        }

        self.d.lvalue = false
        self.d.model = &UnaryExprModel{
            expr: new(Data, *self.d),
            op:   self.u.op,
        }
    }

    fn eval_caret(mut self) {
        let t = self.d.kind.prim()
        if t == nil || !types::is_int(t.to_str()) {
            self.d = nil
            ret
        }

        if self.d.is_const() {
            match {
            | self.d.constant.is_i64():
                self.d.constant.set_i64(^self.d.constant.read_i64())
            | self.d.constant.is_u64():
                self.d.constant.set_u64(^self.d.constant.read_u64())
            }
        }

        self.d.lvalue = false
        self.d.model = &UnaryExprModel{
            expr: new(Data, *self.d),
            op:   self.u.op,
        }
    }

    fn eval_excl(mut self) {
        let t = self.d.kind.prim()
        if t == nil || !t.is_bool() {
            self.d = nil
            ret
        }

        if self.d.is_const() {
            match {
            | self.d.constant.is_bool():
                self.d.constant.set_bool(!self.d.constant.read_bool())
            }
        }

        self.d.lvalue = false
        self.d.model = &UnaryExprModel{
            expr: new(Data, *self.d),
            op:   self.u.op,
        }
    }

    fn eval_star(mut self) {
        self.d.model = &UnaryExprModel{
            expr: new(Data, *self.d),
            op:   self.u.op,
        }

        match {
        | self.d.kind.ptr() != nil:
            if !self.e.is_unsafe() {
                self.e.push_err(self.u.op, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            }

            let mut t = self.d.kind.ptr()
            if t.is_unsafe() {
                self.d = nil
                ret
            }
            self.d.kind = t.elem

        | self.d.kind.sptr() != nil:
            self.d.kind = self.d.kind.sptr().elem

        |:
            self.d = nil
            ret
        }

        self.d.constant = nil
        self.d.lvalue = true
    }

    fn eval_amper(mut self) {
        match type self.d.model {
        | &StructLitExprModel:
            let mut lit = (&StructLitExprModel)(self.d.model)
            make_struct_lit_alloc(self.d, lit)

        |:
            match {
            | can_get_ptr(self.d):
                self.d.kind = &TypeKind{
                    kind: &Ptr{elem: self.d.kind},
                }
                self.d.model = &UnaryExprModel{
                    expr: new(Data, *self.d),
                    op:   self.u.op,
                }

            |:
                self.d = nil
            }
        }

        if self.d != nil {
            self.d.constant = nil
            self.d.lvalue = false
            self.d.mutable = true
        }
    }

    fn eval_type_decl(mut self) {
        let mut tc = TypeChecker{
            s:           self.e.s,
            lookup:      self.e.lookup,
            error_token: self.u.op,
        }
        match self.u.op.kind {
        | TokenKind.Star:
            self.d.kind = &TypeKind{kind: tc.build_ptr_from_type(self.d.kind)}
        | TokenKind.Amper:
            self.d.kind = &TypeKind{kind: tc.build_sptr_from_type(self.d.kind)}
        |:
            self.e.push_err(self.u.op, LogMsg.InvalidExprForUnary, self.u.op.kind, self.d.kind.to_str())
            self.d = nil
            ret
        }
        self.d.decl = true
    }

    fn eval_data(mut self) {
        match self.u.op.kind {
        | TokenKind.Amper:
            let mut prefix = self.e.prefix
            self.e.prefix = nil
            self.d = self.e.eval_expr_kind(self.u.expr)
            self.e.prefix = prefix
        |:
            self.d = self.e.eval_expr_kind(self.u.expr)
        }
    }

    fn eval(mut self, mut u: &UnaryExpr): &Data {
        self.u = u
        self.eval_data()
        if self.d == nil {
            ret nil
        }
        if self.d.decl {
            self.eval_type_decl()
            ret self.d
        }

        let mut cast_kind = self.d.cast_kind
        let kind = self.d.kind
        match self.u.op.kind {
        | TokenKind.Minus: self.eval_minus()
        | TokenKind.Plus:  self.eval_plus()
        | TokenKind.Caret: self.eval_caret()
        | TokenKind.Excl:  self.eval_excl()
        | TokenKind.Star:  self.eval_star()
        | TokenKind.Amper: self.eval_amper()
        |:                 self.d = nil
        }

        match {
        | self.d == nil:
            self.e.push_err(self.u.op, LogMsg.InvalidExprForUnary, self.u.op.kind, kind.to_str())
        | self.d.is_const():
            self.d.model = self.d.constant
        | cast_kind != nil:
            self.d.cast_kind = cast_kind
            apply_cast_kind(self.d)
        }

        ret self.d
    }
}

struct BinaryEval {
    e:  &Eval
    l:  &Data
    r:  &Data
    op: Token
}

impl BinaryEval {
    static fn new_plain(mut e: &Eval): BinaryEval {
        ret BinaryEval{
            e:  e,
        }
    }

    static fn new(mut e: &Eval, mut op: Token): BinaryEval {
        ret BinaryEval{
            e:  e,
            op: op,
        }
    }

    // Reports whether types are compatible.
    // Also logs error message about incompatibility if types are incompatible.
    fn check_type_compatibility(mut self): bool {
        ret self.e.s.check_type_compatibility(self.l.kind, self.r.kind, self.op)
    }

    fn eval_nil(mut self): &Data {
        if !self.r.kind.nil_compatible() {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, TokenKind.Nil, self.r.kind.to_str())
            ret nil
        }

        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, TokenKind.Nil)
            ret nil
        }
    }

    fn eval_enum(mut self): &Data {
        let mut enm = self.l.kind.enm()
        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            let mut rkind = self.r.kind
            if self.r.kind.enm() != nil {
                rkind = self.r.kind.enm().kind.kind
            }
            if !self.e.s.check_type_compatibility(enm.kind.kind, rkind, self.op) {
                ret nil
            }
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        }

        if self.r.kind.enm() == nil || enm != self.r.kind.enm() {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, enm.ident, self.r.kind.to_str())
            ret nil
        }

        match self.op.kind {
        | TokenKind.Gt
        | TokenKind.Lt
        | TokenKind.GreatEq
        | TokenKind.LessEq:
            if !types::is_num(enm.kind.kind.to_str()) {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, enm.ident)
                ret nil
            }
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        | TokenKind.Amper
        | TokenKind.Vline
        | TokenKind.Caret:
            if enm.kind.kind.prim() == nil || !types::is_int(enm.kind.kind.prim().to_str()) {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, enm.ident)
            }
            ret self.l
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, enm.ident)
            ret nil
        }
    }

    fn eval_sptr(mut self): &Data {
        if !self.check_type_compatibility() {
            ret nil
        }

        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret nil
        }
    }

    fn eval_ptr(mut self): &Data {
        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq
        | TokenKind.Lt
        | TokenKind.Gt
        | TokenKind.LessEq
        | TokenKind.GreatEq:
            if !self.check_type_compatibility() {
                ret nil
            }
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        | TokenKind.Plus
        | TokenKind.Minus:
            if self.l.kind.ptr() == nil {
                self.l, self.r = self.r, self.l
            }
            if self.l.kind.ptr().is_unsafe() {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            }
            if !is_ptr_arithmetic_compatible_int(self.r) {
                self.e.push_err(self.op, LogMsg.IncompatibleTypeForPtrArithmetic, self.r.kind.to_str())
                ret nil
            }
            ret self.l
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret nil
        }
    }

    fn eval_arr(mut self): &Data {
        if !self.check_type_compatibility() {
            ret nil
        }

        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret nil
        }
    }

    fn eval_slc(mut self): &Data {
        if !self.check_type_compatibility() {
            ret nil
        }

        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret nil
        }
    }

    fn eval_fn(mut self): &Data {
        if !self.check_type_compatibility() {
            ret nil
        }

        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret nil
        }
    }

    fn eval_struct(mut self): &Data {
        if !self.check_type_compatibility() {
            ret nil
        }

        match self.op.kind {
        | TokenKind.Gt:
            if self.l.kind.strct().operators.gt == nil {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
                ret nil
            }
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        | TokenKind.GreatEq:
            if self.l.kind.strct().operators.gt_eq == nil {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
                ret nil
            }
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        | TokenKind.Lt:
            if self.l.kind.strct().operators.lt == nil {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
                ret nil
            }
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        | TokenKind.LessEq:
            if self.l.kind.strct().operators.lt_eq == nil {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
                ret nil
            }
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        | TokenKind.Lshift:
            if self.l.kind.strct().operators.shl == nil {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
                ret nil
            }
            ret self.l
        | TokenKind.Rshift:
            if self.l.kind.strct().operators.shr == nil {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
                ret nil
            }
            ret self.l
        | TokenKind.Plus:
            if self.l.kind.strct().operators.add == nil {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
                ret nil
            }
            ret self.l
        | TokenKind.Minus:
            if self.l.kind.strct().operators.sub == nil {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
                ret nil
            }
            ret self.l
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret nil
        }
    }

    fn eval_trait(mut self): &Data {
        if !self.check_type_compatibility() {
            ret nil
        }

        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret nil
        }
    }

    fn eval_any(mut self): &Data {
        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq:
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, PrimKind.Any)
            ret nil
        }
    }

    fn eval_bool(mut self): &Data {
        if !self.check_type_compatibility() {
            ret nil
        }

        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq
        | TokenKind.DblAmper
        | TokenKind.DblVline:
            ret self.l
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret nil
        }
    }

    fn eval_str(mut self): &Data {
        let mut rk = self.r.kind.to_str()
        if rk != PrimKind.Str {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, PrimKind.Str, rk)
            ret nil
        }

        match self.op.kind {
        | TokenKind.Plus:
            ret self.l
        | TokenKind.Eqs
        | TokenKind.NotEq
        | TokenKind.Lt
        | TokenKind.Gt
        | TokenKind.GreatEq
        | TokenKind.LessEq:
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, PrimKind.Str)
            ret nil
        }
    }

    fn set_type_to_greater(mut self) {
        if self.l.is_const() {
            if !self.r.is_const() {
                self.l.kind = self.r.kind
                ret
            }
            goto set
        }
        if self.r.is_const() {
            ret
        }
    set:
        if types::is_greater(self.r.kind.prim().kind, self.l.kind.prim().kind) {
            self.l.kind = self.r.kind
        }
    }

    fn check_mod_data(mut self, mut &d: &Data) {
        if !d.is_const() {
            if d.kind.prim() == nil || !types::is_int(d.kind.prim().kind) {
                self.e.push_err(self.op, LogMsg.ModuloWithNotInt)
            }
            ret
        }
        match {
        | sig_assignable(PrimKind.I64, d):
            d.constant.set_i64(d.constant.as_i64())
        | unsig_assignable(PrimKind.U64, d):
            d.constant.set_u64(d.constant.as_u64())
        |:
            self.e.push_err(self.op, LogMsg.ModuloWithNotInt)
        }
    }

    fn mod(mut self) {
        self.check_mod_data(self.l)
        self.check_mod_data(self.r)
    }

    fn numbers_are_compatibile(self, &lk: str, &rk: str): bool {
        if !types::is_num(rk) {
            ret false
        }

        if self.l.is_const() {
            ret true
        }

        if lk == types::TypeKind.F32 {
            if self.r.is_const() {
                ret true
            }
            ret rk == types::TypeKind.F32
        }
        if lk == types::TypeKind.F64 {
            if self.r.is_const() {
                ret true
            }
            ret rk == types::TypeKind.F64
        }

        if self.r.is_const() {
            ret true
        }

        ret lk == rk
    }

    fn eval_float(mut self): &Data {
        let lk = self.l.kind.prim().kind // Float guaranteed.
        let rk = self.r.kind.prim().kind // Primitive guaranteed.
        if !self.numbers_are_compatibile(lk, rk) {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, lk, rk)
            ret nil
        }

        match self.op.kind {
        | TokenKind.Lshift
        | TokenKind.Rshift:
            if !self.l.is_const() || !int_assignable(PrimKind.I64, self.l) {
                self.e.push_err(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            if !self.r.is_const() || !int_assignable(PrimKind.U64, self.r) {
                self.e.push_err(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            self.l.constant.set_i64(self.l.constant.as_i64())
            self.r.constant.set_u64(self.r.constant.as_u64())
            if !is_ok_for_shifting(self.r) {
                self.e.push_err(self.op, LogMsg.BitShiftMustUnsigned)
                ret nil
            }
            ret self.l
        }

        // Logicals.
        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq
        | TokenKind.Lt
        | TokenKind.Gt
        | TokenKind.GreatEq
        | TokenKind.LessEq:
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        }

        // Arithmetics.
        match self.op.kind {
        | TokenKind.Plus
        | TokenKind.Minus
        | TokenKind.Star
        | TokenKind.Solidus:
            self.set_type_to_greater()
            ret self.l
        | TokenKind.Percent:
            if !types::is_int(rk) {
                self.e.push_err(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            self.mod()
            ret self.r
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForFloat, self.op.kind)
            ret nil
        }
    }

    fn eval_int(mut self): &Data {
        let lk = self.l.kind.prim().kind // Integer guaranteed.
        let rk = self.r.kind.prim().kind // Primitive guaranteed.

        match self.op.kind {
        | TokenKind.Lshift
        | TokenKind.Rshift:
            if !types::is_int(lk) || !types::is_int(rk) {
                self.e.push_err(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            if !is_ok_for_shifting(self.r) {
                self.e.push_err(self.op, LogMsg.BitShiftMustUnsigned)
                ret nil
            }
            ret self.l
        }

        if !self.numbers_are_compatibile(lk, rk) {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, lk, rk)
            ret nil
        }

        // Logicals.
        match self.op.kind {
        | TokenKind.Eqs
        | TokenKind.NotEq
        | TokenKind.Lt
        | TokenKind.Gt
        | TokenKind.GreatEq
        | TokenKind.LessEq:
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(PrimKind.Bool),
                },
            }
        }

        // Arithmetics.
        match self.op.kind {
        | TokenKind.Plus
        | TokenKind.Minus
        | TokenKind.Star
        | TokenKind.Solidus
        | TokenKind.Amper
        | TokenKind.Vline
        | TokenKind.Caret:
            self.set_type_to_greater()
            ret self.l
        | TokenKind.Percent:
            self.mod()
            self.set_type_to_greater()
            ret self.l
        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForInt, self.op.kind)
            ret nil
        }
    }

    fn eval_prim(mut self): &Data {
        let prim = self.l.kind.prim()
        match {
        | prim.is_bool():
            ret self.eval_bool()
        | prim.is_str():
            ret self.eval_str()
        }

        if self.r.kind.prim() == nil {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, prim.to_str(), self.r.kind.to_str())
            ret nil
        }

        match {
        | types::is_float(prim.kind):
            ret self.eval_float()
        | types::is_int(prim.kind):
            ret self.eval_int()
        |:
            ret nil
        }
    }

    fn eval_op(mut self): &Data {
        match {
        | self.l.kind.void():
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, "void")
            ret nil
        | self.r.kind.prim() != nil && self.r.kind.prim().is_any():
            self.l, self.r = self.r, self.l
            fall
        | self.l.kind.prim() != nil && self.l.kind.prim().is_any():
            ret self.eval_any()
        | self.l.kind.is_nil():
            ret self.eval_nil()
        | self.r.kind.enm() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.kind.enm() != nil:
            ret self.eval_enum()
        | self.r.kind.sptr() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.kind.sptr() != nil:
            ret self.eval_sptr()
        | self.r.kind.ptr() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.kind.ptr() != nil:
            ret self.eval_ptr()
        | self.l.kind.arr() != nil:
            ret self.eval_arr()
        | self.l.kind.slc() != nil:
            ret self.eval_slc()
        | self.l.kind.fnc() != nil:
            ret self.eval_fn()
        | self.r.kind.trt() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.kind.trt() != nil:
            ret self.eval_trait()
        | self.l.kind.strct() != nil:
            ret self.eval_struct()
        | self.l.kind.prim() != nil:
            ret self.eval_prim()
        |:
            ret nil
        }
    }

    fn eval_const(mut self, mut &d: &Data) {
        match {
        | d == nil:
            ret
        | !self.l.is_const()
        | !self.r.is_const():
            d.constant = nil
            ret
        }

        match self.op.kind {
        | TokenKind.Eqs:
            d.constant = Const.new_bool(self.l.constant.eqs(*self.r.constant))
        | TokenKind.NotEq:
            d.constant = Const.new_bool(!self.l.constant.eqs(*self.r.constant))
        | TokenKind.DblColon:
            d.constant = Const.new_bool(self.l.constant.or(*self.r.constant))
        | TokenKind.DblAmper:
            d.constant = Const.new_bool(self.l.constant.and(*self.r.constant))
        | TokenKind.Gt:
            d.constant = Const.new_bool(self.l.constant.gt(*self.r.constant))
        | TokenKind.Lt:
            d.constant = Const.new_bool(self.l.constant.lt(*self.r.constant))
        | TokenKind.GreatEq:
            d.constant = Const.new_bool(
                self.l.constant.gt(*self.r.constant) ||
                self.l.constant.eqs(*self.r.constant))
        | TokenKind.LessEq:
            d.constant = Const.new_bool(
                self.l.constant.lt(*self.r.constant) ||
                self.l.constant.eqs(*self.r.constant))
        | TokenKind.Plus:
            _ = self.l.constant.add(*self.r.constant)
            d.constant = self.l.constant
        | TokenKind.Minus:
            _ = self.l.constant.sub(*self.r.constant)
            d.constant = self.l.constant
        | TokenKind.Star:
            _ = self.l.constant.mul(*self.r.constant)
            d.constant = self.l.constant
        | TokenKind.Solidus:
            let ok = self.l.constant.div(*self.r.constant)
            if !ok && self.r.constant.as_f64() == 0 {
                self.e.push_err(self.op, LogMsg.DivByZero)
            }
            d.constant = self.l.constant
        | TokenKind.Percent:
            let ok = self.l.constant.mod(*self.r.constant)
            if !ok && self.r.constant.as_f64() == 0 {
                self.e.push_err(self.op, LogMsg.DivByZero)
            }
            d.constant = self.l.constant
        | TokenKind.Vline:
            _ = self.l.constant.bitwise_or(*self.r.constant)
            d.constant = self.l.constant
        | TokenKind.Amper:
            _ = self.l.constant.bitwise_and(*self.r.constant)
            d.constant = self.l.constant
        | TokenKind.Caret:
            _ = self.l.constant.xor(*self.r.constant)
            d.constant = self.l.constant
        | TokenKind.Lshift:
            _ = self.l.constant.lshift(*self.r.constant)
            d.constant = self.l.constant
        | TokenKind.Rshift:
            _ = self.l.constant.rshift(*self.r.constant)
            d.constant = self.l.constant
        }

        d.model = d.constant
        apply_cast_model_by_enum(d, d.kind.enm())
    }

    fn check_data(mut self, mut &d: &Data) {
        let f = d.kind.fnc()
        if f != nil && f.decl != nil && f.decl.is_method() {
            self.e.push_err(self.op, LogMsg.InvalidExprForBinop)
        }
    }

    fn check_datas(mut self) {
        self.check_data(self.l)
        self.check_data(self.r)
    }

    fn set_model(mut self, mut &d: &Data) {
        if d.is_const() {
            ret
        }

        let (mut l, mut r) = self.l, self.r
        if !l.good_operand(r) {
            l, r = r, l
        }

        d.model = &BinopExprModel{
            left: &OperandExprModel{
                kind: l.kind,
                model: l.model,
            },
            right: &OperandExprModel{
                kind: r.kind,
                model: r.model,
            },
            op: self.op,
        }
    }

    fn post_eval(mut self, mut &d: &Data) {
        d.lvalue = false
        self.set_model(d)

        self.e.apply_numeric_prefix(d)
    }

    fn solve_explicit(mut self, mut &l: &Data, mut &r: &Data): &Data {
        self.l, self.r = l, r

        self.check_datas()

        let mut d = self.eval_op()

        // Save normal order
        self.l, self.r = l, r

        self.eval_const(d)

        if d != nil {
            self.post_eval(d)
        }

        ret d
    }

    fn eval(mut self, mut &op: &BinopExpr): &Data {
        if op.op.kind == TokenKind.Eq {
            self.e.push_err(op.op, LogMsg.AssignInExpr)
            self.e.push_suggestion(LogMsg.UseImperative)
            ret nil
        }

        let mut l = self.e.eval_expr_kind(op.left)
        if l == nil || l.kind == nil {
            ret nil
        }

        let mut prefix = self.e.prefix
        self.e.prefix = l.kind
        defer { self.e.prefix = prefix }
        let mut r = self.e.eval_expr_kind(op.right)
        if r == nil || r.kind == nil {
            ret nil
        }

        self.op = op.op

        let mut d = self.solve_explicit(l, r)

        // Save rune type.
        if d != nil && l.is_rune && r.is_rune {
            d.is_rune = true
        }

        ret d
    }
}
