// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::conv::{ConvError, parse_float, parse_int, parse_uint}
use std::jule::ast::{
    Expr,
    LitExpr,
    IdentExpr,
    VariadicExpr,
    UnaryExpr,
    UnsafeExpr,
    SliceExpr,
    ExprData,
    FnDecl,
    BinopExpr,
    BraceLit,
    TupleExpr,
    SubIdentExpr,
    IndexingExpr,
    NsSelectionExpr,
    TypeDecl,
    FnCallExpr,
    SlicingExpr,
    CastExpr,
    StructLit,
    KeyValPair,
    IdentTypeDecl,
    TernaryExpr,
}
use std::jule::build::{LogMsg, logf}
use std::jule::constant::{Const}
use lit for std::jule::constant::lit
use std::jule::lex::{
    self,
    Token,
    TokenKind,
    is_str,
    is_bool,
    is_rune,
    is_byte,
    is_raw_str,
}
use types for std::jule::types

fn find_builtins_import(ident: str, imp: &ImportInfo): any {
    ret find_package_builtin_def(imp.link_path, ident)
}

fn make_struct_lit_alloc(mut &d: &Data, mut &lit: &StructLitExprModel) {
    d.kind = &TypeKind{
        kind: &Ref{
            elem: &TypeKind{kind: lit.strct},
        },
    }

    d.model = &AllocStructLitExprModel{
        lit: lit,
    }
}

fn find_builtins_sema(ident: str, mut s: &Sema): any {
    for (_, mut imp) in s.file.imports {
        if imp.import_all || imp.exist_ident(ident) {
            let mut def = find_builtins_import(ident, imp)
            if def != nil {
                ret def
            }
        }
    }
    ret nil
}

fn is_ok_for_shifting(mut d: &Data): bool {
    let prim = d.kind.prim()
    if !real(prim) || !types::is_int(prim.to_str()) {
        ret false
    }

    if !d.is_const() {
        ret true
    }

    match {
    | d.constant.is_i64(): ret d.constant.read_i64() >= 0
    | d.constant.is_u64(): ret true
    |:                     ret false
    }
}

fn is_instanced_struct(s: &StructIns): bool {
    ret s.decl.generics.len == s.generics.len
}

fn is_ptr_arithmetic_compatible_int(mut &d: &Data): bool {
    if d.is_const() {
        ret int_assignable(str(types::TypeKind.Int), d)
    }
    let mut tcc = TypeCompatibilityChecker{
        dest:        &TypeKind{kind: build_prim_type(str(types::TypeKind.Int))},
        src:         d.kind,
        deref:       true,
    }
    ret tcc.check()
}

fn normalize_bitsize(mut d: &Data) {
    if !d.is_const() {
        ret
    }

    let mut kind = ""
    match {
    | d.constant.is_i64():
        let x = d.constant.read_i64()
        kind = types::int_from_bits(types::bitsize_of_int(x))

    | d.constant.is_u64():
        let x = d.constant.read_u64()
        kind = types::uint_from_bits(types::bitsize_of_uint(x))

    |:
        ret
    }

    // Save enum.
    if real(d.kind.enm()) {
        ret
    }

    d.kind.kind = build_prim_type(kind)
}

fn normalize_type(mut d: &Data) {
    match {
    | int_assignable(str(PrimKind.Int), d):
        d.kind.kind = build_prim_type(str(PrimKind.Int))
        d.constant.set_i64(i64(d.constant.as_f64()))

    | int_assignable(str(PrimKind.Uint), d):
        d.kind.kind = build_prim_type(str(PrimKind.Uint))
        d.constant.set_u64(u64(d.constant.as_f64()))
    }
}

fn apply_cast_kind_model(mut d: &Data) {
    d.model = &CastingExprModel{
        expr:      d.model,
        kind:      d.cast_kind,
        expr_kind: d.kind,
    }
}

fn apply_cast_kind(mut d: &Data) {
    if !real(d.cast_kind) {
        ret
    }

    apply_cast_kind_model(d)
    d.kind = d.cast_kind
    drop(d.cast_kind) // Ignore, because model added.
}

fn build_void_data(): &Data {
    ret &Data{
        mutable:  false,
        lvalue:   false,
        decl:     false,
        kind: &TypeKind{
            kind: build_prim_type("void"),
        },
    }
}

fn kind_by_bitsize(expr: any): str {
    match type expr {
    | f64:
        let x = (f64)(expr)
        ret types::float_from_bits(types::bitsize_of_float(x))

    | i64:
        let x = (i64)(expr)
        ret types::int_from_bits(types::bitsize_of_int(x))

    | u64:
        let x = (u64)(expr)
        ret types::uint_from_bits(types::bitsize_of_uint(x))

    |:
        ret ""
    }
}

fn check_data_for_integer_indexing(mut d: &Data): (err_fmt: LogMsg) {
    if !real(d) {
        ret LogMsg.Empty
    }

    let mut kind = d.kind
    if real(kind.ref()) {
        kind = kind.ref().elem
    }

    match {
    | !real(kind.prim()):
        ret LogMsg.InvalidExpr

    | !types::is_int(kind.prim().to_str()):
        ret LogMsg.InvalidExpr

    | d.is_const():
        if d.constant.as_f64() < 0 {
            ret LogMsg.OverflowLimits
        }

    | !real(d.kind.prim())
    | d.is_const()
    | types::real_kind_of(d.kind.prim().to_str()) != types::real_kind_of(str(PrimKind.Int)):
        d.cast_kind = &TypeKind{kind: build_prim_type(str(PrimKind.Int))}
        apply_cast_kind(d)
    }
    ret LogMsg.Empty
}

// Value data.
pub struct Data {
    pub kind:       &TypeKind
    pub cast_kind:  &TypeKind // This expression should be cast to this kind.
    pub mutable:    bool
    pub reference:  bool
    pub lvalue:     bool
    pub variadiced: bool
    pub is_rune:    bool
    pub model:      ExprModel

    // True if kind is declaration such as:
    //  - &Enum
    //  - &Struct
    //  - int type
    //  - bool type
    pub decl: bool

    // Constant expression data.
    pub constant: &Const
}

impl Data {
    // Reports whether Data is nil literal.
    pub fn is_nil(self): bool { ret self.kind.is_nil() }

    // Reports whether Data is void.
    pub fn is_void(self): bool { ret self.kind.void() }

    // Reports whether Data is constant expression.
    pub fn is_const(self): bool { ret real(self.constant) }
}

// Value.
pub struct Value {
    pub expr: &Expr
    pub data: &Data
}

// Evaluator.
struct Eval {
    s:         &Sema // Used for error logging.
    lookup:    Lookup
    prefix:    &TypeKind
    unsafety:  bool
    immutable: bool // This expression will assigned to immutable memory.
    owner:     &Var
}

impl Eval {
    fn push_err(mut self, token: Token, fmt: LogMsg, args: ...any) {
        self.s.push_err(token, fmt, args...)
    }

    // Push suggestion to last log.
    fn push_suggestion(mut self, fmt: LogMsg, args: ...any) {
        self.s.push_suggestion(fmt, args...)
    }

    // Reports whether evaluation in unsafe scope.
    fn is_unsafe(self): bool { ret self.unsafety }

    // Reports whether evaluated expression is in global scope.
    fn is_global(self): bool {
        match type self.lookup {
        | &Sema: ret true
        |:       ret false
        }
    }

    fn lit_nil(self): &Data {
        // Return new Data with nil kind.
        // Nil kind represents "nil" literal.

        let mut constant = Const.new_nil()
        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: constant,
            decl:     false,
            kind:     &TypeKind{kind: nil},
            model:    constant,
        }
    }

    fn lit_str(self, lt: &LitExpr): &Data {
        let mut s = lt.value[1 : lt.value.len-1] // Remove quotes.
        if is_raw_str(lt.value) {
            s = lit::to_raw_str(([]byte)(s))
        } else {
            s = lit::to_str(([]byte)(s))
        }
        let mut constant = Const.new_str(s)

        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: constant,
            decl:     false,
            kind: &TypeKind{
                kind: build_prim_type(str(PrimKind.Str)),
            },
            model: constant,
        }
    }

    fn lit_bool(self, lit: &LitExpr): &Data {
        let mut constant = Const.new_bool(lit.value == str(TokenKind.True))
        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: constant,
            decl:     false,
            kind: &TypeKind{
                kind: build_prim_type(str(PrimKind.Bool)),
            },
            model: constant,
        }
    }

    fn lit_rune(self, l: &LitExpr): &Data {
        const BYTE_KIND = str(PrimKind.U8)
        const RUNE_KIND = str(PrimKind.I32)

        let lt = l.value[1 : l.value.len-1] // Remove quotes.
        let r = lit::to_rune(([]byte)(lt))
        let mut data = &Data{
            lvalue:   false,
            mutable:  false,
            constant: Const.new_i64(i64(r)),
            decl:     false,
        }

        let is_ascii = lit::is_ascii(r)
        if is_ascii {
            data.kind = &TypeKind{
                kind: build_prim_type(BYTE_KIND),
            }
        } else {
            data.kind = &TypeKind{
                kind: build_prim_type(RUNE_KIND),
            }
        }

        data.model = &RuneExprModel{code: r}
        data.is_rune = true
        ret data
    }

    fn lit_float(self, l: &LitExpr): &Data {
        const FLOAT_KIND = str(PrimKind.F64)

        let (f, _) = parse_float(l.value, 64)
        let mut constant = Const.new_f64(f)

        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: constant,
            decl:     false,
            kind: &TypeKind{
                kind: build_prim_type(FLOAT_KIND),
            },
            model: constant,
        }
    }

    fn lit_int(mut self, l: &LitExpr): &Data {
        const BIT_SIZE = 0b01000000

        let mut lit = l.value
        let mut base = 0

        match {
        | lit.has_prefix("0x"): // Hexadecimal
            lit = lit[2:]
            base = 0b00010000

        | lit.has_prefix("0b"): // Binary
            lit = lit[2:]
            base = 0b10

        | lit.has_prefix("0o"): // Ocatal
            lit = lit[2:]
            base = 0b1000

        | lit[0] == '0' && lit.len > 1: // Octal
            lit = lit[1:]
            base = 0b1000

        |: // Decimal
            base = 0b1010
        }

        let mut d = &Data{
            lvalue:  false,
            mutable: false,
            decl:    false,
        }

        let mut value: any = nil
        let (sig, err) = parse_int(lit, base, BIT_SIZE)
        if err == ConvError.Ok {
            value = sig
            d.constant = Const.new_i64(sig)
        } else {
            let (unsig, err) = parse_uint(lit, base, BIT_SIZE)
            if err != ConvError.Ok {
                self.push_err(l.token, LogMsg.InvalidNumericRange)
                self.push_suggestion(LogMsg.TryFloatingPoint)
            }
            d.constant = Const.new_u64(unsig)
            value = unsig
        }

        d.kind = &TypeKind{
            kind: build_prim_type(kind_by_bitsize(value)),
        }

        normalize_bitsize(d)
        d.model = d.constant

        ret d
    }

    fn lit_num(mut self, l: &LitExpr): &Data {
        match {
        | std::jule::lex::is_float(l.value): ret self.lit_float(l)
        |:                                   ret self.lit_int(l)
        }
    }

    fn eval_lit(mut self, lit: &LitExpr): &Data {
        match {
        | lit.is_nil():                      ret self.lit_nil()
        | is_str(lit.value):                 ret self.lit_str(lit)
        | is_bool(lit.value):                ret self.lit_bool(lit)
        | is_rune(lit.value):                ret self.lit_rune(lit)
        | std::jule::lex::is_num(lit.value): ret self.lit_num(lit)
        |:                                   ret new(Data)
        }
    }

    fn find_builtins(mut self, ident: str): any {
        match type self.lookup {
        | &ImportInfo:
            let mut def = find_builtins_import(ident, (&ImportInfo)(self.lookup))
            if def != nil {
                ret def
            }

        | &Sema:
            let mut def = find_builtins_sema(ident, (&Sema)(self.lookup))
            if def != nil {
                ret def
            }

        | &ScopeChecker:
            let mut def = find_builtins_sema(ident, (&ScopeChecker)(self.lookup).s)
            if def != nil {
                ret def
            }
        }

        ret find_builtin_def(ident)
    }

    fn get_def(mut self, ident: str, cpp_linked: bool): any {
        if !cpp_linked {
            let mut enm = self.lookup.find_enum(ident)
            if real(enm) {
                ret enm
            }
        }

        let mut v = self.lookup.find_var(ident, cpp_linked)
        if real(v) {
            ret v
        }

        let mut f = self.lookup.find_fn(ident, cpp_linked)
        if real(f) {
            ret f
        }

        let mut s = self.lookup.find_struct(ident, cpp_linked)
        if real(s) {
            ret s
        }

        let mut ta = self.lookup.find_type_alias(ident, cpp_linked)
        if real(ta) {
            ret ta
        }

        ret self.find_builtins(ident)
    }

    fn push_reference(mut self, mut references: &ReferenceStack) {
        match type self.lookup {
        | &ScopeChecker:
            let mut sc = (&ScopeChecker)(self.lookup).get_root()
            if !references.exist[FnIns](sc.owner) {
                references.push(sc.owner)
            }

        |:
            if real(self.owner) && !references.exist[Var](self.owner) {
                references.push(self.owner)
            }
        }
    }

    fn push_reference_to_fn(mut self, mut f: &FnIns) {
        match type self.lookup {
        | &ScopeChecker:
            let mut sc = (&ScopeChecker)(self.lookup).get_root()
            if sc.owner.decl.is_init() && !sc.owner.references.exist[FnIns](f) {
                sc.owner.refers.push(f)
            }
        }
        self.push_reference(f.references)
    }

    fn push_reference_to_var(mut self, mut v: &Var) {
        if !real(v.references) {
            ret
        }

        match type self.lookup {
        | &ScopeChecker:
            let mut sc = (&ScopeChecker)(self.lookup).get_root()
            if sc.owner.decl.is_init() && !sc.owner.references.exist[Var](v) {
                sc.owner.refers.push(v)
            }
        }

        self.push_reference(v.references)
    }

    fn push_reference_to_struct(mut self, mut s: &StructIns) {
        match type self.lookup {
        | &ScopeChecker:
            let mut sc = (&ScopeChecker)(self.lookup).get_root()
            if sc.owner.decl.is_init() && !sc.owner.references.exist[StructIns](s) {
                sc.owner.refers.push(s)
            }
        }
        self.push_reference(s.references)
    }

    fn __eval_enum(self, mut enm: &Enum): &Data {
        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: new(Const),
            decl:     true,
            kind: &TypeKind{
                kind: enm,
            },
        }
    }

    fn eval_enum(mut self, mut enm: &Enum, error_token: Token): &Data {
        if !self.s.is_accessible_define(enm.public, enm.token) {
            self.push_err(error_token, LogMsg.IdentIsNotAccessible, enm.ident)
            self.push_suggestion(LogMsg.MakePubToAccess)
            ret new(Data)
        }

        ret self.__eval_enum(enm)
    }

    fn __eval_struct(self, mut s: &StructIns): &Data {
        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: new(Const),
            decl:     true,
            kind: &TypeKind{
                kind: s,
            },
            model: s,
        }
    }

    fn eval_struct(mut self, mut s: &StructIns, error_token: Token): &Data {
        if !self.s.is_accessible_define(s.decl.public, s.decl.token) {
            self.push_err(error_token, LogMsg.IdentIsNotAccessible, s.decl.ident)
            self.push_suggestion(LogMsg.MakePubToAccess)
            ret new(Data)
        }

        ret self.__eval_struct(s)
    }

    fn eval_fn_ins(self, mut f: &FnIns): &Data {
        ret &Data{
            lvalue:   false,
            mutable:  false,
            constant: new(Const),
            decl:     false,
            kind: &TypeKind{
                kind: f,
            },
            model: f,
        }
    }

    fn eval_fn(mut self, mut f: &Fn, error_token: Token): &Data {
        if !self.s.is_accessible_define(f.public, f.token) {
            self.push_err(error_token, LogMsg.IdentIsNotAccessible, f.ident)
            self.push_suggestion(LogMsg.MakePubToAccess)
            ret new(Data)
        }

        let mut ins = f.instance()
        self.push_reference_to_fn(ins)
        ret self.eval_fn_ins(ins)
    }

    fn push_illegal_cycle_error(mut self, v1: &Var, v2: &Var, mut &message: str) {
        const PADDING = 4

        let refers_to = logf(LogMsg.RefersTo, v1.ident, v2.ident)
        message = str_repeat(" ", PADDING) + refers_to + "\n" + message
    }

    fn check_cross_cycle(mut self, v: &Var, mut &message: str): bool {
        for _, d in v.depends {
            if &d == &self.owner {
                self.push_illegal_cycle_error(v, d, message)
                ret false
            }

            if !self.check_cross_cycle(d, message) {
                self.push_illegal_cycle_error(v, d, message)
                ret false
            }
        }

        ret true
    }

    // Checks owner illegal cycles.
    // Appends depend to depends if there is no illegal cycle.
    // Returns true if e.owner is nil.
    fn check_illegal_cycles(mut self, mut v: &Var, decl_token: Token): (ok: bool) {
        if !real(self.owner) {
            ret true
        }

        // Check illegal cycle for itself.
        // Because refers's owner is ta.
        if &self.owner == &v {
            self.push_err(self.owner.token, LogMsg.IllegalCycleRefersItself, self.owner.ident)
            ret false
        }

        let mut message = ""

        if !self.check_cross_cycle(v, message) {
            let mut err_msg = message
            message = ""
            self.push_illegal_cycle_error(self.owner, v, message)
            err_msg = err_msg + message
            self.push_err(decl_token, LogMsg.IllegalCrossCycle, err_msg)
            ret false
        }

        self.owner.depends = append(self.owner.depends, v)
        ret true
    }

    fn eval_var(mut self, mut v: &Var, error_token: Token): &Data {
        if !self.s.is_accessible_define(v.public, v.token) {
            self.push_err(error_token, LogMsg.IdentIsNotAccessible, v.ident)
            self.push_suggestion(LogMsg.MakePubToAccess)
            ret new(Data)
        }

        v.used = true

        match type self.lookup {
        | &Sema:
            // Check cycles for global scope.
            let ok = self.check_illegal_cycles(v, error_token)
            if !ok {
                ret new(Data)
            }

        | &ScopeChecker:
            if !v.reference || self.is_unsafe() {
                break
            }

            let mut s = (&ScopeChecker)(self.lookup)
            for !real(s.owner) && real(s.parent) {
                s = s.parent
            }
            if real(s.owner) && s.owner.anon && &v.scope != &s.owner.scope {
                self.push_err(error_token, LogMsg.UsedRefInAnonFnFromParentScope, v.ident)
            }
        }

        self.push_reference_to_var(v)

        if !v.cpp_linked && (!real(v.value) || !real(v.value.data)) {
            if v.constant {
                // Eval constant dependent variable.
                self.s.check_type_var(v, self.s)
                if !real(v.value.data) {
                    // Skip error.
                    ret new(Data)
                }
            }
        }

        if !real(v.kind) || !real(v.kind.kind) {
            ret new(Data)
        }

        let mut d = &Data{
            lvalue:    !v.constant,
            mutable:   v.mutable,
            reference: v.reference,
            decl:      false,
            kind:      v.kind.kind.clone(),
            model:     v,
        }

        if !v.cpp_linked && v.is_initialized() && real(v.value.data) {
            d.is_rune = v.value.data.is_rune
        }

        if v.constant && real(v.value.data.constant) {
            d.constant = new(Const, v.value.data.constant)
            d.model = d.constant
        }

        if real(d.kind.fnc()) {
            let mut f = d.kind.fnc()
            if real(f.decl) {
                // Ignore identifier for non-anonymous
                // (because has an identifier via variable).
                f.decl.ident = v.ident
            }
        }

        ret d
    }

    fn eval_type_alias(mut self, mut ta: &TypeAlias, error_token: Token): &Data {
        if !self.s.is_accessible_define(ta.public, ta.token) {
            self.push_err(error_token, LogMsg.IdentIsNotAccessible, ta.ident)
            self.push_suggestion(LogMsg.MakePubToAccess)
            ret new(Data)
        }

        ta.used = true

        let mut kind = ta.kind.kind.kind
        match type kind {
        | &StructIns:
            ret self.__eval_struct((&StructIns)(kind))

        | &Enum:
            ret self.__eval_enum((&Enum)(kind))

        |:
            let mut d = &Data{
                decl: true,
                kind: ta.kind.kind.clone(),
            }

            d.kind.generic = ta.generic

            // Save C identifier of type.
            if ta.cpp_linked {
                d.kind.cpp_ident = ta.ident
            }

            d.model = d.kind
            ret d
        }
    }

    fn eval_def(mut self, mut def: any, ident: Token): &Data {
        match type def {
        | &Var:
            ret self.eval_var((&Var)(def), ident)

        | &Enum:
            ret self.eval_enum((&Enum)(def), ident)

        | &Struct:
            ret self.eval_struct((&Struct)(def).instance(), ident)

        | &Fn:
            ret self.eval_fn((&Fn)(def), ident)

        | &FnIns:
            ret self.eval_fn_ins((&FnIns)(def))

        | &TypeAlias:
            ret self.eval_type_alias((&TypeAlias)(def), ident)

        |:
            self.push_err(ident, LogMsg.IdentNotExist, ident.kind)
            ret new(Data)
        }
    }

    fn eval_ident(mut self, ident: &IdentExpr): &Data {
        let mut def = self.get_def(ident.ident, ident.cpp_linked)
        ret self.eval_def(def, ident.token)
    }

    fn eval_unary_minus(self, mut d: &Data): &Data {
        if real(d.kind.ref()) {
            let mut ref = d.kind.ref()
            let prim = ref.elem.prim()
            if !real(prim) || !types::is_num(prim.to_str()) {
                ret new(Data)
            }
            d.kind = ref.elem
        } else {
            let t = d.kind.prim()
            if !real(t) || !types::is_num(t.to_str()) {
                ret new(Data)
            }
        }

        if d.is_const() {
            match {
            | d.constant.is_f64(): d.constant.set_f64(-d.constant.read_f64())
            | d.constant.is_i64(): d.constant.set_f64(-d.constant.as_f64())
            | d.constant.is_u64(): d.constant.set_f64(-d.constant.as_f64())
            }
            normalize_type(d)
        }

        d.lvalue = false
        d.model = &UnaryExprModel{
            expr: d.model,
            op:   str(TokenKind.Minus),
        }
        ret d
    }

    fn eval_unary_plus(self, mut d: &Data): &Data {
        if real(d.kind.ref()) {
            let mut ref = d.kind.ref()
            let prim = ref.elem.prim()
            if !real(prim) || !types::is_num(prim.to_str()) {
                ret new(Data)
            }
            d.kind = ref.elem
        } else {
            let t = d.kind.prim()
            if !real(t) || !types::is_num(t.to_str()) {
                ret new(Data)
            }
        }

        if d.is_const() {
            match {
            | d.constant.is_f64(): d.constant.set_f64(+d.constant.read_f64())
            | d.constant.is_i64(): d.constant.set_f64(+d.constant.as_f64())
            | d.constant.is_u64(): d.constant.set_f64(+d.constant.as_f64())
            }
            normalize_type(d)
        }

        d.lvalue = false
        d.model = &UnaryExprModel{
            expr: d.model,
            op:   str(TokenKind.Plus),
        }
        ret d
    }

    fn eval_unary_caret(self, mut d: &Data): &Data {
        if real(d.kind.ref()) {
            let mut ref = d.kind.ref()
            let prim = ref.elem.prim()
            if !real(prim) || !types::is_int(prim.to_str()) {
                ret new(Data)
            }
            d.kind = ref.elem
        } else {
            let t = d.kind.prim()
            if !real(t) || !types::is_int(t.to_str()) {
                ret new(Data)
            }
        }

        if d.is_const() {
            match {
            | d.constant.is_i64():
                d.constant.set_i64(^d.constant.read_i64())

            | d.constant.is_u64():
                d.constant.set_u64(^d.constant.read_u64())
            }
        }

        d.lvalue = false
        d.model = &UnaryExprModel{
            expr: d.model,
            op:   str(TokenKind.Caret),
        }
        ret d
    }

    fn eval_unary_excl(self, mut d: &Data): &Data {
        if real(d.kind.ref()) {
            let mut ref = d.kind.ref()
            let prim = ref.elem.prim()
            if !real(prim) || !prim.is_bool() {
                ret new(Data)
            }
            d.kind = ref.elem
        } else {
            let t = d.kind.prim()
            if !real(t) || !t.is_bool() {
                ret new(Data)
            }
        }

        if d.is_const() {
            match {
            | d.constant.is_bool():
                d.constant.set_bool(!d.constant.read_bool())
            }
        }

        d.lvalue = false
        d.model = &UnaryExprModel{
            expr: d.model,
            op:   str(TokenKind.Excl),
        }
        ret d
    }

    fn eval_unary_star(mut self, mut d: &Data, op: Token): &Data {
        if !self.is_unsafe() {
            self.push_err(op, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
        }

        let mut t = d.kind.ptr()
        if !real(t) || t.is_unsafe() {
            ret new(Data)
        }
        drop(d.constant)
        d.lvalue = true
        d.kind = t.elem
        d.model = &UnaryExprModel{
            expr: d.model,
            op:   str(TokenKind.Star),
        }
        ret d
    }

    fn eval_unary_amper(self, mut d: &Data): &Data {
        match type d.model {
        | &StructLitExprModel:
            let mut lit = (&StructLitExprModel)(d.model)
            make_struct_lit_alloc(d, lit)

        |:
            match {
            | real(d.kind.ref()):
                d.kind = &TypeKind{
                    kind: &Ptr{elem: d.kind.ref().elem.clone()},
                }
                d.model = &GetRefPtrExprModel{
                    expr: d.model,
                }

            | can_get_ptr(d):
                d.kind = &TypeKind{
                    kind: &Ptr{elem: d.kind.clone()},
                }
                d.model = &UnaryExprModel{
                    expr: d.model,
                    op:   str(TokenKind.Amper),
                }

            |:
                drop(d)
            }
        }

        if real(d) {
            drop(d.constant)
            d.lvalue = false
            d.mutable = true
        }

        ret d
    }

    fn eval_unary_type_decl(mut self, mut d: &Data, mut u: &UnaryExpr): &Data {
        let mut tc = TypeChecker{
            s:           self.s,
            lookup:      self.lookup,
            error_token: u.op,
        }

        match u.op.kind {
        | str(TokenKind.Star):
            d.kind = &TypeKind{kind: tc.build_ptr_from_type(d.kind)}

        | str(TokenKind.Amper):
            d.kind = &TypeKind{kind: tc.build_ref_from_type(d.kind)}

        |:
            self.push_err(u.op, LogMsg.InvalidExprForUnary, u.op.kind)
            ret new(Data)
        }

        d.decl = true
        ret d
    }

    fn eval_unary(mut &self, mut u: &UnaryExpr): &Data {
        let mut prefix = self.prefix
        drop(self.prefix)
        defer { self.prefix = prefix }

        let mut d = self.eval_expr_kind(u.expr)
        if !real(d) {
            ret new(Data)
        }

        if d.decl {
            ret self.eval_unary_type_decl(d, u)
        }

        let mut cast_kind = d.cast_kind
        match u.op.kind {
        | str(TokenKind.Minus): d = self.eval_unary_minus(d)
        | str(TokenKind.Plus):  d = self.eval_unary_plus(d)
        | str(TokenKind.Caret): d = self.eval_unary_caret(d)
        | str(TokenKind.Excl):  d = self.eval_unary_excl(d)
        | str(TokenKind.Star):  d = self.eval_unary_star(d, u.op)
        | str(TokenKind.Amper): d = self.eval_unary_amper(d)
        |:                      drop(d)
        }

        if !real(d) {
            self.push_err(u.op, LogMsg.InvalidExprForUnary, u.op.kind)
        } else if d.is_const() {
            d.model = d.constant
        } else if real(cast_kind) {
            d.cast_kind = cast_kind
            apply_cast_kind(d)
        }

        ret d
    }

    fn eval_variadic(mut &self, mut v: &VariadicExpr): &Data {
        let mut prefix = self.prefix
        drop(self.prefix)
        defer { self.prefix = prefix }

        let mut d = self.eval_expr_kind(v.expr)
        if !real(d) {
            ret new(Data)
        }

        if real(d.kind.ref()) {
            d.kind = d.kind.ref().elem
            d.model = &ExplicitDerefExprModel{
                expr: d.model,
            }
        }

        if !d.kind.variadicable() {
            self.push_err(v.token, LogMsg.VariadicWithNonVariadicable, d.kind.to_str())
            ret new(Data)
        }

        d.variadiced = true
        d.kind = d.kind.slc().elem
        d.kind.variadic = true
        ret d
    }

    fn eval_unsafe(mut &self, mut u: &UnsafeExpr): &Data {
        let unsafety = self.unsafety
        self.unsafety = true

        let mut d = self.eval_expr_kind(u.expr)

        self.unsafety = unsafety

        ret d
    }

    fn eval_arr(mut &self, mut s: &SliceExpr): &Data {
        // Arrays always has type prefixes.
        let mut pt = self.prefix.arr()

        let mut arr = &Arr{
            auto: false,
            n:    0,
            elem: pt.elem,
        }

        if pt.auto {
            arr.n = s.elems.len
        } else {
            arr.n = s.elems.len
            if arr.n > pt.n {
                self.push_err(s.token, LogMsg.OverflowLimits)
            } else if arr.n < pt.n {
                arr.n = pt.n
            }
        }

        let mut model = &ArrayExprModel{
            kind:  arr,
            elems: make([]ExprModel, s.elems.len),
        }

        let mut prefix = self.prefix
        self.prefix = arr.elem
        for (i, mut elem) in s.elems {
            let mut d = self.eval_expr_kind(elem)
            if !real(d) {
                continue
            }

            self.s.check_assign_type(false, arr.elem, d, s.token, true)
            model.elems[i] = d.model
        }
        self.prefix = prefix

        ret &Data{
            mutable: true,
            kind:    &TypeKind{kind: arr},
            model:   model,
        }
    }

    fn eval_exp_slc(mut &self, mut s: &SliceExpr, mut elem_type: &TypeKind): &Data {
        let mut slc = &Slc{
            elem: elem_type,
        }

        let mut model = &SliceExprModel{
            elem_kind: elem_type,
            elems:     make([]ExprModel, s.elems.len),
        }

        let mut prefix = self.prefix
        self.prefix = slc.elem
        for (i, mut elem) in s.elems {
            let mut d = self.eval_expr_kind(elem)
            if !real(d) {
                continue
            }

            self.s.check_assign_type(false, slc.elem, d, s.token, true)
            model.elems[i] = d.model
        }
        self.prefix = prefix

        ret &Data{
            mutable: true,
            kind:    &TypeKind{kind: slc},
            model:   model,
        }
    }

    fn eval_slice_expr(mut &self, mut s: &SliceExpr): &Data {
        if real(self.prefix) {
            match {
            | real(self.prefix.arr()):
                ret self.eval_arr(s)

            | real(self.prefix.slc()):
                let mut pt = self.prefix.slc()
                ret self.eval_exp_slc(s, pt.elem)
            }
        }

        let mut prefix = self.prefix
        drop(self.prefix)

        if s.elems.len == 0 {
            self.push_err(s.token, LogMsg.DynamicTypeAnnotationFailed)
            ret new(Data)
        }

        let mut first_elem = self.eval_expr_kind(s.elems[0])
        if !real(first_elem) {
            ret new(Data)
        }

        let mut d = self.eval_exp_slc(s, first_elem.kind)

        self.prefix = prefix
        ret d
    }

    fn check_integer_indexing_by_data(mut self, mut d: &Data, token: Token) {
        let err_key = check_data_for_integer_indexing(d)
        if err_key != LogMsg.Empty {
            self.push_err(token, err_key)
        }
    }

    fn indexing_ptr(mut self, mut d: &Data, mut index: &Data, i: &IndexingExpr) {
        self.check_integer_indexing_by_data(index, i.token)

        let mut ptr = d.kind.ptr()
        match {
        | ptr.is_unsafe():
            self.push_err(i.token, LogMsg.UnsafePtrIndexing)
            ret

        | !self.is_unsafe():
            self.push_err(i.token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
        }

        d.kind = ptr.elem.clone()
    }

    fn indexing_arr(mut self, mut d: &Data, mut index: &Data, i: &IndexingExpr) {
        let mut arr = d.kind.arr()
        d.kind = arr.elem.clone()
        self.check_integer_indexing_by_data(index, i.token)
        if index.is_const() && index.constant.as_f64() >= f64(arr.n) {
            self.push_err(i.token, LogMsg.OverflowLimits)
        }
    }

    fn indexing_slc(mut self, mut d: &Data, mut index: &Data, i: &IndexingExpr) {
        let mut slc = d.kind.slc()
        d.kind = slc.elem.clone()
        self.check_integer_indexing_by_data(index, i.token)

        // Check compile-time bounds.
        if !index.is_const() {
            ret
        }
        match type d.model {
        | &SliceExprModel:
            let m = (&SliceExprModel)(d.model)
            let indx = index.constant.as_f64()
            if indx >= f64(m.elems.len) {
                self.push_err(i.token, LogMsg.OverflowLimits)
            }
        }
    }

    fn indexing_map(mut self, mut d: &Data, mut index: &Data, mut i: &IndexingExpr) {
        if !real(index) {
            ret
        }

        let mut m = d.kind.map()
        let mut atc = AssignTypeChecker{
            s:           self.s,
            dest:        m.key,
            d:           index,
            error_token: i.token,
            deref:       true,
        }
        _ = atc.check()

        d.kind = m.val.clone()
    }

    fn indexing_str(mut self, mut d: &Data, mut index: &Data, i: &IndexingExpr) {
        const BYTE_KIND = str(PrimKind.U8)
        d.kind.kind = build_prim_type(BYTE_KIND)

        if !real(index) {
            ret
        }

        self.check_integer_indexing_by_data(index, i.token)

        if !index.is_const() {
            drop(d.constant)
            ret
        }

        if d.is_const() {
            let error_token = i.token
            let j = index.constant.as_i64()
            let s = d.constant.read_str()
            if int(j) >= s.len {
                self.push_err(error_token, LogMsg.OverflowLimits)
            } else {
                d.constant.set_u64(u64(s[j]))
            }
        }
    }

    fn to_indexing(mut self, mut d: &Data, mut index: &Data, mut i: &IndexingExpr) {
        match {
        | real(d.kind.ptr()):
            self.indexing_ptr(d, index, i)
            ret

        | real(d.kind.arr()):
            self.indexing_arr(d, index, i)
            ret

        | real(d.kind.slc()):
            self.indexing_slc(d, index, i)
            ret

        | real(d.kind.map()):
            self.indexing_map(d, index, i)
            ret

        | real(d.kind.prim()):
            let prim = d.kind.prim()
            match {
            | prim.is_str():
                self.indexing_str(d, index, i)
                ret
            }
        }

        self.push_err(i.token, LogMsg.NotSupportsIndexing, d.kind.to_str())
    }

    fn eval_ident_decl_from_indexing(mut &self, mut i: &IndexingExpr): &Data {
        match type i.expr {
        | &IdentExpr:
        |:
            self.push_err(i.token, LogMsg.InvalidSyntax)
            ret new(Data)
        }

        let mut decl = &IdentTypeDecl{
            ident: (&IdentExpr)(i.expr).ident,
        }

        match type i.index {
        | &UnaryExpr:
            // Unary eval catches type declarations.
            // Therefore use unary eval algorithm for eval related type declarations.
            let mut d = self.eval_unary((&UnaryExpr)(i.index))
            if !d.decl {
                self.push_err(i.token, LogMsg.InvalidSyntax)
                ret new(Data)
            }
            decl.generics = append(decl.generics, &TypeDecl{kind: d.kind})

        | &TypeDecl:
            decl.generics = append(decl.generics, (&TypeDecl)(i.index))

        | &IdentExpr:
            decl.generics = append(decl.generics, &TypeDecl{
                kind: &IdentTypeDecl{ident: (&IdentExpr)(i.index).ident}
            })

        | &TupleExpr:
            for (_, mut expr) in (&TupleExpr)(i.index).expr {
                match type expr.kind {
                | &TypeDecl:
                    decl.generics = append(decl.generics, (&TypeDecl)(expr.kind))

                | &IdentExpr:
                    decl.generics = append(decl.generics, &TypeDecl{
                        kind: &IdentTypeDecl{ident: (&IdentExpr)(expr.kind).ident}
                    })
                }
            }

        |:
            self.push_err(i.token, LogMsg.InvalidSyntax)
            ret new(Data)
        }

        ret self.eval_type(&TypeDecl{kind: decl})
    }

    fn eval_indexing(mut &self, mut i: &IndexingExpr): &Data {
        let mut prefix = self.prefix
        drop(self.prefix)
        defer { self.prefix = prefix }

        let mut d = self.eval_expr_kind(i.expr)
        if !real(d) {
            ret new(Data)
        }

        // Catch types.
        if d.decl {
            ret self.eval_ident_decl_from_indexing(i)
        }

        let mut old_d: Data = d

        let mut index = self.eval_expr_kind(i.index)
        if !real(index) {
            ret new(Data)
        }

        self.to_indexing(d, index, i)
        if d.is_const() {
            d.model = d.constant
        } else {
            d.model = &IndexigExprModel{
                expr:  new(Data, old_d),
                index: index,
            }
        }

        ret d
    }

    // Returns left and right index values.
    // Returns zero integer expression if slicing have not left index.
    // So, left index always represents an expression.
    // Left data is nil if expression eval failed.
    fn eval_slicing_exprs(mut &self, mut s: &SlicingExpr): (&Data, &Data) {
        let mut prefix = self.prefix
        drop(self.prefix)
        defer { self.prefix = prefix }

        let mut l = new(Data)
        let mut r = new(Data)

        if s.start != nil {
            l = self.eval_expr_kind(s.start)
            if real(l) {
                self.check_integer_indexing_by_data(l, s.token)
            } else {
                ret new(Data), new(Data)
            }
        } else {
            l = &Data{
                constant: Const.new_i64(0),
                kind:     &TypeKind{kind: build_prim_type(types::SYS_INT)},
            }
            l.model = l.constant
        }

        if s.to != nil {
            r = self.eval_expr_kind(s.to)
            if real(r) {
                self.check_integer_indexing_by_data(r, s.token)
            } else {
                ret new(Data), new(Data)
            }
        }

        ret l, r
    }

    fn slicing_arr(self, mut d: &Data) {
        let mut elem_type = d.kind.arr().elem.clone()
        d.kind.kind = &Slc{elem: elem_type}

        d.lvalue = false

        // Keep mutability id already mutable.
        // Be mutable, if element is not mutable-type.
        d.mutable = d.mutable || !elem_type.mutable()
    }

    fn slicing_slc(self, mut d: &Data) {
        d.lvalue = false
    }

    fn slicing_str(self, mut d: &Data, l: &Data, r: &Data) {
        d.lvalue = false
        d.mutable = true
        if !d.is_const() {
            ret
        }

        if !real(l) || !real(r) {
            drop(d.constant)
            ret
        }

        if l.is_const() && r.is_const() {
            let left = l.constant.as_i64()
            if left < 0 {
                ret
            }

            let s = d.constant.read_str()
            let mut right: i64 = 0
            if !real(r) {
                right = i64(s.len)
            } else {
                right = r.constant.as_i64()
            }

            if left > right {
                ret
            }
            d.constant.set_str(s[left:right])
        } else {
            drop(d.constant)
        }
    }

    fn check_slicing(mut self, mut d: &Data, l: &Data, r: &Data, s: &SlicingExpr) {
        match {
        | real(d.kind.arr()):
            self.slicing_arr(d)
            ret

        | real(d.kind.slc()):
            self.slicing_slc(d)
            ret

        | real(d.kind.prim()):
            let prim = d.kind.prim()
            match {
            | prim.is_str():
                self.slicing_str(d, l, r)
                ret
            }
        }

        self.push_err(s.token, LogMsg.NotSupportsSlicing, d.kind.to_str())
    }

    fn eval_slicing(mut &self, mut s: &SlicingExpr): &Data {
        let mut d = self.eval_expr_kind(s.expr)
        if !real(d) {
            ret new(Data)
        }

        let (mut l, mut r) = self.eval_slicing_exprs(s)
        if !real(l) {
            ret d
        }

        self.check_slicing(d, l, r, s)
        drop(d.cast_kind)

        let mut model = &SlicingExprModel{
            expr: d.model,
            left: l.model,
        }

        if real(r) {
            model.right = r.model
        }

        d.model = model
        ret d
    }

    fn cast_ptr(mut self, t: &TypeKind, mut d: &Data, error_token: Token) {
        if !self.is_unsafe() {
            self.push_err(error_token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            ret
        }

        let prim = d.kind.prim()
        if !real(d.kind.ptr()) && (!real(prim) || !types::is_int(prim.to_str())) {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
        }

        drop(d.constant)
    }

    fn cast_struct(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        let mut tr = d.kind.trt()
        if !real(tr) {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
            ret
        }

        let mut s = new(StructIns)
        if real(t.ref()) {
            s = t.ref().elem.strct()
        } else {
            s = t.strct()
        }

        self.push_reference_to_struct(s)

        if !s.decl.is_implements(tr) {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
        }
    }

    fn cast_ref(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        let mut ref = t.ref()
        if real(ref.elem.strct()) {
            self.cast_struct(t, d, error_token)
            ret
        }

        self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
    }

    fn cast_slc(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        if real(d.kind.enm()) {
            if !real(d.kind.enm().kind.kind.prim()) || !d.kind.enm().kind.kind.prim().is_str() {
                self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
                ret
            }
        } else if !real(d.kind.prim()) || !d.kind.prim().is_str() {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
            ret
        }

        t = t.slc().elem
        let prim = t.prim()
        if !real(prim) || (!prim.is_u8() && !prim.is_i32()) {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
        }
    }

    fn cast_str(mut self, mut d: &Data, error_token: Token) {
        if real(d.kind.enm()) {
            let mut e = d.kind.enm()
            if real(e.kind.kind.prim()) && e.kind.kind.prim().is_str() {
                ret
            }
        }

        if real(d.kind.prim()) {
            let prim = d.kind.prim()
            if !prim.is_u8() && !prim.is_i32() {
                self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, str(PrimKind.Str), d.kind.to_str())
            }
            ret
        }

        if !real(d.kind.slc()) {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, str(PrimKind.Str), d.kind.to_str())
            ret
        }

        let mut t = d.kind.slc().elem
        let prim = t.prim()
        if !real(prim) || (!prim.is_u8() && !prim.is_i32()) {
            self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, str(PrimKind.Str), d.kind.to_str())
        }
    }

    fn cast_int(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        if d.is_const() {
            let prim = t.prim()
            match {
            | types::is_sig_int(prim.kind):
                d.constant.set_i64(d.constant.as_i64())

            | types::is_unsig_int(prim.kind):
                d.constant.set_u64(d.constant.as_u64())
            }
        }

        if real(d.kind.enm()) {
            let e = d.kind.enm()
            if types::is_num(e.kind.kind.to_str()) {
                ret
            }
        }

        if real(d.kind.ptr()) {
            let prim = t.prim()
            if prim.is_uintptr() {
                // Ignore case.
            } else if !self.is_unsafe() {
                self.push_err(error_token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            } else if !prim.is_i32() && !prim.is_i64() && !prim.is_u16() && !prim.is_u32() && !prim.is_u64() {
                self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
            }
            ret
        }

        let prim = d.kind.prim()
        if real(prim) && types::is_num(prim.to_str()) {
            ret
        }

        self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
    }

    fn cast_num(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        if d.is_const() {
            let prim = t.prim()
            match {
            | types::is_float(prim.kind):
                d.constant.set_f64(d.constant.as_f64())

            | types::is_sig_int(prim.kind):
                d.constant.set_i64(d.constant.as_i64())

            | types::is_unsig_int(prim.kind):
                d.constant.set_u64(d.constant.as_u64())
            }
        }

        if real(d.kind.enm()) {
            let e = d.kind.enm()
            if types::is_num(e.kind.kind.to_str()) {
                ret
            }
        }

        let prim = d.kind.prim()
        if real(prim) && types::is_num(prim.to_str()) {
            ret
        }

        self.push_err(error_token, LogMsg.TypeNotSupportsCastingTo, d.kind.to_str(), t.to_str())
    }

    fn cast_prim(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token) {
        let prim = t.prim()
        match {
        | prim.is_any():
            // The any type supports casting to any data type.

        | prim.is_str():
            self.cast_str(d, error_token)

        | types::is_int(prim.to_str()):
            self.cast_int(t, d, error_token)

        | types::is_num(prim.to_str()):
            self.cast_num(t, d, error_token)

        |:
            self.push_err(error_token, LogMsg.TypeNotSupportsCasting, t.to_str())
        }
    }

    fn cast_constant(mut self, mut &t: &TypeKind, mut &d: &Data) {
        let prim = t.prim()
        if !real(prim) || !d.is_const() {
            ret
        }

        match {
        | types::is_sig_int(prim.kind):
            d.constant.set_i64(d.constant.as_i64())

        | types::is_unsig_int(prim.kind):
            d.constant.set_u64(d.constant.as_u64())

        | types::is_float(prim.kind):
            d.constant.set_f64(d.constant.as_f64())
        }

        d.model = d.constant
    }

    fn eval_cast_by_type_n_data(mut self, mut t: &TypeKind, mut d: &Data, error_token: Token): &Data {
        match {
        | real(d.kind.prim()) && d.kind.prim().is_any():
            if real(t.enm()) {
                self.push_err(error_token, LogMsg.EnumCastedFromAny)
                self.push_suggestion(LogMsg.CastToEnumTypeInsteadOfEnum)
            }

        | real(t.ptr()):
            self.cast_ptr(t, d, error_token)

        | real(t.ref()):
            self.cast_ref(t, d, error_token)

        | real(t.slc()):
            self.cast_slc(t, d, error_token)

        | real(t.strct()):
            self.cast_struct(t, d, error_token)

        | real(t.prim()):
            self.cast_prim(t, d, error_token)

        |:
            self.push_err(error_token, LogMsg.TypeNotSupportsCasting, t.to_str())
            drop(d)
        }

        if !real(d) {
            ret new(Data)
        }

        // Keep mutability if data is already mutable.
        // Even if the data is not mutable, set as mutable if the type is not mutable-type.
        d.mutable = d.mutable || (!d.kind.mutable() && t.mutable())

        d.lvalue = t.lvalue()
        d.decl = false
        self.cast_constant(t, d)

        if !real(d.kind.enm()) || d.kind.enm().kind.kind.to_str() != t.to_str() {
            d.cast_kind = t
            // d.kind = t // Do not this, will be set automatically end of the eval.
        } else {
            d.kind = t
        }

        ret d
    }

    fn eval_cast(mut &self, mut c: &CastExpr): &Data {
        let mut t = build_type(c.kind)
        let ok = self.s.check_type(t, self.lookup)
        if !ok {
            ret new(Data)
        }

        let mut prefix = self.prefix
        drop(self.prefix)
        defer { self.prefix = prefix }

        let mut d = self.eval_expr_kind(c.expr)
        if !real(d) {
            ret new(Data)
        }

        d = self.eval_cast_by_type_n_data(t.kind, d, c.kind.token)

        ret d
    }

    fn eval_ns_selection(mut self, s: &NsSelectionExpr): &Data {
        let path = build_link_path_by_tokens(s.ns)
        let mut imp = self.lookup.select_package(fn(p: &ImportInfo): bool {
            if s.ns.len == 1 && p.alias == path {
                ret true
            }
            ret p.link_path == path
        })

        if !real(imp) || !imp.is_lookupable(str(TokenKind.Self)) {
            self.push_err(s.ident, LogMsg.NamespaceNotExist, path)
            ret new(Data)
        }

        let mut lookup = self.lookup
        self.lookup = imp

        const CPP_LINKED = false
        let mut def = self.get_def(s.ident.kind, CPP_LINKED)
        self.lookup = lookup

        let mut d = self.eval_def(def, s.ident)

        ret d
    }

    fn eval_struct_lit_explicit(mut &self, mut s: &StructIns,
        mut exprs: []ExprData, mut error_token: Token): &Data {
        let ok = self.s.check_generic_quantity(s.decl.generics.len, s.generics.len, error_token)
        if !ok {
            ret new(Data)
        }
        // NOTE: Instance already checked (just fields) if generic quantity passes.

        self.push_reference_to_struct(s)

        let mut slc = StructLitChecker{
            e:           self,
            error_token: error_token,
            s:           s,
        }
        slc.check(exprs)

        ret &Data{
            mutable: !self.immutable,
            kind:    &TypeKind{kind: s},
            model: &StructLitExprModel{
                strct: s,
                args:  slc.args,
            },
        }
    }

    fn eval_struct_lit(mut &self, mut lit: &StructLit): &Data {
        let mut t = build_type(lit.kind)
        let ok = self.s.check_type(t, self.lookup)
        if !ok {
            ret new(Data)
        }

        let mut s = t.kind.strct()
        if !real(s) {
            if real(t.kind.ref()) {
                s = t.kind.ref().elem.strct()
                if real(s) {
                    goto eval
                }
            }
            self.push_err(lit.kind.token, LogMsg.InvalidSyntax)
            ret new(Data)
        }

    eval:
        let mut d = self.eval_struct_lit_explicit(s, lit.exprs, lit.kind.token)
        if real(t.kind.ref()) {
            let mut model = (&StructLitExprModel)(d.model)
            make_struct_lit_alloc(d, model)
        }
        ret d
    }

    fn eval_type(mut self, mut t: &TypeDecl): &Data {
        let mut tk = build_type(t)
        let ok = self.s.check_type(tk, self.lookup)
        if !ok {
            ret new(Data)
        }

        ret &Data{
            decl:  true,
            kind:  tk.kind,
            model: tk.kind,
        }
    }

    fn call_type_fn(mut &self, mut fc: &FnCallExpr, mut d: &Data): &Data {
        if fc.generics.len > 0 {
            self.push_err(fc.token, LogMsg.TypeNotSupportsGenerics, d.kind.to_str())
        } else if fc.args.len < 1 {
            self.push_err(fc.token, LogMsg.MissingExprFor, "v")
        } else if fc.args.len > 1 {
            self.push_err(fc.args[1].token, LogMsg.ArgumentOverflow)
        }

        if fc.args.len > 0 {
            let mut arg = self.eval_expr_kind(fc.args[0].kind)

            if real(arg) {
                d = self.eval_cast_by_type_n_data(d.kind, arg, fc.args[0].token)
            }
        }

        d.decl = false
        ret d
    }

    fn check_fn_call_generics(mut self, mut f: &FnIns,
        mut fc: &FnCallExpr): (ok: bool, dynamic_annotation: bool) {
        match {
        | f.decl.generics.len > 0 && fc.generics.len == 0 && f.params.len > 0:
            dynamic_annotation = true
            // Make empty types to generics for ordering.
            f.generics = make([]&TypeKind, f.decl.generics.len)
            ret true, true

        | !self.s.check_generic_quantity(f.decl.generics.len, fc.generics.len, fc.token):
            ret false, false

        |:
            // Build real kinds of generic types.
            f.generics = make([]&TypeKind, f.decl.generics.len)
            for (i, mut g) in fc.generics {
                let mut k = build_type(g)
                ok = self.s.check_type(k, self.lookup)
                if !ok {
                    ret false, false
                }
                f.generics[i] = k.kind
            }

            ret true, false
        }
    }

    fn call_builtin_fn(mut &self, mut fc: &FnCallExpr, mut d: &Data): &Data {
        let mut f = d.kind.fnc()

        d = f.caller(self, fc, d)
        if !real(d) {
            ret new(Data)
        }

        d.mutable = true
        ret d
    }

    fn check_fn_of_concurrent_call(mut self, &f: &FnIns, error_token: Token) {
        if self.is_unsafe() {
            ret
        }

        for _, p in f.params {
            if p.decl.reference {
                self.push_err(error_token, LogMsg.ConcurrenctCallWithRefParam)
                ret
            }
        }
    }

    fn call_fn(mut &self, mut fc: &FnCallExpr, mut d: &Data): &Data {
        let mut f = d.kind.fnc()
        if f.is_builtin() {
            ret self.call_builtin_fn(fc, d)
        }

        if fc.concurrent {
            self.check_fn_of_concurrent_call(f, fc.token)
        }

        if !d.mutable && f.decl.is_method() && !f.decl.statically && f.decl.params[0].mutable {
            self.push_err(fc.token, LogMsg.MutOperationOnImmut)
        } else if !self.is_unsafe() && f.decl.unsafety {
            self.push_err(fc.token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
        }

        let (mut ok, dynamic_annotation) = self.check_fn_call_generics(f, fc)
        if !ok {
            ret new(Data)
        }

        let mut old = self.s
        if real(f.decl.owner) {
            self.s = f.decl.owner.sema
        }

        defer {
            if &old != &self.s {
                old.errors = append(old.errors, self.s.errors...)
                self.s.errors = nil
            }
            self.s = old
        }

        if !dynamic_annotation {
            if !f.reloaded {
                ok = self.s.reload_fn_ins_types(f)
                if !ok {
                    ret new(Data)
                }
                f.reloaded = true
            }
        } else {
            self.s.build_fn_non_generic_type_kinds(f)
        }

        let mut fcac = FnCallArgChecker{
            e:                  self,
            f:                  f,
            args:               fc.args,
            dynamic_annotation: dynamic_annotation,
            error_token:        fc.token,
        }
        if real(f.decl.owner) {
            old, self.s = self.s, old // Save current Sema.
            ok = fcac.check()
            old, self.s = self.s, old // Save owner Sema.
        } else {
            ok = fcac.check()
        }

        if !ok && dynamic_annotation {
            ret new(Data)
        }

        let (is_unique_ins, pos) = f.decl.append_instance(f)
        if !is_unique_ins {
            f = f.decl.instances[pos]
        }

        let mut call_model = d.model

        if f.decl.is_void() {
            d = build_void_data()
        } else {
            if dynamic_annotation {
                ok = self.s.reload_fn_ins_types(f)
                if !ok {
                    ret new(Data)
                }
                f.reloaded = true
            }

            d.kind = f.result
            d.lvalue = f.result.lvalue()
        }

        d.mutable = true
        d.model = &FnCallExprModel{
            func:  f,
            is_co: fc.concurrent,
            expr:  call_model,
            args:  fcac.arg_models,
        }

        if f.generics.len > 0 && is_unique_ins {
            // Check generic function instance instantly.
            self.s.check_fn_ins(f)
        }

        ret d
    }

    fn eval_fn_call(mut &self, mut fc: &FnCallExpr): &Data {
        let mut prefix = self.prefix
        drop(self.prefix)
        defer { self.prefix = prefix }

        let mut d = self.eval_expr_kind(fc.expr.kind)
        if !real(d) {
            ret new(Data)
        }

        if d.decl {
            ret self.call_type_fn(fc, d)
        }

        if !real(d.kind.fnc()) {
            self.push_err(fc.token, LogMsg.InvalidSyntax)
            ret new(Data)
        }

        ret self.call_fn(fc, d)
    }

    fn eval_enum_static(mut self, mut enm: &Enum, ident: Token): &Data {
        let mut d = &Data{
            lvalue:  false,
            decl:    false,
            mutable: false,
            kind:    &TypeKind{kind: enm},
        }

        let mut item = enm.find_item(ident.kind)
        if !real(item) {
            self.push_err(ident, LogMsg.ObjHaveNotIdent, ident.kind)
        } else {
            d.constant = new(Const, item.value.data.constant)
            d.model = d.constant
        }

        ret d
    }

    fn eval_struct_static(mut self, mut s: &StructIns, ident: Token): &Data {
        let mut d = &Data{
            lvalue:  false,
            decl:    false,
            mutable: false,
        }

        // Method.
        const STATIC = true
        let mut method = s.find_method(ident.kind, STATIC)
        if real(method) {
            if !self.s.is_accessible_define(method.public, method.token) {
                self.push_err(ident, LogMsg.IdentIsNotAccessible, ident.kind)
                self.push_suggestion(LogMsg.MakePubToAccess)
            }

            let mut ins = method.instance()
            ins.owner = s
            self.push_reference_to_fn(ins)
            d.model = &StructStaticIdentExprModel{
                structure: s,
                expr:      d.model,
                method:    ins,
            }
            d.kind = &TypeKind{kind: ins}
            ret d
        }

        let mut sttc = s.decl.find_static(ident.kind)
        if real(sttc) {
            ret self.eval_var(sttc, ident)
        }

        self.push_err(ident, LogMsg.ObjHaveNotIdent, ident.kind)
        ret new(Data)
    }

    fn eval_trait_sub_ident(mut self, mut d: &Data, mut trt: &Trait, ident: Token): &Data {
        let mut f = trt.find_method(ident.kind)
        if !real(f) {
            self.push_err(ident, LogMsg.ObjHaveNotIdent, ident.kind)
            ret new(Data)
        }

        let mut model: any = nil
        if &trt == &BUILTIN_TRAIT_ERROR {
            model = &BuiltinErrorTraitSubIdentExprModel{
                expr:  d.model,
                ident: ident.kind,
            }
        } else {
            model = &TraitSubIdentExprModel{
                expr:  d.model,
                ident: ident.kind,
            }
        }

        ret &Data{
            lvalue:   false,
            decl:     false,
            mutable:  false,
            kind:     &TypeKind{kind: f.instance()},
            model:    model,
        }
    }

    fn eval_struct_sub_ident(mut self, mut d: &Data, mut s: &StructIns, si: &SubIdentExpr, ref: bool): &Data {
        let mut f = s.find_field(si.ident.kind)
        if real(f) {
            if !self.s.is_accessible_define(f.decl.public, f.decl.token) {
                self.push_err(si.ident, LogMsg.IdentIsNotAccessible, f.decl.ident)
                self.push_suggestion(LogMsg.MakePubToAccess)
            }

            let mut model = &StructSubIdentExprModel{
                expr_kind: d.kind,
                expr:      d.model,
                field:     f,
            }
            d.model = model
            d.kind = f.kind.clone()

            if f.decl.mutable && !d.mutable {
                // Interior mutability.
                match type self.lookup {
                | &ScopeChecker:
                    let scope = (&ScopeChecker)(self.lookup).get_root()
                    d.mutable = real(scope.owner) && &scope.owner.owner == &s
                    if d.mutable {
                        let mut field = (&Var)(model.expr)
                        let mut v = &Var{
                            scope:      field.scope,
                            token:      field.token,
                            ident:      field.ident,
                            cpp_linked: field.cpp_linked,
                            constant:   field.constant,
                            kind:       field.kind,
                            value:      field.value,
                        }
                        v.mutable = true
                        model.expr = v
                    }
                }
            }

            ret d
        }

        const STATIC = false
        let mut m = s.find_method(si.ident.kind, STATIC)
        if !real(m) {
            self.push_err(si.ident, LogMsg.ObjHaveNotIdent, si.ident.kind)
            ret new(Data)
        }

        if m.params[0].is_ref() && !ref {
            self.push_err(si.ident, LogMsg.RefMethodUsedWithNotRefInstance)
        }


        let mut ins = m.instance()
        ins.owner = s
        self.push_reference_to_fn(ins)
        d.model = &StructSubIdentExprModel{
            expr_kind: d.kind,
            expr:      d.model,
            method:    ins,
        }
        d.kind = &TypeKind{kind: ins}
        ret d
    }

    fn eval_slice_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
        match ident.kind {
        | "len":
            ret &Data{
                mutable: false,
                kind:    &TypeKind{kind: build_prim_type(types::SYS_INT)},
                model:   &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "len()",
                },
            }
    
        | "cap":
            ret &Data{
                mutable: false,
                kind:    &TypeKind{kind: build_prim_type(types::SYS_INT)},
                model:   &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "cap()",
                },
            }

        |:
            self.push_err(ident, LogMsg.ObjHaveNotIdent, ident.kind)
            ret new(Data)
        }
    }

    fn eval_array_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
        match ident.kind {
        | "len":
            let mut c = Const.new_i64(i64(d.kind.arr().n))
            ret &Data{
                constant: c,
                mutable:  false,
                kind:     &TypeKind{kind: build_prim_type(types::SYS_INT)},
                model:    c,
            }

        |:
            self.push_err(ident, LogMsg.ObjHaveNotIdent, ident.kind)
            ret new(Data)
        }
    }

    fn eval_map_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
        let mut map_kind = d.kind.map()
        if !real(map_kind) {
            map_kind = d.kind.ref().elem.map()
        }

        match ident.kind {
        | "len":
            ret &Data{
                mutable: false,
                kind:    &TypeKind{kind: build_prim_type(types::SYS_INT)},
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "len()",
                },
            }

        | "clear":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common_mut,
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "clear",
                },
            }

        | "keys":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common_mut,
                        result: &TypeKind{
                            kind: &Slc{
                                elem: map_kind.key,
                            },
                        },
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "keys",
                },
            }

        | "values":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common_mut,
                        result: &TypeKind{
                            kind: &Slc{
                                elem: map_kind.val,
                            },
                        },
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "values",
                },
            }

        | "has":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "key",
                                },
                                kind: map_kind.key,
                            },
                        ],
                        result: &TypeKind{kind: build_prim_type(str(PrimKind.Bool))},
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "has",
                },
            }

        | "del":
            ret &Data{
                mutable: d.mutable,
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common_mut,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "key",
                                },
                                kind: map_kind.key,
                            },
                        ],
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "del",
                },
            }

        |:
            self.push_err(ident, LogMsg.ObjHaveNotIdent, ident.kind)
            ret new(Data)
        }
    }

    fn eval_str_sub_ident(mut self, mut d: &Data, ident: Token): &Data {
        let mut str_kind = &TypeKind{kind: build_prim_type(str(PrimKind.Str))}
        match ident.kind {
        | "len":
            ret &Data{
                mutable: false,
                kind:    &TypeKind{kind: build_prim_type(types::SYS_INT)},
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "len()",
                },
            }

        | "has_prefix":
            ret &Data{
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "sub",
                                },
                                kind: str_kind,
                            },
                        ],
                        result: &TypeKind{kind: build_prim_type(str(PrimKind.Bool))},
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "has_prefix",
                },
            }

        | "has_suffix":
            ret &Data{
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "sub",
                                },
                                kind: str_kind,
                            },
                        ],
                        result: &TypeKind{kind: build_prim_type(str(PrimKind.Bool))},
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "has_suffix",
                },
            }

        | "find":
            ret &Data{
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "sub",
                                },
                                kind: str_kind,
                            },
                        ],
                        result: &TypeKind{kind: build_prim_type(str(PrimKind.Int))},
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "find",
                },
            }

        | "rfind":
            ret &Data{
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "sub",
                                },
                                kind: str_kind,
                            },
                        ],
                        result: &TypeKind{kind: build_prim_type(str(PrimKind.Int))},
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "rfind",
                },
            }

        | "trim":
            ret &Data{
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "bytes",
                                },
                                kind: str_kind,
                            },
                        ],
                        result: str_kind,
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "trim",
                },
            }

        | "ltrim":
            ret &Data{
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "bytes",
                                },
                                kind: str_kind,
                            },
                        ],
                        result: str_kind,
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "ltrim",
                },
            }

        | "rtrim":
            ret &Data{
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "bytes",
                                },
                                kind: str_kind,
                            },
                        ],
                        result: str_kind,
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "rtrim",
                },
            }

        | "split":
            ret &Data{
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "sub",
                                },
                                kind: str_kind,
                            },
                            &ParamIns{
                                decl: &Param{
                                    ident: "n",
                                },
                                kind: &TypeKind{kind: build_prim_type(str(PrimKind.Int))},
                            },
                        ],
                        result: &TypeKind{
                            kind: &Slc{
                                elem: str_kind,
                            },
                        },
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "split",
                },
            }

        | "replace":
            ret &Data{
                kind: &TypeKind{
                    kind: &FnIns{
                        caller: builtin_caller_common,
                        params: [
                            &ParamIns{
                                decl: &Param{
                                    ident: "sub",
                                },
                                kind: str_kind,
                            },
                            &ParamIns{
                                decl: &Param{
                                    ident: "new",
                                },
                                kind: str_kind,
                            },
                            &ParamIns{
                                decl: &Param{
                                    ident: "n",
                                },
                                kind: &TypeKind{kind: build_prim_type(str(PrimKind.Int))},
                            },
                        ],
                        result: str_kind,
                    },
                },
                model: &CommonSubIdentExprModel{
                    expr_kind: d.kind,
                    expr:      d.model,
                    ident:     "replace",
                },
            }

        |:
            self.push_err(ident, LogMsg.ObjHaveNotIdent, ident.kind)
            ret new(Data)
        }
    }

    fn eval_int_type_static(mut self, ident: Token): &Data {
        const kind = str(PrimKind.Int)

        match ident.kind {
        | "MAX":
            let mut c = Const.new_i64(i64(types::max(kind)))
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_i64(i64(types::min(kind)))
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_uint_type_static(mut self, ident: Token): &Data {
        const kind = str(PrimKind.Uint)

        match ident.kind {
        | "MAX":
            let mut c = Const.new_u64(u64(types::max(kind)))
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_i8_type_static(mut self, ident: Token): &Data {
        const kind = str(PrimKind.I8)
        const min = types::MIN_I8
        const max = types::MAX_I8

        match ident.kind {
        | "MAX":
            let mut c = Const.new_i64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_i64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_i16_type_static(mut self, ident: Token): &Data {
        const kind = str(PrimKind.I16)
        const min = types::MIN_I16
        const max = types::MAX_I16

        match ident.kind {
        | "MAX":
            let mut c = Const.new_i64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_i64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_i32_type_static(mut self, ident: Token): &Data {
        const kind = str(PrimKind.I32)
        const min = types::MIN_I32
        const max = types::MAX_I32

        match ident.kind {
        | "MAX":
            let mut c = Const.new_i64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_i64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_i64_type_static(mut self, ident: Token): &Data {
        const kind = str(PrimKind.I64)
        const min = types::MIN_I64
        const max = types::MAX_I64

        match ident.kind {
        | "MAX":
            let mut c = Const.new_i64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_i64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_u8_type_static(mut self, ident: Token): &Data {
        const kind = str(PrimKind.U8)
        const max = types::MAX_U8

        match ident.kind {
        | "MAX":
            let mut c = Const.new_u64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_u16_type_static(mut self, ident: Token): &Data {
        const kind = str(PrimKind.U16)
        const max = types::MAX_U16

        match ident.kind {
        | "MAX":
            let mut c = Const.new_u64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_u32_type_static(mut self, ident: Token): &Data {
        const kind = str(PrimKind.U32)
        const max = types::MAX_U32

        match ident.kind {
        | "MAX":
            let mut c = Const.new_u64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_u64_type_static(mut self, ident: Token): &Data {
        const kind = str(PrimKind.U64)
        const max = types::MAX_U64

        match ident.kind {
        | "MAX":
            let mut c = Const.new_u64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_f32_type_tatic(mut self, ident: Token): &Data {
        const kind = str(PrimKind.F32)
        const max = types::MAX_F32
        const min = types::MIN_F32

        match ident.kind {
        | "MAX":
            let mut c = Const.new_f64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_f64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_f64_type_static(mut self, ident: Token): &Data {
        const kind = str(PrimKind.F64)
        const max = types::MAX_F64
        const min = types::MIN_F64

        match ident.kind {
        | "MAX":
            let mut c = Const.new_f64(max)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        | "MIN":
            let mut c = Const.new_f64(min)
            ret &Data{
                constant: c,
                model:    c,
                kind:     &TypeKind{kind: build_prim_type(kind)},
            }

        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_prim_static(mut self, kind: str, ident: Token): &Data {
        match kind {
        | str(PrimKind.Int):  ret self.eval_int_type_static(ident)
        | str(PrimKind.Uint): ret self.eval_uint_type_static(ident)
        | str(PrimKind.I8):   ret self.eval_i8_type_static(ident)
        | str(PrimKind.I16):  ret self.eval_i16_type_static(ident)
        | str(PrimKind.I32):  ret self.eval_i32_type_static(ident)
        | str(PrimKind.I64):  ret self.eval_i64_type_static(ident)
        | str(PrimKind.U8):   ret self.eval_u8_type_static(ident)
        | str(PrimKind.U16):  ret self.eval_u16_type_static(ident)
        | str(PrimKind.U32):  ret self.eval_u32_type_static(ident)
        | str(PrimKind.U64):  ret self.eval_u64_type_static(ident)
        | str(PrimKind.F32):  ret self.eval_f32_type_tatic(ident)
        | str(PrimKind.F64):  ret self.eval_f64_type_static(ident)
        |:
            self.push_err(ident, LogMsg.TypeHaveNotIdent, kind, ident.kind)
            ret new(Data)
        }
    }

    fn eval_type_static(mut self, mut d: &Data, mut si: &SubIdentExpr): &Data {
        match {
        | real(d.kind.prim()):
            ret self.eval_prim_static(d.kind.prim().to_str(), si.ident)

        | real(d.kind.enm()):
            ret self.eval_enum_static(d.kind.enm(), si.ident)

        | real(d.kind.strct()):
            ret self.eval_struct_static(d.kind.strct(), si.ident)

        |:
            self.push_err(si.ident, LogMsg.TypeNotSupportSubFields, d.kind.to_str())
            ret new(Data)
        }
    }

    fn eval_obj_sub_ident(mut self, mut d: &Data, mut si: &SubIdentExpr): &Data {
        let mut kind = d.kind
        if real(d.kind.ptr()) {
            let ptr = d.kind.ptr()
            if !ptr.is_unsafe() {
                if !si.is_self && !self.is_unsafe() {
                    self.push_err(si.ident, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
                }
                kind = d.kind.ptr().elem
            }
        } else if real(d.kind.ref()) {
            kind = d.kind.ref().elem
        }

        match {
        | real(d.kind.trt()):
            ret self.eval_trait_sub_ident(d, d.kind.trt(), si.ident)

        | real(kind.strct()):
            let s = kind.strct()
            if is_instanced_struct(s) {
                let mut used_reference_elem = real(d.kind.ref())
                ret self.eval_struct_sub_ident(d, kind.strct(), si, used_reference_elem)
            }

        | real(kind.slc()):
            ret self.eval_slice_sub_ident(d, si.ident)

        | real(kind.arr()):
            ret self.eval_array_sub_ident(d, si.ident)

        | real(kind.map()):
            ret self.eval_map_sub_ident(d, si.ident)

        | real(kind.prim()):
            let p = kind.prim()
            match p.kind {
            | str(PrimKind.Str):
                ret self.eval_str_sub_ident(d, si.ident)
            }
        }

        self.push_err(si.ident, LogMsg.ObjNotSupportSubFields, d.kind.to_str())
        ret new(Data)
    }

    fn eval_sub_ident(mut &self, mut si: &SubIdentExpr): &Data {
        let mut prefix = self.prefix
        drop(self.prefix)
        defer { self.prefix = prefix }

        let mut d = self.eval_expr_kind(si.expr)
        if !real(d) {
            ret new(Data)
        }

        if d.decl {
            ret self.eval_type_static(d, si)
        }

        ret self.eval_obj_sub_ident(d, si)
    }

    fn eval_tuple(mut &self, mut tup: &TupleExpr): &Data {
        let mut tup_t = &Tuple{}
        tup_t.types = make([]&TypeKind, tup.expr.len)

        let mut model = &TupleExprModel{
            datas: make([]&Data, tup.expr.len),
        }

        let mut ok = true
        for (i, mut expr) in tup.expr {
            let mut d = self.eval_expr_kind(expr.kind)
            if !real(d) {
                ok = false
                continue
            }
            tup_t.types[i] = d.kind
            model.datas[i] = d
        }

        if !ok {
            ret new(Data)
        }

        ret &Data{
            kind:  &TypeKind{kind: tup_t},
            model: model,
        }
    }

    fn eval_map(mut &self, mut m: &Map, mut lit: &BraceLit): &Data {
        let mut model = &MapExprModel{
            key_kind: m.key,
            val_kind: m.val,
        }

        for (_, mut expr) in lit.exprs {
            match type expr {
            | &KeyValPair:
                // Ok.

            |:
                self.push_err(lit.token, LogMsg.InvalidSyntax)
                ret new(Data)
            }

            let mut pair = (&KeyValPair)(expr)

            let mut key = self.eval_expr_kind(pair.key)
            if !real(key) {
                ret new(Data)
            }

            let mut val = self.eval_expr_kind(pair.val)
            if !real(val) {
                ret new(Data)
            }

            self.s.check_assign_type(false, m.key, key, pair.colon, true)
            self.s.check_assign_type(false, m.val, val, pair.colon, true)

            model.entries = append(model.entries, &KeyValPairExprModel{
                key: key.model,
                val: val.model,
            })
        }

        ret &Data{
            mutable:    true,
            lvalue:     false,
            variadiced: false,
            decl:       false,
            kind:       &TypeKind{kind: m},
            model:      model,
        }
    }

    fn eval_brace_lit(mut &self, mut lit: &BraceLit): &Data {
        match {
        | !real(self.prefix):
            self.push_err(lit.token, LogMsg.InvalidSyntax)
            ret new(Data)

        | real(self.prefix.map()):
            ret self.eval_map(self.prefix.map(), lit)

        | real(self.prefix.strct()):
            ret self.eval_struct_lit_explicit(self.prefix.strct(), lit.exprs, lit.token)

        |:
            self.push_err(lit.token, LogMsg.InvalidSyntax)
            ret new(Data)
        }
    }

    fn eval_anon_fn(mut self, mut decl: &FnDecl): &Data {
        let mut tc = TypeChecker{
            s:      self.s,
            lookup: self.lookup,
        }
        let mut ins = tc.build_fn(decl)
        ins.anon = true

        match type self.lookup {
        | &ScopeChecker:
            let mut sc = (&ScopeChecker)(self.lookup)
            let mut scc = sc.new_child_checker()
            scc.labels = new([]&ScopeLabel, nil)
            scc.gotos = new([]&ScopeGoto, nil)
            drop(scc.owner)
            scc.child_index = 0
            scc.it = 0
            scc.cse = 0
            scc.owner = ins
            self.s.check_fn_ins_sc(ins, scc)

        |:
            self.s.check_fn_ins(ins)
        }

        ret &Data{
            kind: &TypeKind{kind: ins},
            model: &AnonFnExprModel{
                func:   ins,
                global: self.is_global(),
            },
        }
    }

    fn eval_binop(mut &self, mut op: &BinopExpr): &Data {
        let mut prefix = self.prefix
        drop(self.prefix)
        defer { self.prefix = prefix }

        let mut bs = BinopSolver{
            e: self,
        }
        ret bs.solve(op)
    }

    fn eval_ternary(mut &self, mut ter: &TernaryExpr): &Data {
        let mut d = self.eval_expr_kind(ter.condition)
        if !real(d) {
            ret new(Data)
        }

        let prim = d.kind.prim()
        if !real(prim) || !prim.is_bool() {
            self.push_err(ter.token, LogMsg.IfRequireBoolExpr)
            ret new(Data)
        }

        let mut td = self.eval_expr_kind(ter.true_expr)
        if !real(td) {
            ret new(Data)
        }

        if td.kind.void() {
            self.push_err(ter.token, LogMsg.VoidUsedForTernary)
            ret new(Data)
        }

        let mut prefix = self.prefix
        self.prefix = td.kind

        let mut fd = self.eval_expr_kind(ter.false_expr)

        self.prefix = prefix
        if !real(fd) {
            ret new(Data)
        }

        let mut ac = AssignTypeChecker{
            s:           self.s,
            error_token: ter.token,
        }
        if td.is_const() && !fd.is_const() {
            ac.dest = fd.kind
            ac.d = td
        } else {
            ac.dest = td.kind
            ac.d = fd
        }
        if !ac.check() {
            self.push_suggestion(LogMsg.UseCompatibleValuesForTernary)
        }

        if d.is_const() {
            if d.constant.read_bool() {
                ret td
            }
            ret fd
        }

        let mut r = &Data{}
        r.kind = ac.dest
        r.lvalue = r.kind.lvalue()
        r.mutable = r.kind.mutable()
        r.model = &TernaryExprModel{
            condition:  d.model,
            true_expr:  td.model,
            false_expr: fd.model,
        }
        ret r
    }

    fn eval_expr_kind(mut &self, mut kind: ExprData): &Data {
        let mut d = new(Data)

        match type kind {
        | &LitExpr:         d = self.eval_lit((&LitExpr)(kind))
        | &IdentExpr:       d = self.eval_ident((&IdentExpr)(kind))
        | &UnaryExpr:       d = self.eval_unary((&UnaryExpr)(kind))
        | &VariadicExpr:    d = self.eval_variadic((&VariadicExpr)(kind))
        | &UnsafeExpr:      d = self.eval_unsafe((&UnsafeExpr)(kind))
        | &SliceExpr:       d = self.eval_slice_expr((&SliceExpr)(kind))
        | &IndexingExpr:    d = self.eval_indexing((&IndexingExpr)(kind))
        | &SlicingExpr:     d = self.eval_slicing((&SlicingExpr)(kind))
        | &CastExpr:        d = self.eval_cast((&CastExpr)(kind))
        | &NsSelectionExpr: d = self.eval_ns_selection((&NsSelectionExpr)(kind))
        | &StructLit:       d = self.eval_struct_lit((&StructLit)(kind))
        | &TypeDecl:        d = self.eval_type((&TypeDecl)(kind))
        | &FnCallExpr:      d = self.eval_fn_call((&FnCallExpr)(kind))
        | &SubIdentExpr:    d = self.eval_sub_ident((&SubIdentExpr)(kind))
        | &TupleExpr:       d = self.eval_tuple((&TupleExpr)(kind))
        | &BraceLit:        d = self.eval_brace_lit((&BraceLit)(kind))
        | &FnDecl:          d = self.eval_anon_fn((&FnDecl)(kind))
        | &BinopExpr:       d = self.eval_binop((&BinopExpr)(kind))
        | &TernaryExpr:     d = self.eval_ternary((&TernaryExpr)(kind))
        |:                  drop(d)
        }

        if !real(d) {
            ret new(Data)
        }

        if !real(d.kind) {
            ret d
        }

        if !real(d.cast_kind) && d.is_const() && !d.is_rune && real(d.kind.prim()) {
            match {
            | d.constant.is_i64():
                if int_assignable(str(PrimKind.Int), d) {
                    d.kind.kind = build_prim_type(str(PrimKind.Int))
                    d.constant.set_i64(d.constant.as_i64())
                }

            | d.constant.is_u64():
                if int_assignable(str(PrimKind.Uint), d) {
                    d.kind.kind = build_prim_type(str(PrimKind.Uint))
                    d.constant.set_u64(d.constant.as_u64())
                }
            }
        }

        if !d.decl {
            if !d.kind.cpp_linked() &&
                real(self.prefix) &&
                !real(d.cast_kind) &&
                !d.variadiced &&
                !d.lvalue &&
                !d.is_const() &&
                real(d.kind.prim()) &&
                types::is_num(d.kind.prim().kind) {
                d.cast_kind = d.kind
            }

            apply_cast_kind(d)

            if !real(d.kind.prim()) || !d.kind.prim().is_any() {
                if real(self.prefix) && real(self.prefix.prim()) && self.prefix.prim().is_any() {
                    d.cast_kind = self.prefix
                    apply_cast_kind_model(d)
                    drop(d.cast_kind)
                }
            }
        }

        ret d
    }

    // Returns value data of evaluated expression.
    // Returns nil if error occurs.
    fn eval(mut &self, mut expr: &Expr): &Data {
        let mut d = self.eval_expr_kind(expr.kind)
        if !real(d) || !real(d.kind) {
            ret new(Data)
        }

        match {
        | real(d.kind.fnc()):
            let mut f = d.kind.fnc()
            if f.is_builtin() {
                break
            }

            if f.generics.len != f.decl.generics.len {
                self.s.push_err(expr.token, LogMsg.HasGenerics)
            }

            if f.decl.is_method() {
                self.s.push_err(expr.token, LogMsg.MethodNotInvoked)
            }
        }

        ret d
    }

    // Returns value data of evaluated expression.
    // Returns nil if error occurs.
    // Accepts decls as invalid expression.
    fn eval_expr(mut &self, mut expr: &Expr): &Data {
        let mut d = self.eval(expr)
        match {
        | !real(d):
            ret new(Data)

        | d.decl:
            self.push_err(expr.token, LogMsg.InvalidExpr)
            ret new(Data)

        |:
            ret d
        }
    }
}

struct BinopSolver {
    e:  &Eval
    l:  &Data
    r:  &Data
    op: Token
}

impl BinopSolver {
    fn check_type_compatibility(mut self): bool {
        let mut tcc = TypeCompatibilityChecker{
            s:           self.e.s,
            error_token: self.op,
            dest:        self.l.kind,
            src:         self.r.kind,
            deref:       true,
        }
        ret tcc.check()
    }

    fn eval_nil(mut self): &Data {
        if !self.r.kind.nil_compatible() {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, str(TokenKind.Nil), self.r.kind.to_str())
            ret new(Data)
        }

        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, str(TokenKind.Nil))
            ret new(Data)
        }
    }

    fn eval_enum(mut self): &Data {
        let mut enm = self.l.kind.enm()
        if !real(self.r.kind.enm()) || &enm != &self.r.kind.enm() {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, enm.ident, self.r.kind.to_str())
            ret new(Data)
        }

        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }

        | str(TokenKind.Amper)
        | str(TokenKind.Vline):
            if !real(enm.kind.kind.prim()) || !types::is_int(enm.kind.kind.prim().to_str()) {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, enm.ident)
            }
            ret self.l

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, enm.ident)
            ret new(Data)
        }
    }

    fn eval_ptr(mut self): &Data {
        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq)
        | str(TokenKind.Lt)
        | str(TokenKind.Gt)
        | str(TokenKind.LessEq)
        | str(TokenKind.GreatEq):
            if !self.check_type_compatibility() {
                self.e.push_err(self.op, LogMsg.IncompatibleTypes, self.l.kind.to_str(), self.r.kind.to_str())
                ret new(Data)
            }
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }

        | str(TokenKind.Plus)
        | str(TokenKind.Minus):
            if !real(self.l.kind.ptr()) {
                self.l, self.r = self.r, self.l
            }
            if self.l.kind.ptr().is_unsafe() {
                self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            }
            if !is_ptr_arithmetic_compatible_int(self.r) {
                self.e.push_err(self.op, LogMsg.IncompatibleTypeForPtrArithmetic, self.r.kind.to_str())
                ret new(Data)
            }
            ret self.l

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret new(Data)
        }
    }

    fn eval_arr(mut self): &Data {
        if !self.check_type_compatibility() {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, self.l.kind.to_str(), self.r.kind.to_str())
            ret new(Data)
        }

        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret new(Data)
        }
    }

    fn eval_slc(mut self): &Data {
        if !self.check_type_compatibility() {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, self.l.kind.to_str(), self.r.kind.to_str())
            ret new(Data)
        }

        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret new(Data)
        }
    }

    fn eval_fn(mut self): &Data {
        if !self.check_type_compatibility() {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, self.l.kind.to_str(), self.r.kind.to_str())
            ret new(Data)
        }

        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret new(Data)
        }
    }

    fn eval_struct(mut self): &Data {
        if !self.check_type_compatibility() {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, self.l.kind.to_str(), self.r.kind.to_str())
            ret new(Data)
        }

        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret new(Data)
        }
    }

    fn eval_trait(mut self): &Data {
        if !self.check_type_compatibility() {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, self.l.kind.to_str(), self.r.kind.to_str())
            ret new(Data)
        }

        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret new(Data)
        }
    }

    fn eval_any(mut self): &Data {
        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, str(PrimKind.Any))
            ret new(Data)
        }
    }

    fn eval_bool(mut self): &Data {
        if !self.check_type_compatibility() {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, self.l.kind.to_str(), self.r.kind.to_str())
            ret new(Data)
        }

        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq)
        | str(TokenKind.DblAmper)
        | str(TokenKind.DblVline):
            ret self.l

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, self.l.kind.to_str())
            ret new(Data)
        }
    }

    fn eval_str(mut self): &Data {
        let mut rk = self.r.kind.to_str()
        if rk != str(PrimKind.Str) {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, self.l.kind.to_str(), rk)
            ret new(Data)
        }

        match self.op.kind {
        | str(TokenKind.Plus):
            ret self.l

        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, str(PrimKind.Any))
            ret new(Data)
        }
    }

    fn set_type_to_greater(mut self) {
        if self.l.is_const() && self.r.is_const() || !self.l.is_const() && !self.r.is_const() {
            let lk = self.l.kind.to_str()
            let rk = self.r.kind.to_str()
            if types::is_greater(rk, lk) {
                self.l.kind = self.r.kind
            }
            ret
        }

        if self.l.is_const() {
            self.l.kind = self.r.kind
            ret
        }

        self.r.kind = self.l.kind
    }

    fn check_mod_data(mut self, mut d: &Data) {
        if !d.is_const() {
            if !real(d.kind.prim()) || !types::is_int(d.kind.prim().kind) {
                self.e.push_err(self.op, LogMsg.ModuloWithNotInt)
            }
            ret
        }

        match {
        | sig_assignable(str(PrimKind.I64), d):
            d.constant.set_i64(d.constant.as_i64())

        | unsig_assignable(str(PrimKind.U64), d):
            d.constant.set_u64(d.constant.as_u64())

        |:
            self.e.push_err(self.op, LogMsg.ModuloWithNotInt)
        }
    }

    fn mod(mut self) {
        self.check_mod_data(self.l)
        self.check_mod_data(self.r)
    }

    fn numbers_are_compatibile(self, &lk: str, &rk: str): bool {
        if self.l.is_const() {
            ret true
        }

        if lk == str(types::TypeKind.F32) {
            if self.r.is_const() {
                ret true
            }
            ret rk == str(types::TypeKind.F32)
        }
        if lk == str(types::TypeKind.F64) {
            if self.r.is_const() {
                ret true
            }
            ret rk == str(types::TypeKind.F64)
        }

        if self.r.is_const() {
            if !self.r.constant.is_f64() {
                ret true
            }

            // Truncate only literals.
            // Skip castings.
            match type self.r.model {
            | &Const:
                ret int_assignable(str(types::TypeKind.Int), self.r) ||
                    int_assignable(str(types::TypeKind.Uint), self.r)

            |:
                ret false
            }
        }

        ret !types::is_float(rk)
    }

    fn eval_float(mut self): &Data {
        let lk = self.l.kind.to_str()
        let rk = self.r.kind.to_str()
        if !self.numbers_are_compatibile(lk, rk) {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, lk, rk)
            ret new(Data)
        }

        // Logicals.
        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq)
        | str(TokenKind.Lt)
        | str(TokenKind.Gt)
        | str(TokenKind.GreatEq)
        | str(TokenKind.LessEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }
        }

        // Arithmetics.
        match self.op.kind {
        | str(TokenKind.Plus)
        | str(TokenKind.Minus)
        | str(TokenKind.Star)
        | str(TokenKind.Solidus):
            self.set_type_to_greater()
            ret self.l

        | str(TokenKind.Percent):
            if !types::is_int(rk) {
                self.e.push_err(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret new(Data)
            }
            self.mod()
            ret self.r

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForFloat, self.op.kind)
            ret new(Data)
        }
    }

    fn eval_unsig_int(mut self): &Data {
        let lk = self.l.kind.to_str()
        let rk = self.r.kind.to_str()
        if !self.numbers_are_compatibile(lk, rk) {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, lk, rk)
            ret new(Data)
        }

        // Logicals.
        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq)
        | str(TokenKind.Lt)
        | str(TokenKind.Gt)
        | str(TokenKind.GreatEq)
        | str(TokenKind.LessEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }
        }

        // Arithmetics.
        match self.op.kind {
        | str(TokenKind.Plus)
        | str(TokenKind.Minus)
        | str(TokenKind.Star)
        | str(TokenKind.Solidus)
        | str(TokenKind.Amper)
        | str(TokenKind.Vline)
        | str(TokenKind.Caret):
            self.set_type_to_greater()
            ret self.l

        | str(TokenKind.Percent):
            self.mod()
            self.set_type_to_greater()
            ret self.l

        | str(TokenKind.Lshift)
        | str(TokenKind.Rshift):
            if !is_ok_for_shifting(self.r) {
                self.e.push_err(self.op, LogMsg.BitShiftMustUnsigned)
                ret new(Data)
            }

            if self.l.is_const() {
                self.l.kind = self.r.kind
            }

            ret self.l

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForUint, self.op.kind)
            ret new(Data)
        }
    }

    fn eval_sig_int(mut self): &Data {
        let lk = self.l.kind.to_str()
        let rk = self.r.kind.to_str()
        if !self.numbers_are_compatibile(lk, rk) {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, lk, rk)
            ret new(Data)
        }

        // Logicals.
        match self.op.kind {
        | str(TokenKind.Eqs)
        | str(TokenKind.NotEq)
        | str(TokenKind.Lt)
        | str(TokenKind.Gt)
        | str(TokenKind.GreatEq)
        | str(TokenKind.LessEq):
            ret &Data{
                kind: &TypeKind{
                    kind: build_prim_type(str(PrimKind.Bool)),
                },
            }
        }

        // Arithmetics.
        match self.op.kind {
        | str(TokenKind.Plus)
        | str(TokenKind.Minus)
        | str(TokenKind.Star)
        | str(TokenKind.Solidus)
        | str(TokenKind.Amper)
        | str(TokenKind.Vline)
        | str(TokenKind.Caret):
            self.set_type_to_greater()
            ret self.l

        | str(TokenKind.Percent):
            self.mod()
            self.set_type_to_greater()
            ret self.l

        | str(TokenKind.Lshift)
        | str(TokenKind.Rshift):
            if !is_ok_for_shifting(self.r) {
                self.e.push_err(self.op, LogMsg.BitShiftMustUnsigned)
                ret new(Data)
            }

            ret self.l

        |:
            self.e.push_err(self.op, LogMsg.OperatorNotForInt, self.op.kind)
            ret new(Data)
        }
    }

    fn eval_prim(mut self): &Data {
        let prim = self.l.kind.prim()
        match {
        | prim.is_any():  ret self.eval_any()
        | prim.is_bool(): ret self.eval_bool()
        | prim.is_str():  ret self.eval_str()
        }

        let rprim = self.r.kind.prim()
        if !real(rprim) {
            self.e.push_err(self.op, LogMsg.IncompatibleTypes, prim.to_str(), self.r.kind.to_str())
            ret new(Data)
        }

        let lk = prim.to_str()
        match {
        | types::is_float(lk):     ret self.eval_float()
        | types::is_unsig_int(lk): ret self.eval_unsig_int()
        | types::is_sig_int(lk):   ret self.eval_sig_int()
        |:                         ret new(Data)
        }
    }

    fn eval(mut self): &Data {
        match {
        | self.l.kind.void():
            self.e.push_err(self.op, LogMsg.OperatorNotForJuleType, self.op.kind, "void")
            ret new(Data)

        | self.l.kind.is_nil():
            ret self.eval_nil()

        | real(self.l.kind.enm()):
            ret self.eval_enum()

        | real(self.l.kind.ptr()) || real(self.r.kind.ptr()):
            ret self.eval_ptr()

        | real(self.l.kind.arr()):
            ret self.eval_arr()

        | real(self.l.kind.slc()):
            ret self.eval_slc()

        | real(self.l.kind.fnc()):
            ret self.eval_fn()

        | real(self.l.kind.trt()) || real(self.r.kind.trt()):
            if real(self.r.kind.trt()) {
                self.l, self.r = self.r, self.l
            }
            ret self.eval_trait()

        | real(self.l.kind.strct()):
            ret self.eval_struct()

        | real(self.l.kind.prim()):
            ret self.eval_prim()

        |:
            ret new(Data)
        }
    }

    fn solve_const(mut self, mut d: &Data) {
        match {
        | !real(d):
            ret

        | !self.l.is_const()
        | !self.r.is_const():
            drop(d.constant)
            ret
        }

        match self.op.kind {
        | str(TokenKind.Eqs):
            d.constant = Const.new_bool(self.l.constant.eqs(self.r.constant))

        | str(TokenKind.NotEq):
            d.constant = Const.new_bool(!self.l.constant.eqs(self.r.constant))

        | str(TokenKind.DblColon):
            d.constant = Const.new_bool(self.l.constant.or(self.r.constant))

        | str(TokenKind.DblAmper):
            d.constant = Const.new_bool(self.l.constant.and(self.r.constant))

        | str(TokenKind.Gt):
            d.constant = Const.new_bool(self.l.constant.gt(self.r.constant))

        | str(TokenKind.Lt):
            d.constant = Const.new_bool(self.l.constant.lt(self.r.constant))

        | str(TokenKind.GreatEq):
            d.constant = Const.new_bool(self.l.constant.gt(self.r.constant) || self.l.constant.eqs(self.r.constant))

        | str(TokenKind.LessEq):
            d.constant = Const.new_bool(self.l.constant.lt(self.r.constant) || self.l.constant.eqs(self.r.constant))

        | str(TokenKind.Plus):
            _ = self.l.constant.add(self.r.constant)
            d.constant = self.l.constant

        | str(TokenKind.Minus):
            _ = self.l.constant.sub(self.r.constant)
            d.constant = self.l.constant

        | str(TokenKind.Star):
            _ = self.l.constant.mul(self.r.constant)
            d.constant = self.l.constant

        | str(TokenKind.Solidus):
            let ok = self.l.constant.div(self.r.constant)
            if !ok && self.r.constant.as_f64() == 0 {
                self.e.push_err(self.op, LogMsg.DivByZero)
            }
            d.constant = self.l.constant

        | str(TokenKind.Percent):
            let ok = self.l.constant.mod(self.r.constant)
            if !ok && self.r.constant.as_f64() == 0 {
                self.e.push_err(self.op, LogMsg.DivByZero)
            }
            d.constant = self.l.constant

        | str(TokenKind.Vline):
            _ = self.l.constant.bitwise_or(self.r.constant)
            d.constant = self.l.constant

        | str(TokenKind.Amper):
            _ = self.l.constant.bitwise_and(self.r.constant)
            d.constant = self.l.constant

        | str(TokenKind.Caret):
            _ = self.l.constant.xor(self.r.constant)
            d.constant = self.l.constant

        | str(TokenKind.Lshift):
            _ = self.l.constant.lshift(self.r.constant)
            d.constant = self.l.constant

        | str(TokenKind.Rshift):
            _ = self.l.constant.rshift(self.r.constant)
            d.constant = self.l.constant
        }

        d.model = d.constant
    }

    fn post_const(self, mut d: &Data) {
        if !real(d) {
            ret
        }

        normalize_bitsize(d)
    }

    fn prepare_data(self, mut d: &Data) {
        if real(d) && real(d.kind.ref()) {
            d.kind = d.kind.ref().elem
        }
    }

    fn prepare_eval(mut self) {
        self.prepare_data(self.r)
        self.prepare_data(self.l)
    }

    fn check_data(mut self, mut d: &Data) {
        let f = d.kind.fnc()
        if real(f) && real(f.decl) && f.decl.is_method() {
            self.e.push_err(self.op, LogMsg.InvalidExprForBinop)
        }
    }

    fn check_datas(mut self) {
        self.check_data(self.l)
        self.check_data(self.r)
    }

    fn solve_explicit(mut self, mut l: &Data, mut r: &Data): &Data {
        self.l, self.r = l, r

        self.prepare_eval()
        self.check_datas()

        let mut d = self.eval()
        self.l, self.r = l, r // Save normal order

        self.solve_const(d)
        self.post_const(d)

        if real(d) {
            d.lvalue = d.kind.lvalue()
            if !d.is_const() {
                d.model = &BinopExprModel{
                    left:  l.model,
                    right: r.model,
                    op:    self.op.kind,
                }
            }
        }

        ret d
    }

    fn solve(mut self, mut op: &BinopExpr): &Data {
        let mut l = self.e.eval_expr_kind(op.left)
        if !real(l) || !real(l.kind) {
            ret new(Data)
        }

        let mut r = self.e.eval_expr_kind(op.right)
        if !real(r) || !real(r.kind) {
            ret new(Data)
        }

        self.op = op.op

        let mut d = self.solve_explicit(l, r)

        // Save rune type.
        if real(d) && l.is_rune && r.is_rune {
            d.is_rune = true
        }

        ret d
    }
}
