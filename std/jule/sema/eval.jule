// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::unsafe
use conv for std::conv
use path for std::fs::path
use ast for std::jule::ast::{
    Expr,
    LitExpr,
    IdentExpr,
    VariadicExpr,
    UnaryExpr,
    UnsafeExpr,
    SliceExpr,
    ExprData,
    FnDecl,
    BinaryExpr,
    BraceLit,
    TupleExpr,
    SubIdentExpr,
    IndexingExpr,
    NsSelectionExpr,
    TypeDecl,
    FnCallExpr,
    SlicingExpr,
    CastExpr,
    StructLit,
    KeyValPair,
    IdentTypeDecl,
    NamespaceTypeDecl,
    SubIdentTypeDecl,
    RangeExpr,
    TypeDeclKind,
    SptrTypeDecl,
    PtrTypeDecl,
}
use build for std::jule::build::{
    LogMsg,
    Directive,
    PathStdlib,
    Logf,
}
use std::jule::constant::{Const}
use lit for std::jule::constant::lit
use lex for std::jule::lex::{
    self,
    Token,
    TokenId,
    TokenKind,
    IsStr,
    IsBool,
    IsRune,
    IsRawStr,
    IsNil,
    IsIgnoreIdent,
}
use types for std::jule::types
use mod for std::jule::internal::mod
use strings for std::strings::{StrBuilder}

// Value data.
struct Data {
    // Means data is constant numeric and have not any exact type.
    // Since data is constant numeric, it also implies kind is primitive.
    untyped: bool

    Kind:      &TypeKind
    Mutable:   bool
    Reference: bool
    Lvalue:    bool
    IsRune:    bool
    Model:     ExprModel

    // True if kind is declaration such as:
    //  - &Enum
    //  - &Struct
    //  - int type
    //  - bool type
    Decl: bool

    // Constant expression data.
    Constant: &Const
}

impl Data {
    // Reports whether Data is nil literal.
    fn IsNil(self): bool {
        ret self.Kind.IsNil()
    }

    // Reports whether Data is void.
    fn IsVoid(self): bool {
        ret self.Kind.Void()
    }

    // Reports whether Data is constant expression.
    fn IsConst(self): bool {
        ret self.Constant != nil
    }

    // Reports left and right operand is good order.
    // If reports false, left and right operand should be swapped.
    // Accepts itself as left operand.
    fn GoodOperand(self, mut &other: &Data): bool {
        if other.Kind.TypeEnum() != nil {
            ret false
        }
        ret (other.Kind.Prim() == nil || !other.Kind.Prim().IsAny()) &&
            other.Kind.Trait() == nil &&
            !self.Kind.IsNil()
    }
}

// Value.
struct Value {
    Expr: &Expr
    Data: &Data
}

// Evaluator.
struct Eval {
    s:          &Sema // Used for error logging.
    lookup:     Lookup
    prefix:     &TypeKind
    unsafety:   bool
    immutable:  bool // This expression will assigned to immutable memory.
    ignored:    bool // Evaluated expression is not for assignment or something else.
    disBuiltin: bool // Disallow/suppress Jule's built-in defines.
    owner:      &Var
    field:      &FieldIns // Field of this default expression. Used for checking cycles.
    arg:        bool      // This expression evaluating for argument.
}

impl Eval {
    fn pushErr(mut self, token: &Token, fmt: LogMsg, args: ...any) {
        self.s.pushErr(token, fmt, args...)
    }

    // Push suggestion to last log.
    fn pushSuggestion(mut self, fmt: LogMsg, args: ...any) {
        self.s.pushSuggestion(fmt, args...)
    }

    fn allowBuiltin(mut self) {
        self.disBuiltin = false
    }

    fn disallowBuiltin(mut self) {
        self.disBuiltin = true
    }

    // Reports whether evaluation in unsafe scope.
    fn isUnsafe(self): bool {
        ret self.unsafety
    }

    // Reports whether evaluated expression is in global scope.
    fn isGlobal(self): bool {
        match type self.lookup {
        | &Sema:
            ret true
        |:
            ret false
        }
    }

    fn applyNumericPrefix(mut self, mut &d: &Data): bool {
        if d == nil ||
            !d.IsConst() ||
            d.Kind.Prim() == nil ||
            self.prefix == nil {
            ret false
        }
        prim := self.prefix.Prim()
        if prim == nil {
            ret false
        }

        match {
        | types::IsFloat(prim.Str()):
            d.Kind = new(TypeKind, *self.prefix)
            d.Constant.SetF64(d.Constant.AsF64())
            d.Constant.Kind = prim.Kind
        | types::IsSigInt(prim.Str()):
            if !sigAssignable(prim.Str(), d) {
                ret false
            }
            d.Kind = new(TypeKind, *self.prefix)
            d.Constant.SetI64(d.Constant.AsI64())
            d.Constant.Kind = prim.Kind
        | types::IsUnsigInt(prim.Str()):
            if !unsigAssignable(prim.Str(), d) {
                ret false
            }
            d.Kind = new(TypeKind, *self.prefix)
            d.Constant.SetU64(d.Constant.AsU64())
            d.Constant.Kind = prim.Kind
        }
        ret true
    }

    fn litStr(self, &l: &LitExpr): &Data {
        mut s := ""
        if IsRawStr(l.Value) {
            s = lit::ToRawStr(l.Value)
        } else {
            s = lit::ToStr(l.Value)
        }
        mut constant := Const.NewStr(s)

        ret &Data{
            Mutable: true,
            Constant: constant,
            Kind: primStr,
            Model: constant,
        }
    }

    fn litRune(self, &l: &LitExpr): &Data {
        r := lit::ToRune(l.Value)
        mut data := &Data{
            Constant: Const.NewI64(i64(r)),
        }

        isAscii := lit::IsAscii(r)
        if isAscii {
            data.Kind = primU8 // Byte
        } else {
            data.Kind = primI32 // Rune
        }

        data.Model = &RuneExprModel{Code: r}
        data.Mutable = true
        data.IsRune = true
        data.untyped = true
        ret data
    }

    fn litFloat(self, &l: &LitExpr): &Data {
        f := conv::ParseFloat(l.Value, 64) else { use f64.Max }
        mut constant := Const.NewF64(f)
        ret &Data{
            untyped: true,
            Mutable: true,
            Constant: constant,
            Kind: primF64,
            Model: constant,
        }
    }

    fn litInt(mut self, &l: &LitExpr): &Data {
        const BitSize = 1 << 6

        mut lit := l.Value
        mut base := 0

        match {
        | strings::HasPrefix(lit, "0x"): // Hexadecimal
            lit = lit[2:]
            base = 1 << 4
        | strings::HasPrefix(lit, "0b"): // Binary
            lit = lit[2:]
            base = 1 << 1
        | strings::HasPrefix(lit, "0o"): // Ocatal
            lit = lit[2:]
            base = 1 << 3
        | lit[0] == '0' && len(lit) > 1: // Octal
            lit = lit[1:]
            base = 1 << 3
        |:
            // Decimal
            base = 1 << 3 + 2
        }

        mut d := new(Data)

        mut ok := true
        sig := conv::ParseInt(lit, base, BitSize) else {
            ok = false
            use 0
        }
        if ok {
            d.Constant = Const.NewI64(sig)
            d.Kind = primInt
        } else {
            unsig := conv::ParseUint(lit, base, BitSize) else {
                self.pushErr(l.Token, LogMsg.InvalidNumericRange)
                self.pushSuggestion(LogMsg.TryFloatingPoint)
                use u64.Max
            }
            d.Constant = Const.NewU64(unsig)
            d.Kind = primUint
        }

        d.Model = d.Constant
        d.untyped = true
        if !self.applyNumericPrefix(d) {
            // If prefix is not implemented, check constant bitsize.
            // Arcihtecture bitsize type might be insufficient to store constant data.
            // If this concern is true, set kind to minimum type that has enough bitsize.
            fitBitsize(d)
        }
        ret d
    }

    fn litNum(mut self, &l: &LitExpr): &Data {
        match {
        | lex::IsFloat(l.Value):
            ret self.litFloat(l)
        |:
            ret self.litInt(l)
        }
    }

    fn evalLit(mut self, lit: &LitExpr): &Data {
        match {
        | IsStr(lit.Value):
            ret self.litStr(lit)
        | IsRune(lit.Value):
            ret self.litRune(lit)
        | lex::IsNum(lit.Value):
            ret self.litNum(lit)
        |:
            ret nil
        }
    }

    fn findBuiltins(mut self, &ident: str): any {
        if mod::IsPub(ident) {
            match type self.lookup {
            | &ImportInfo:
                mut def := findBuiltinsImport(ident, (&ImportInfo)(self.lookup))
                if def != nil {
                    ret def
                }
            | &Sema:
                mut def := findBuiltinsSema(ident, (&Sema)(self.lookup))
                if def != nil {
                    ret def
                }
            | &scopeChecker:
                mut def := findBuiltinsSema(ident, (&scopeChecker)(self.lookup).s)
                if def != nil {
                    ret def
                }
            }
            ret nil
        }
        if self.disBuiltin {
            ret nil
        }
        ret findBuiltinDef(ident)
    }

    fn getDef(mut self, &ident: str, binded: bool): any {
        // Find variables and type aliases first.
        // Because self.lookup might be a scopeChecker, and shadowing may occurred.
        // If any variable or type aliases is shadowing other declarations such us structure,
        // it will result as wrong expression evaluation.
        mut v := self.lookup.FindVar(ident, binded)
        if v != nil {
            ret v
        }

        mut ta := self.lookup.FindTypeAlias(ident, binded)
        if ta != nil {
            ret ta
        }

        if !binded {
            mut enm := self.lookup.FindEnum(ident)
            if enm != nil {
                ret enm
            }

            mut tenm := self.lookup.FindTypeEnum(ident)
            if tenm != nil {
                ret tenm
            }
        }

        mut f := self.lookup.FindFn(ident, binded)
        if f != nil {
            ret f
        }

        mut s := self.lookup.FindStruct(ident, binded)
        if s != nil {
            ret s
        }

        ret self.findBuiltins(ident)
    }

    fn getOwnerRefers(mut self): &ReferenceStack {
        match type self.lookup {
        | &scopeChecker:
            mut sc := (&scopeChecker)(self.lookup).getHardRoot()
            ret sc.owner.Refers
        |:
            // Push reference to owner if global.
            if self.owner != nil &&
                self.owner.Scope == nil {
                ret self.owner.Refers
            }
        }
        ret nil
    }

    fn pushReference[T](mut self, mut &ref: T) {
        mut refers := self.getOwnerRefers()
        if refers != nil && !refers.Exist[T](ref) {
            refers.Push(ref)
        }
    }

    fn _evalEnum(self, mut enm: &Enum): &Data {
        ret &Data{
            Decl: true,
            Kind: &TypeKind{
                Kind: enm,
            },
        }
    }

    fn evalEnum(mut self, mut enm: &Enum, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(enm.Public, enm.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, enm.Ident)
            self.pushSuggestion(LogMsg.MakePubToAccess)
            ret nil
        }
        ret self._evalEnum(enm)
    }

    fn _evalTypeEnum(self, mut enm: &TypeEnum): &Data {
        ret &Data{
            Decl: true,
            Kind: &TypeKind{
                Kind: enm,
            },
        }
    }

    fn evalTypeEnum(mut self, mut enm: &TypeEnum, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(enm.Public, enm.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, enm.Ident)
            self.pushSuggestion(LogMsg.MakePubToAccess)
            ret nil
        }
        ret self._evalTypeEnum(enm)
    }

    fn _evalStruct(self, mut s: &StructIns): &Data {
        mut d := &Data{
            Decl: true,
            Kind: &TypeKind{
                Kind: s,
            },
            Model: s,
        }
        if s.Decl != nil && s.Decl.Binded {
            d.Kind.BindIdent = s.Decl.Ident
        }
        ret d
    }

    fn evalStruct(mut self, mut s: &StructIns, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(s.Decl.Public, s.Decl.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, s.Decl.Ident)
            self.pushSuggestion(LogMsg.MakePubToAccess)
            ret nil
        }
        self.checkDeprecated(s.Decl.Directives, errorToken)
        ret self._evalStruct(s)
    }

    fn evalFnIns(self, mut f: &FnIns): &Data {
        ret &Data{
            Kind: &TypeKind{
                Kind: f,
            },
            Model: f,
        }
    }

    fn checkDeprecated(mut self, mut &directives: []&ast::Directive, tok: &Token) {
        if self.isUnsafe() {
            ret
        }

        d := findDirective(directives, Directive.Deprecated)
        if d != nil {
            if len(d.Args) == 0 {
                self.pushErr(tok, LogMsg.UsingDeprecated, "this code is deprecated")
            } else {
                self.pushErr(tok, LogMsg.UsingDeprecated, d.Args[0].Kind)
            }
            self.pushSuggestion(LogMsg.UseUnsafeForDeprecated)
        }
    }

    fn evalFn(mut self, mut f: &Fn, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(f.Public, f.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, f.Ident)
            self.pushSuggestion(LogMsg.MakePubToAccess)
            ret nil
        }

        self.checkDeprecated(f.Directives, errorToken)

        mut ins := f.instance()
        self.pushReference[&FnIns](ins)
        ret self.evalFnIns(ins)
    }

    fn pushIllegalCycleError(mut self, &v1: &Var, &v2: &Var, mut &message: StrBuilder) {
        const Padding = 7
        refers_to := Logf(LogMsg.RefersTo, v1.Ident, v2.Ident)
        buf := unsafe { message.Buf() }
        message.WriteStr(strings::Repeat(" ", Padding))
        message.WriteStr(refers_to)
        message.WriteByte('\n')
        message.Write(buf)
    }

    fn checkCrossCycle(mut self, &v: &Var, mut &message: StrBuilder): bool {
        for _, d in v.Depends {
            if d == self.owner {
                self.pushIllegalCycleError(v, d, message)
                ret false
            }
            if !self.checkCrossCycle(d, message) {
                self.pushIllegalCycleError(v, d, message)
                ret false
            }
        }
        ret true
    }

    // Checks owner illegal cycles.
    // Appends depend to depends if there is no illegal cycle.
    // Returns true if e.owner is nil.
    fn checkIllegalCycles(mut self, mut &v: &Var, declToken: &Token): (ok: bool) {
        // Skip cycle checking if owner is nil or not global.
        if self.owner == nil || self.owner.Scope != nil {
            ret true
        }

        // Check illegal cycle for itself.
        // Because refers's owner is ta.
        if self.owner == v {
            self.pushErr(self.owner.Token, LogMsg.IllegalCycleRefersItself, self.owner.Ident)
            ret false
        }

        mut message := StrBuilder.New(1 << 5)

        if !self.checkCrossCycle(v, message) {
            mut errMsg := message.Str()
            message.Clear()
            self.pushIllegalCycleError(self.owner, v, message)
            errMsg += message.Str()
            self.pushErr(declToken, LogMsg.IllegalCrossCycle, errMsg)
            ret false
        }

        self.owner.Depends = append(self.owner.Depends, v)
        ret true
    }

    fn evalVar(mut self, mut v: &Var, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(v.Public, v.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, v.Ident)
            self.pushSuggestion(LogMsg.MakePubToAccess)
            ret nil
        }

        self.checkDeprecated(v.Directives, errorToken)

        if v.Token == nil {
            // Variable is built-in.
            goto data
        }

        v.Used = true

        match type self.lookup {
        | &Sema:
            // Check cycles for global scope.
            ok := self.checkIllegalCycles(v, errorToken)
            if !ok {
                ret nil
            }
        | &scopeChecker:
            if !v.Reference || self.isUnsafe() {
                break
            }
            mut s := (&scopeChecker)(self.lookup)
            for s.owner == nil && s.parent != nil {
                s = s.parent
            }
            if s.owner != nil && s.owner.Anon && v.Scope != s.owner.Scope {
                self.pushErr(errorToken, LogMsg.UsedRefInAnonFnFromParentScope, v.Ident)
            }
        }

        // Push reference to global variable.
        if v.Scope == nil {
            self.pushReference[&Var](v)
        }

        if !v.Binded && (v.Value == nil || v.Value.Data == nil) {
            if v.Constant {
                // Eval constant dependent variable.
                self.s.checkVar(v, self.s)
                if v.Value == nil || v.Value.Data == nil {
                    // Skip error.
                    ret nil
                }
            }
        }

        // Kind is nil, no determined.
        // In other word, not analyzed yet.
        // But this variable is dependency, therefore check this for eval.
        if v.Kind == nil || v.Kind.Kind == nil {
            // Just necessary for global scope, therefore
            // execute if only scope is nil aka variable is not in global scope.
            if v.Scope != nil {
                ret nil
            }

            self.s.checkVar(v, self.lookup)

            // Ignore eval, because analyze is failed.
            if v.Kind == nil || v.Kind.Kind == nil {
                ret nil
            }
        }

    data:
        mut d := &Data{
            Lvalue: !v.Constant,
            Mutable: v.Mutable,
            Reference: v.Reference,
            Kind: v.Kind.Kind,
            Model: v,
        }

        if !v.Binded && v.IsInitialized() && v.Value.Data != nil {
            d.IsRune = v.Value.Data.IsRune
        }

        if v.Constant && v.Value.Data.Constant != nil {
            d.Constant = new(Const, *v.Value.Data.Constant)
            d.Model = d.Constant
            if v.untypedConstant() {
                self.applyNumericPrefix(d)
                d.untyped = true
            }
        }

        ret d
    }

    fn evalTypeAlias(mut self, mut ta: &TypeAlias, errorToken: &Token): &Data {
        if !self.s.isAccessibleDefine(ta.Public, ta.Token) {
            self.pushErr(errorToken, LogMsg.IdentIsNotAccessible, ta.Ident)
            self.pushSuggestion(LogMsg.MakePubToAccess)
            ret nil
        }

        ta.Used = true

        mut kind := ta.Kind.Kind.Kind
        let mut d: &Data = nil
        match type kind {
        | &StructIns:
            d = self._evalStruct((&StructIns)(kind))
        | &Enum:
            d = self._evalEnum((&Enum)(kind))
        | &TypeEnum:
            d = self._evalTypeEnum((&TypeEnum)(kind))
        |:
            d = &Data{
                Decl: true,
                Kind: &TypeKind{
                    Kind: ta.Kind.Kind.Kind,
                },
            }
            if ta.Binded {
                d.Kind.BindIdent = ta.Ident
            } else {
                d.Kind.BindIdent = ta.Kind.Kind.BindIdent
            }
            d.Model = d.Kind
        }
        d.Kind.Generic = ta.Generic
        ret d
    }

    fn evalDef(mut self, mut &def: any, ident: &Token): &Data {
        match type def {
        | &Var:
            ret self.evalVar((&Var)(def), ident)
        | &Enum:
            ret self.evalEnum((&Enum)(def), ident)
        | &TypeEnum:
            ret self.evalTypeEnum((&TypeEnum)(def), ident)
        | &Struct:
            ret self.evalStruct((&Struct)(def).instance(), ident)
        | &Fn:
            mut f := (&Fn)(def)
            if f.Ident != build::InitFn {
                ret self.evalFn(f, ident)
            }
        | &FnIns:
            ret self.evalFnIns((&FnIns)(def))
        | &TypeAlias:
            ret self.evalTypeAlias((&TypeAlias)(def), ident)
        }
        self.pushErr(ident, LogMsg.IdentNotExist, ident.Kind)
        ret nil
    }

    fn evalIdent(mut self, ident: &IdentExpr): &Data {
        mut def := self.getDef(ident.Ident, ident.Binded)
        ret self.evalDef(def, ident.Token)
    }

    fn evalUnary(mut &self, mut u: &UnaryExpr): &Data {
        mut unary := unaryEval.new(self)
        ret unary.eval(u)
    }

    fn evalVariadic(mut &self, mut v: &VariadicExpr): &Data {
        if v.Expr == nil {
            self.pushErr(v.Token, LogMsg.InvalidExpr)
            ret nil
        }

        mut prefix := self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        mut d := self.evalExpr(v.Expr)
        if d == nil {
            ret nil
        }

        if !d.Kind.Variadicable() {
            self.pushErr(v.Token, LogMsg.VariadicWithNonVariadicable, d.Kind.Str())
            ret nil
        }

        mut slc := d.Kind.Slc()
        d.Kind = &TypeKind{
            Variadic: true,
            Generic: slc.Elem.Generic,
            BindIdent: slc.Elem.BindIdent,
            Kind: slc.Elem.Kind,
        }
        ret d
    }

    fn evalUnsafe(mut &self, mut u: &UnsafeExpr): &Data {
        unsafety := self.unsafety
        self.unsafety = true
        mut d := self.evalExpr(u.Expr)
        self.unsafety = unsafety
        ret d
    }

    fn evalArr(mut &self, mut s: &SliceExpr): &Data {
        // Arrays always has type prefixes.
        mut pt := self.prefix.Arr()

        mut arr := &Arr{
            Auto: false,
            N: 0,
            Elem: pt.Elem,
        }

        mut filled := false

        if len(s.Exprs) == 2 {
            match type s.Exprs[1].Kind {
            | &VariadicExpr:
                if (&VariadicExpr)(s.Exprs[1].Kind).Expr != nil {
                    break
                }
                // Filled.

                if pt.Auto {
                    self.pushErr(s.Token, LogMsg.AutoSizedArrFilled)
                    ret nil
                }

                filled = true
                s.Exprs = s.Exprs[:1]
            }
        }

        arr.N = len(s.Exprs)
        if !pt.Auto {
            if arr.N > pt.N {
                self.pushErr(s.Token, LogMsg.OverflowLimits)
            } else if arr.N < pt.N {
                arr.N = pt.N
            }
        }

        mut model := &ArrayExprModel{
            Kind: arr,
        }
        if filled {
            model.Elems = make([]ExprModel, 0, 2)
        } else {
            model.Elems = make([]ExprModel, 0, len(s.Exprs))
        }

        mut prefix := self.prefix
        self.prefix = arr.Elem
        for (_, mut elem) in s.Exprs {
            mut d := self.evalExpr(elem)
            if d == nil {
                continue
            }
            const destIsRef = false
            if self.s.checkValidityForInitExpr(!self.immutable, destIsRef, arr.Elem, d, elem.Token) {
                _ = self.s.checkAssignType(destIsRef, arr.Elem, d, elem.Token)
            }
            model.Elems = append(model.Elems, d.Model)
        }
        self.prefix = prefix

        if filled {
            // Fill mark.
            model.Elems = append(model.Elems, nil)
        }

        ret &Data{
            Mutable: true,
            Kind: &TypeKind{
                Kind: arr,
            },
            Model: model,
        }
    }

    fn evalExpSlc(mut &self, mut s: &SliceExpr, mut t: &TypeKind, mut first: ExprModel): &Data {
        mut slc := &Slc{
            Elem: t,
        }

        mut i := 0
        mut model := &SliceExprModel{
            ElemKind: t,
            Elems: make([]ExprModel, 0, len(s.Exprs)),
        }
        if first != nil {
            model.Elems = append(model.Elems, first)
            i = 1
        }

        mut prefix := self.prefix
        self.prefix = slc.Elem
        for (_, mut elem) in s.Exprs[i:] {
            mut d := self.evalExpr(elem)
            if d != nil {
                const destIsRef = false
                if self.s.checkValidityForInitExpr(!self.immutable, destIsRef, slc.Elem, d, elem.Token) {
                    _ = self.s.checkAssignType(destIsRef, slc.Elem, d, elem.Token)
                }
                model.Elems = append(model.Elems, d.Model)
            }
        }
        self.prefix = prefix

        ret &Data{
            Mutable: true,
            Kind: &TypeKind{
                Kind: slc,
            },
            Model: model,
        }
    }

    fn evalSliceExpr(mut &self, mut s: &SliceExpr): &Data {
        if self.prefix != nil {
            match {
            | self.prefix.Arr() != nil:
                ret self.evalArr(s)
            | self.prefix.Slc() != nil:
                mut pt := self.prefix.Slc()
                ret self.evalExpSlc(s, pt.Elem, nil)
            }
        }

        mut prefix := self.prefix
        self.prefix = nil

        if len(s.Exprs) == 0 {
            self.pushErr(s.Token, LogMsg.DynamicTypeAnnotationFailed)
            ret nil
        }

        mut firstElem := self.evalExpr(s.Exprs[0])
        if firstElem == nil {
            ret nil
        }

        // Check mutability for first element.
        const destIsRef = false
        self.s.checkValidityForInitExpr(!self.immutable, destIsRef,
            firstElem.Kind, firstElem, s.Exprs[0].Token)

        mut d := self.evalExpSlc(s, firstElem.Kind, firstElem.Model)

        self.prefix = prefix
        ret d
    }

    fn checkIntegerIndexingByData(mut self, mut &d: &Data, mut token: &Token) {
        errKey := checkDataForIntegerIndexing(d, token)
        match errKey {
        | LogMsg.Empty:
            ret
        | LogMsg.InvalidTypeForIndexing:
            self.pushErr(token, errKey, d.Kind.Str())
        |:
            self.pushErr(token, errKey)
        }
    }

    fn indexingPtr(mut self, mut &d: &Data, mut &index: &Data, mut &i: &IndexingExpr) {
        self.checkIntegerIndexingByData(index, i.Token)
        d.Lvalue = true

        mut ptr := d.Kind.Ptr()
        match {
        | ptr.IsUnsafe():
            self.pushErr(i.Token, LogMsg.UnsafePtrIndexing)
            ret
        | !self.isUnsafe():
            self.pushErr(i.Token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
        }

        d.Kind = ptr.Elem
    }

    fn indexingArr(mut self, mut &d: &Data, mut &index: &Data, mut &i: &IndexingExpr) {
        mut arr := d.Kind.Arr()
        d.Kind = arr.Elem
        self.checkIntegerIndexingByData(index, i.Token)
        d.Lvalue = true
        if index.IsConst() && index.Constant.AsF64() >= f64(arr.N) {
            self.pushErr(i.Token, LogMsg.OverflowLimits)
        }
    }

    fn indexingSlc(mut self, mut &d: &Data, mut &index: &Data, mut &i: &IndexingExpr) {
        mut slc := d.Kind.Slc()
        d.Kind = slc.Elem
        self.checkIntegerIndexingByData(index, i.Token)
        d.Lvalue = true

        // Check compile-time bounds.
        if !index.IsConst() {
            ret
        }
        match type d.Model {
        | &SliceExprModel:
            mut m := (&SliceExprModel)(d.Model)
            indx := index.Constant.AsF64()
            if indx >= f64(len(m.Elems)) {
                self.pushErr(i.Token, LogMsg.OverflowLimits)
            } else {
                d.Model = m.Elems[u64(indx)]
                d.Decl = true // Set Model: flag.
            }
        }
    }

    fn indexingMap(mut self, mut &d: &Data, mut &index: &Data, mut &i: &IndexingExpr) {
        d.Lvalue = true
        if index == nil {
            ret
        }
        mut m := d.Kind.Map()
        mut atc := assignTypeChecker{
            s: self.s,
            dest: m.Key,
            d: index,
            errorToken: i.Token,
        }
        _ = atc.check()
        d.Kind = m.Val
    }

    fn indexingStr(mut self, mut &d: &Data, mut &index: &Data, mut &i: &IndexingExpr) {
        d.Kind = primU8 // Byte
        d.Mutable = false
        d.Lvalue = true

        if index == nil {
            ret
        }

        self.checkIntegerIndexingByData(index, i.Token)

        if !index.IsConst() {
            d.Constant = nil
            d.untyped = false
            ret
        }

        if d.IsConst() {
            errorToken := i.Token
            j := index.Constant.AsI64()
            s := d.Constant.ReadStr()
            if int(j) >= len(s) {
                self.pushErr(errorToken, LogMsg.OverflowLimits)
            } else {
                d.Constant.SetU64(u64(s[j]))
            }
        }
    }

    fn toIndexing(mut self, mut &d: &Data, mut &index: &Data, mut &i: &IndexingExpr) {
        match {
        | d.Kind.Ptr() != nil:
            self.indexingPtr(d, index, i)
            ret
        | d.Kind.Arr() != nil:
            self.indexingArr(d, index, i)
            ret
        | d.Kind.Slc() != nil:
            self.indexingSlc(d, index, i)
            ret
        | d.Kind.Map() != nil:
            self.indexingMap(d, index, i)
            ret
        | d.Kind.Prim() != nil:
            prim := d.Kind.Prim()
            match {
            | prim.IsStr():
                self.indexingStr(d, index, i)
                ret
            }
        }
        self.pushErr(i.Token, LogMsg.NotSupportsIndexing, d.Kind.Str())
    }

    fn pushGenericsFromExprSubIdent(mut &self, mut &sexpr: &SubIdentExpr,
        mut &generics: []&TypeDecl, mut &expr: &Expr): bool {
        mut t := new(SubIdentTypeDecl)
        if !pushSubIdentFromExpr(sexpr, t) {
            self.pushErr(expr.Token, LogMsg.InvalidSyntax)
            ret false
        }
        generics = append(generics, &TypeDecl{Kind: t})
        ret true
    }

    fn pushGenericsFromData(mut &self, mut &generics: []&TypeDecl, mut &expr: &Expr): bool {
        match type expr.Kind {
        | &UnaryExpr:
            mut u := (&UnaryExpr)(expr.Kind)
            match u.Op.Id {
            | TokenId.Star:
                mut kind := new(PtrTypeDecl)
                mut _generics := make([]&TypeDecl, 0, 1)
                self.pushGenericsFromData(_generics, u.Expr)
                kind.Elem = _generics[0]
                generics = append(generics, &TypeDecl{
                    Token: expr.Token,
                    Kind: kind,
                })
            | TokenId.Amper:
                mut kind := new(SptrTypeDecl)
                mut _generics := make([]&TypeDecl, 0, 1)
                self.pushGenericsFromData(_generics, u.Expr)
                kind.Elem = _generics[0]
                generics = append(generics, &TypeDecl{
                    Token: expr.Token,
                    Kind: kind,
                })
            |:
                self.pushErr(u.Op, LogMsg.InvalidType)
                ret false
            }
        | &TypeDecl:
            generics = append(generics, (&TypeDecl)(expr.Kind))
        | &SubIdentExpr:
            mut sexpr := (&SubIdentExpr)(expr.Kind)
            ret self.pushGenericsFromExprSubIdent(sexpr, generics, expr)
        | &IdentExpr:
            mut ident := (&IdentExpr)(expr.Kind)
            generics = append(generics, &TypeDecl{
                Kind: &IdentTypeDecl{
                    Binded: ident.Binded,
                    Token: ident.Token,
                    Ident: ident.Ident,
                },
            })
        | &TupleExpr:
            for (_, mut texpr) in (&TupleExpr)(expr.Kind).Expr {
                if !self.pushGenericsFromData(generics, texpr) {
                    ret false
                }
            }
        | &NsSelectionExpr:
            mut ns := (&NsSelectionExpr)(expr.Kind)
            mut decl := &IdentTypeDecl{
                Token: ns.Ident,
                Ident: ns.Ident.Kind,
            }
            generics = append(generics, &TypeDecl{
                Token: decl.Token,
                Kind: &NamespaceTypeDecl{
                    Idents: ns.Ns,
                    Kind: &TypeDecl{
                        Token: decl.Token,
                        Kind: decl,
                    },
                },
            })
        |:
            self.pushErr(expr.Token, LogMsg.InvalidSyntax)
            ret false
        }
        ret true
    }

    fn evalIdentDeclFromIndexing(mut &self, mut &d: &Data, mut &i: &IndexingExpr) {
        mut s := d.Kind.Struct()
        if s == nil {
            self.pushErr(i.Expr.Token, LogMsg.TypeNotSupportsGenerics, d.Kind.Str())
            d = nil
            ret
        }

        let mut decl: &IdentTypeDecl = nil
        match type i.Expr.Kind {
        | &IdentExpr:
            mut expr := (&IdentExpr)(i.Expr.Kind)
            decl = &IdentTypeDecl{
                Binded: expr.Binded,
                Token: expr.Token,
                Ident: expr.Ident,
            }
        | &NsSelectionExpr:
            mut expr := (&NsSelectionExpr)(i.Expr.Kind)
            decl = &IdentTypeDecl{
                Token: expr.Ident,
                Ident: expr.Ident.Kind,
            }
        |:
            self.pushErr(i.Token, LogMsg.InvalidSyntax)
            d = nil
            ret
        }
        if !self.pushGenericsFromData(decl.Generics, i.Index) {
            d = nil
            ret
        }

        s = self.typeChecker().fromStruct(decl, s.Decl)
        if s == nil {
            d = nil
            ret
        }
        d.Kind.Kind = s
    }

    // Checks new generics function instance.
    // If instance is already exist, f will point to exist instantantiation.
    fn checkGenericFn(mut &self, mut &f: &FnIns, mut &et: &Token, mut &model: ExprModel): bool {
        ok := self.s.reloadFnInsTypes(f)
        f.reloaded = true
        if !ok {
            ret false
        }
        mut existInstance := f.Decl.appendInstance(f)
        // TODO: [check] is possible to optimize here using same environment with realoadFnInsTypes?
        if !self.s.checkConstraintsFn(f, et, existInstance) {
            ret false
        }
        if existInstance != nil {
            // Update model and references by exist function instance.
            // Generic functions returns always new instance, because might be
            // generics are inferred. Therefore, always returns new instance for requests.
            // So, if this absolute instance is already exist, update model.
            // Otherwise, model's instance will be a dangling, because it never
            // be appended into instances of function declaration since already exist.
            updateModelToGenericIns(model, existInstance)
            updateRefer(self.getOwnerRefers(), f, existInstance)
            // Set f to exist one.
            f = existInstance
        } else {
            // Check generic function instance instantly.
            self.s.checkFnInsCaller(f, et)
        }
        ret true
    }

    fn evalFnGenericFromIndexing(mut &self, mut &d: &Data, mut &i: &IndexingExpr) {
        mut generics := make([]&TypeDecl, 0, 1 << 3)
        if !self.pushGenericsFromData(generics, i.Index) {
            d = nil
            ret
        }

        mut f := d.Kind.Fn()
        mut genericsLen := 0
        if f.Decl != nil {
            genericsLen = len(f.Decl.Generics)
        }
        if !self.s.checkGenericQuantity(genericsLen, len(generics), i.Expr.Token) {
            d = nil
            ret
        }

        // Build real kinds of generic types.
        f.Generics = make([]&InsGeneric, 0, len(f.Decl.Generics))
        for (_, mut g) in generics {
            mut k := self.evalType(g)
            if k == nil {
                d = nil
                ret
            }
            f.Generics = append(f.Generics, &InsGeneric{Kind: k.Kind})
        }

        if f.IsBuiltin() {
            ret
        }

        if self.checkGenericFn(f, i.Expr.Token, d.Model) {
            d.Kind.Kind = f
        } else {
            d = nil
        }
    }

    fn evalIndexing(mut &self, mut i: &IndexingExpr): &Data {
        mut prefix := self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        mut d := self.evalExprKind(i.Expr.Kind)
        if d == nil {
            ret nil
        }

        // Catch types.
        if d.Decl {
            self.evalIdentDeclFromIndexing(d, i)
            ret d
        }

        if d.Kind.Fn() != nil {
            self.evalFnGenericFromIndexing(d, i)
            ret d
        }

        mut oldData := *d

        mut index := self.evalExpr(i.Index)
        if index == nil {
            ret nil
        }

        // Set decl to true. It's a kind of flag.
        // If decl is true after indexing eval, do not touch Model:.
        // Setted by indexing eval.
        d.Decl = false

        self.toIndexing(d, index, i)
        if d.IsConst() {
            d.Decl = false
            d.Model = d.Constant
        } else if d.Decl {
            d.Decl = false
        } else {
            d.Model = &IndexingExprModel{
                Token: i.Token,
                Expr: new(Data, oldData),
                Index: index,
            }
        }

        ret d
    }

    // Returns left and right index values.
    // Returns zero integer expression if slicing have not left index.
    // So, left index always represents an expression.
    // Left data is nil if expression eval failed.
    fn evalSlicingExprs(mut &self, mut &s: &SlicingExpr): (&Data, &Data) {
        mut prefix := self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        let mut l: &Data = nil
        let mut r: &Data = nil

        if s.Start != nil {
            l = self.evalExpr(s.Start)
            if l != nil {
                self.checkIntegerIndexingByData(l, s.Token)
            } else {
                ret nil, nil
            }
        } else {
            l = &Data{
                Constant: Const.NewI64(0),
                Kind: primInt,
            }
            l.Constant.Kind = PrimKind.Int
            l.Model = l.Constant
        }

        if s.To != nil {
            r = self.evalExpr(s.To)
            if r != nil {
                self.checkIntegerIndexingByData(r, s.Token)
            } else {
                ret nil, nil
            }
        }

        ret l, r
    }

    fn slicingArr(self, mut &d: &Data) {
        mut elemType := d.Kind.Arr().Elem
        d.Kind = &TypeKind{
            Kind: &Slc{
                Elem: elemType,
            },
        }

        d.Lvalue = false

        // Keep mutability id already mutable.
        // Be mutable, if element is not mutable-type.
        d.Mutable = d.Mutable || !elemType.Mutable()
    }

    fn slicingStr(self, mut &d: &Data, &l: &Data, &r: &Data) {
        d.Lvalue = false
        d.Mutable = true
        if !d.IsConst() {
            ret
        }

        if l == nil || r == nil {
            d.Constant = nil
            d.untyped = false
            ret
        }

        if l.IsConst() && r.IsConst() {
            left := l.Constant.AsI64()
            if left < 0 {
                ret
            }

            s := d.Constant.ReadStr()
            mut right := i64(0)
            if r == nil {
                right = i64(len(s))
            } else {
                right = r.Constant.AsI64()
            }

            if left > right {
                ret
            }
            d.Constant.SetStr(s[left:right])
            d.Decl = true // Set Model: flag.
        } else {
            d.Constant = nil
            d.untyped = false
        }
    }

    fn checkSlicing(mut self, mut &d: &Data, &l: &Data, &r: &Data, &s: &SlicingExpr) {
        match {
        | d.Kind.Arr() != nil:
            self.slicingArr(d)
            ret
        | d.Kind.Slc() != nil:
            ret
        | d.Kind.Prim() != nil:
            prim := d.Kind.Prim()
            match {
            | prim.IsStr():
                self.slicingStr(d, l, r)
                ret
            }
        }

        self.pushErr(s.Token, LogMsg.NotSupportsSlicing, d.Kind.Str())
    }

    fn evalSlicing(mut &self, mut s: &SlicingExpr): &Data {
        mut d := self.evalExpr(s.Expr)
        if d == nil {
            ret nil
        }

        mut l, mut r := self.evalSlicingExprs(s)
        if l == nil {
            ret d
        }

        // Set decl to true. It's a kind of flag.
        // If decl is true after indexing eval, do not touch Model:.
        // Setted by indexing eval.
        d.Decl = false

        self.checkSlicing(d, l, r, s)

        if d.IsConst() {
            d.Decl = false
            d.Model = d.Constant
        } else if d.Decl {
            d.Decl = false
        } else {
            mut model := &SlicingExprModel{
                Token: s.Token,
                Expr: d.Model,
                Left: l.Model,
            }
            if r != nil {
                model.Right = r.Model
            }
            d.Model = model
        }
        ret d
    }

    fn castPtr(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        d.Constant = nil
        d.untyped = false
        sptr := d.Kind.Sptr()
        if sptr != nil {
            if !t.Ptr().Elem.Equal(sptr.Elem) {
                self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
            }
            ret
        }

        if !self.isUnsafe() {
            self.pushErr(errorToken, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            ret
        }

        prim := d.Kind.Prim()
        if d.Kind.Ptr() == nil && (prim == nil || !types::IsInt(prim.Str())) {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
        }
    }

    fn castStruct(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        d.Constant = nil
        d.untyped = false
        mut tr := d.Kind.Trait()
        if tr == nil {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
            ret
        }

        mut s := t.Struct()
        self.pushReference[&StructIns](s)

        if !s.Decl.IsImplements(tr) {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
        }
    }

    fn castRef(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        d.Constant = nil
        d.untyped = false
        mut sptr := t.Sptr()

        mut ptr := d.Kind.Ptr()
        if ptr != nil && sptr.Elem.Equal(ptr.Elem) {
            if !self.isUnsafe() {
                self.pushErr(errorToken, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            }
            // Ok.
            ret
        }

        // For traits.
        if sptr.Elem.Struct() != nil {
            self.castStruct(sptr.Elem, d, errorToken)
            ret
        }

        self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
    }

    fn castSlc(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        c := d.Constant
        d.Constant = nil
        d.untyped = false

        if d.Kind.Enum() != nil {
            if d.Kind.Enum().Kind.Kind.Prim() == nil || !d.Kind.Enum().Kind.Kind.Prim().IsStr() {
                self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
                ret
            }
        } else if d.Kind.Prim() == nil || !d.Kind.Prim().IsStr() {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
            ret
        }

        t = t.Slc().Elem
        prim := t.Prim()
        if prim == nil || (!prim.IsU8() && !prim.IsI32()) {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
            ret
        }

        // Cast constant expressions.
        if c != nil {
            match {
            | prim.IsU8():
                s := c.ReadStr()
                mut model := &SliceExprModel{
                    ElemKind: t,
                    Elems: make([]ExprModel, 0, len(s)),
                }
                for _, b in s {
                    mut bc := Const.NewU64(u64(b))
                    bc.Kind = prim.Kind
                    model.Elems = append(model.Elems, bc)
                }
                d.Model = model
                d.Decl = true // Prevent model changing.
            | prim.IsI32():
                runes := []rune(c.ReadStr())
                mut model := &SliceExprModel{
                    ElemKind: t,
                    Elems: make([]ExprModel, 0, len(runes)),
                }
                for _, r in runes {
                    mut rc := Const.NewI64(i64(r))
                    rc.Kind = prim.Kind
                    model.Elems = append(model.Elems, rc)
                }
                d.Model = model
                d.Decl = true // Prevent model changing.
            }
        }
    }

    fn castStr(mut self, mut d: &Data, errorToken: &Token) {
        if d.Kind.Enum() != nil {
            mut e := d.Kind.Enum()
            if e.Kind.Kind.Prim() != nil && e.Kind.Kind.Prim().IsStr() {
                ret
            }
        }

        c := d.Constant
        d.Constant = nil
        d.untyped = false
        if d.Kind.Prim() != nil {
            prim := d.Kind.Prim()
            if !prim.IsU8() && !prim.IsI32() {
                self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, PrimKind.Str, d.Kind.Str())
                ret
            }
            // Cast constant expressions.
            if c != nil {
                match {
                | prim.IsU8():
                    d.Constant = Const.NewStr(str(byte(c.AsU64())))
                    d.Model = d.Constant
                    d.Decl = true // Prevent model changing.
                | prim.IsI32():
                    d.Constant = Const.NewStr(str(rune(c.AsI64())))
                    d.Model = d.Constant
                    d.Decl = true // Prevent model changing.
                }
            }
            ret
        }

        mut s := d.Kind.Slc()
        if s == nil {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, PrimKind.Str, d.Kind.Str())
            ret
        }

        mut t := s.Elem
        prim := t.Prim()
        if prim == nil || (!prim.IsU8() && !prim.IsI32()) {
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, PrimKind.Str, d.Kind.Str())
            ret
        }
    }

    fn castInt(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        if d.IsConst() {
            prim := t.Prim()
            match {
            | types::IsSigInt(prim.Kind):
                d.Constant.SetI64(d.Constant.AsI64())
            | types::IsUnsigInt(prim.Kind):
                d.Constant.SetU64(d.Constant.AsU64())
            }
        } else {
            d.Constant = nil
            d.untyped = false
        }

        if d.Kind.Enum() != nil {
            e := d.Kind.Enum()
            if types::IsNum(e.Kind.Kind.Str()) {
                ret
            }
        }

        if d.Kind.Sptr() != nil {
            prim := t.Prim()
            if !prim.IsUintptr() {
                self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
            }
            ret
        }
        if d.Kind.Ptr() != nil {
            prim := t.Prim()
            if prim.IsUintptr() {
                // Ignore case.
            } else if !self.isUnsafe() {
                self.pushErr(errorToken, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            }
            ret
        }

        prim := d.Kind.Prim()
        if prim != nil && types::IsNum(prim.Str()) {
            ret
        }

        self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
    }

    fn castNum(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        if d.IsConst() {
            prim := t.Prim()
            match {
            | types::IsFloat(prim.Kind):
                d.Constant.SetF64(d.Constant.AsF64())
            | types::IsSigInt(prim.Kind):
                d.Constant.SetI64(d.Constant.AsI64())
            | types::IsUnsigInt(prim.Kind):
                d.Constant.SetU64(d.Constant.AsU64())
            }
        } else {
            d.Constant = nil
            d.untyped = false
        }

        if d.Kind.Enum() != nil {
            e := d.Kind.Enum()
            if types::IsNum(e.Kind.Kind.Str()) {
                ret
            }
        }

        prim := d.Kind.Prim()
        if prim != nil && types::IsNum(prim.Str()) {
            ret
        }

        self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
    }

    fn castPrim(mut self, mut t: &TypeKind, mut d: &Data, errorToken: &Token) {
        prim := t.Prim()
        match {
        | prim.IsAny():
            // The any type supports casting to any data type.
            d.Constant = nil
            d.untyped = false
        | prim.IsStr():
            self.castStr(d, errorToken)
        | types::IsInt(prim.Str()):
            self.castInt(t, d, errorToken)
        | types::IsNum(prim.Str()):
            self.castNum(t, d, errorToken)
        |:
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCasting, t.Str())
        }
    }

    fn castConstant(mut self, mut &t: &TypeKind, mut &d: &Data) {
        if d == nil || !d.IsConst() {
            ret
        }
        prim := t.Prim()
        castConstByType(prim.Kind, d)
        d.Model = d.Constant
    }

    fn castTypeEnum(mut self, mut &t: &TypeKind, mut &d: &Data, mut &errorToken: &Token) {
        n := len(self.s.errors)
        if !self.s.checkTypeCompatibility(d.Kind, t, errorToken) {
            self.s.errors = self.s.errors[:n]
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
        }
        d.Constant = nil
        d.untyped = false
    }

    fn castTypeEnumT(mut self, mut &t: &TypeKind, mut &d: &Data, mut &errorToken: &Token) {
        n := len(self.s.errors)
        if !self.s.checkTypeCompatibility(t, d.Kind, errorToken) {
            self.s.errors = self.s.errors[:n]
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, d.Kind.Str(), t.Str())
        }
        d.Constant = nil
        d.untyped = false
    }

    fn evalCastByTypeNData(mut self, mut t: &TypeKind, mut d: &Data, mut errorToken: &Token): &Data {
        if d != nil && d.Decl {
            self.pushErr(errorToken, LogMsg.InvalidExpr)
            ret nil
        }

        match {
        | d.IsNil():
            if !t.NilCompatible() {
                self.pushErr(errorToken, LogMsg.TypeNotSupportsCastingTo, "<nil>", t.Str())
            }
            d.Constant = nil // Remove nil constant.
            d.untyped = false
        | d.Kind.Prim() != nil && d.Kind.Prim().IsAny():
            if t.Enum() != nil {
                self.pushErr(errorToken, LogMsg.EnumCastedFromAny)
                self.pushSuggestion(LogMsg.CastToEnumTypeInsteadOfEnum)
            } else if t.TypeEnum() != nil {
                self.pushErr(errorToken, LogMsg.EnumCastedFromAny)
            }
            d.Constant = nil
            d.untyped = false
        | d.Kind.TypeEnum() != nil:
            self.castTypeEnum(t, d, errorToken)
        | t.TypeEnum() != nil:
            self.castTypeEnumT(t, d, errorToken)
        | t.Ptr() != nil:
            self.castPtr(t, d, errorToken)
        | t.Sptr() != nil:
            self.castRef(t, d, errorToken)
        | t.Slc() != nil:
            self.castSlc(t, d, errorToken)
        | t.Struct() != nil:
            self.castStruct(t, d, errorToken)
        | t.Prim() != nil:
            self.castPrim(t, d, errorToken)
            self.castConstant(t, d)
        |:
            self.pushErr(errorToken, LogMsg.TypeNotSupportsCasting, t.Str())
            d = nil
        }

        if d == nil {
            ret nil
        }

        // Keep mutability if data is already mutable.
        // Even if the data is not mutable, set as mutable if the type is not mutable-type.
        d.Mutable = d.Mutable || !d.Kind.Mutable()

        if !d.Decl && (d.Kind.Enum() == nil || !d.Kind.Enum().Kind.Kind.Equal(t)) {
            applyCastKind(d, t, errorToken)
            (&CastingExprModel)(d.Model).Token = errorToken
        } else {
            d.Kind = t
        }

        // Remove flag.
        // The variable d cannot be d.Decl true because of checked already.
        // Therefore this field used as flag to say "do not touch to expression model".
        // So, if d.Decl is true, model will not be changed.
        d.Decl = false

        d.Lvalue = false
        d.untyped = false

        if d.IsConst() {
            d.Constant.Kind = t.Prim().Kind
        }

        ret d
    }

    fn evalCastT(mut &self, mut &t: &TypeKind, mut &e: &Expr, mut &et: &Token): &Data {
        mut prefix := self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }
        if t.Slc() != nil {
            match type e.Kind {
            | &SliceExpr:
                self.prefix = t
            }
        }
        mut d := self.evalExpr(e)
        if d == nil || self.prefix != nil {
            ret d
        }
        ret self.evalCastByTypeNData(t, d, et)
    }

    fn evalCast(mut &self, mut c: &CastExpr): &Data {
        mut t := buildType(c.Kind)
        ok := self.s.checkType(t, self.lookup)
        if !ok {
            ret nil
        }
        ret self.evalCastT(t.Kind, c.Expr, c.Kind.Token)
    }

    fn evalNsSelection(mut self, s: &NsSelectionExpr): &Data {
        path := buildLinkPathByTokens(s.Ns)
        mut imp := self.lookup.SelectPackage(fn(imp: &ImportInfo): bool {
            if len(s.Ns) == 1 && imp.Alias == path {
                ret true
            }
            ret imp.LinkPath == path && imp.isAccessibleViaSelection()
        })

        if imp == nil {
            self.pushErr(s.Ns[0], LogMsg.NamespaceNotExist, path)
            ret nil
        }

        mut lookup := self.lookup
        self.lookup = imp

        const Binded = false
        self.disallowBuiltin()
        mut def := self.getDef(s.Ident.Kind, Binded)
        self.allowBuiltin()
        self.lookup = lookup
        mut d := self.evalDef(def, s.Ident)
        ret d
    }

    fn evalStructLitExplicit(mut &self, mut s: &StructIns,
        mut exprs: []&Expr, mut errorToken: &Token): &Data {
        ok := self.s.checkGenericQuantity(len(s.Decl.Generics), len(s.Generics), errorToken)
        if !ok {
            ret nil
        }
        // NOTICE: Instance already checked (just fields) if generic quantity passes.

        if self.field != nil && self.field.Decl.Owner == s.Decl {
            self.pushErr(errorToken, LogMsg.IllegalCycleRefersItself, s.Decl.Ident)
        }

        self.pushReference[&StructIns](s)
        self.checkDeprecated(s.Decl.Directives, errorToken)

        mut slc := structLitChecker{
            e: self,
            errorToken: errorToken,
            s: s,
        }
        slc.check(exprs)

        mut d := &Data{
            Mutable: !self.immutable,
            Kind: &TypeKind{
                Kind: s,
            },
            Model: &StructLitExprModel{
                Strct: s,
                Args: slc.args,
            },
        }
        if s.Decl.Binded {
            d.Kind.BindIdent = s.Decl.Ident
        }
        ret d
    }

    fn evalStructLit(mut &self, mut lit: &StructLit): &Data {
        mut t := buildType(lit.Kind)
        ok := self.s.checkType(t, self.lookup)
        if !ok {
            ret nil
        }

        mut s := t.Kind.Struct()
        if s == nil {
            if t.Kind.Sptr() != nil {
                s = t.Kind.Sptr().Elem.Struct()
                if s != nil {
                    goto eval
                }
            }
            self.pushErr(lit.Kind.Token, LogMsg.InvalidSyntax)
            ret nil
        }

    eval:
        mut d := self.evalStructLitExplicit(s, lit.Exprs, lit.Kind.Token)
        if t.Kind.Sptr() != nil {
            mut model := (&StructLitExprModel)(d.Model)
            makeStructLitAlloc(d, model)
        }
        ret d
    }

    fn typeChecker(mut self): typeChecker {
        ret self.s.typeChecker(self.lookup, nil, nil)
    }

    fn evalType(mut self, mut t: &TypeDecl): &Data {
        mut tk := buildType(t)
        ok := self.s.checkType(tk, self.lookup)
        if !ok {
            ret nil
        }
        ret &Data{
            Decl: true,
            Kind: tk.Kind,
            Model: tk.Kind,
        }
    }

    fn callTypeFn(mut &self, mut &fc: &FnCallExpr, mut &d: &Data) {
        if len(fc.Args) < 1 {
            self.pushErr(fc.Token, LogMsg.MissingExprFor, "v")
        } else if len(fc.Args) > 1 {
            self.pushErr(fc.Args[1].Token, LogMsg.ArgumentOverflow, d.Kind.Str())
        } else if fc.IsCo {
            self.pushErr(fc.Token, LogMsg.CoForCastingCall)
            d = nil
            ret
        } else if fc.Exception != nil {
            self.pushErr(fc.Token, LogMsg.TypeCallWithExceptional)
            d = nil
            ret
        }

        if len(fc.Args) > 0 {
            mut arg := fc.Args[0]
            d = self.evalCastT(d.Kind, arg, arg.Token)
            ret
        }

        if d != nil {
            d.Decl = false
        }
    }

    fn callBuiltinFn(mut &self, mut &fc: &FnCallExpr, mut &d: &Data) {
        if !fc.Unhandled() { // Exceptional handled?
            // Built-in functions are not exceptional.
            self.pushErr(fc.Token, LogMsg.HandledUnexceptional)
        }
        d = d.Kind.Fn().caller(self, fc, d)
        if d == nil {
            ret
        }
        d.Mutable = true
    }

    fn checkFnOfConcurrentCall(mut self, &f: &FnIns, errorToken: &Token) {
        if self.isUnsafe() {
            ret
        }
        for _, p in f.Params {
            if p.Decl.IsSelf() {
                if !p.Decl.IsRef() {
                    self.pushErr(errorToken, LogMsg.ConcurrentCallWithSelfParam)
                    self.pushSuggestion(LogMsg.UseUnsafeJuleToCallCoSelf)
                }
            }
            if p.Decl.Reference {
                self.pushErr(errorToken, LogMsg.ConcurrentCallWithRefParam)
                self.pushSuggestion(LogMsg.UseUnsafeJuleToCallCo)
                ret
            }
        }
    }

    fn processExceptionalHandler(mut self, mut &f: &FnIns, mut &fc: &FnCallExpr, mut &d: &Data) {
        resultNeeded := !f.Decl.IsVoid() && (self.arg || !self.ignored)
        let mut csc: &scopeChecker = nil
        let mut ch: &Scope = nil

        mut model := (&FnCallExprModel)(d.Model)

        // self.lookup is always scopeChecker because exceptionals are
        // not allowed in global scope.
        mut sc := (&scopeChecker)(self.lookup)
        csc = sc.newChildChecker()
        if resultNeeded {
            csc.result = f
        }
        ch = sc.getChild()
        fc.Exception.Parent = sc.tree
        csc.table.Vars = append(csc.table.Vars, buildErrorVar(ch, fc))
        sc.checkChildSsc(fc.Exception, ch, csc)

        model.Assigned = resultNeeded
        model.Except = ch

        if resultNeeded && csc.result != nil {
            self.pushErr(fc.Token, LogMsg.MissingAssignRet)
        }
    }

    fn callFn(mut &self, mut &fc: &FnCallExpr, mut &d: &Data) {
        mut f := d.Kind.Fn()
        if f.IsBuiltin() {
            self.callBuiltinFn(fc, d)
            ret
        }
        if self.isGlobal() && f.Decl.Exceptional {
            self.pushErr(fc.Token, LogMsg.ExceptionalAtGlobalScope)
            self.pushSuggestion(LogMsg.WrapExceptional)
            d = nil
            ret
        }

        if !f.Decl.IsMethod() && hasDirective(f.Decl.Directives, Directive.Test) {
            self.pushErr(fc.Token, LogMsg.TestCalled)
            d = nil
            ret
        }

        if !d.Mutable && f.Decl.IsMethod() && !f.Decl.Statically && f.Decl.Params[0].Mutable {
            if !self.immutable {
                self.pushErr(fc.Token, LogMsg.MutOperationOnImmut)
            } else {
                // Caught mutability risk of immutable literals.
                // Literal will not be assigned to immutable memory,
                // used to call method with mutable receiver.
                // Assume literal as mutable and check accordingly.
                lit := isLitBased(d.Model)
                if lit == nil {
                    // Expression is not literal based, so data is strictly immutable.
                    self.pushErr(fc.Token, LogMsg.MutOperationOnImmut)
                } else {
                    checkMutRiskOfStructLit(self.s, lit)
                }
            }
        } else if !self.isUnsafe() && f.Decl.Unsafety {
            self.pushErr(fc.Token, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
        }

        mut dynamicAnnotation := len(f.Decl.Generics) > 0 && len(f.Generics) == 0 && len(f.Params) > 0
        if dynamicAnnotation {
            f.Generics = make([]&InsGeneric, len(f.Decl.Generics))
        } else if len(f.Generics) != len(f.Decl.Generics) {
            _ = self.s.checkGenericQuantity(len(f.Decl.Generics), len(f.Generics), fc.Token)
            d = nil
            ret
        }

        mut old := self.s
        if f.Decl.Owner != nil {
            self.s = f.Decl.Owner.sema
        }

        defer {
            if old != self.s {
                old.errors = append(old.errors, self.s.errors...)
                self.s.errors = nil
            }
            self.s = old
        }

        mut fcac := fnCallArgChecker{
            e: self,
            args: fc.Args,
            dynamicAnnotation: dynamicAnnotation,
            errorToken: fc.Token,
        }

        if !dynamicAnnotation {
            if !f.reloaded {
                ok := self.s.reloadFnInsTypes(f)
                f.reloaded = true
                if !ok {
                    d = nil
                    ret
                }
            }
            mut existInstance := f.Decl.appendInstance(f)
            if existInstance != nil {
                f = existInstance
            }
        } else if !self.s.buildFnNonGenericTypeKinds(f, fcac.ignored) {
            d = nil
            ret
        }

        fcac.f = f

        mut ok := false
        if f.Decl.Owner != nil {
            old, self.s = self.s, old // Save current Sema.
            ok = fcac.check()
            old, self.s = self.s, old // Save owner Sema.
        } else {
            ok = fcac.check()
        }

        if dynamicAnnotation {
            if !ok {
                d = nil
                ret
            }
            if !self.checkGenericFn(f, fc.Token, d.Model) {
                d = nil
                ret
            }
        }

        mut callModel := d.Model

        if f.Decl.IsVoid() {
            d = buildVoidData()
        } else {
            d.Kind = f.Result
            d.Lvalue = false
        }

        mut model := &FnCallExprModel{
            Token: fc.Token,
            Func: f,
            Expr: callModel,
            Args: fcac.argModels,
            IsCo: fc.IsCo,
        }
        d.Model = model
        d.Mutable = true

        if f.Decl.Exceptional {
            if fc.IsCo {
                self.s.pushErr(fc.Token, LogMsg.CoForExceptional)
                self.s.pushSuggestion(LogMsg.HandleInFn)
            }
            match {
            | fc.Unhandled():
                self.pushErr(fc.Token, LogMsg.UnhandledExceptional)
                self.pushSuggestion(LogMsg.HandleExceptional)
            | fc.Ignored():
                // Ok.
                break
            |:
                // Handled with scope.
                self.processExceptionalHandler(f, fc, d)
            }
        } else if !fc.Unhandled() {
            self.pushErr(fc.Token, LogMsg.HandledUnexceptional)
        }

        if fc.IsCo {
            self.checkFnOfConcurrentCall(model.Func, fc.Token)
        }
    }

    fn evalFnCall(mut &self, mut fc: &FnCallExpr): &Data {
        mut prefix := self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }

        match type fc.Expr.Kind {
        | &IdentExpr:
            // Use fc.expr.Token.Kind instead of casting.
            // Same thing, but more efficient and performant.
            if fc.Expr.Token.Kind == TokenKind.Error {
                ret builtinCallerError(self, fc)
            }
        }

        mut d := self.evalExprKind(fc.Expr.Kind)
        if d == nil {
            ret nil
        }

        if d.Decl {
            self.callTypeFn(fc, d)
            ret d
        }

        if d.Kind.Fn() == nil {
            self.pushErr(fc.Token, LogMsg.CallingNonFn)
            ret nil
        }

        self.callFn(fc, d)
        ret d
    }

    fn evalEnumStatic(mut self, mut enm: &Enum, mut ident: &Token): &Data {
        mut item := enm.FindItem(ident.Kind)
        if item == nil {
            self.pushErr(ident, LogMsg.ObjHaveNotIdent, enm.Ident, ident.Kind)
        }
        ret evalEnumStatic(enm, item, ident)
    }

    fn evalTypeEnumStatic(mut self, mut enm: &TypeEnum, ident: &Token): &Data {
        mut item := enm.FindItem(ident.Kind)
        if item == nil {
            self.pushErr(ident, LogMsg.ObjHaveNotIdent, enm.Ident, ident.Kind)
            ret nil
        }
        match {
        | item.Kind.Kind.Enum() != nil:
            ret self._evalEnum(item.Kind.Kind.Enum())
        | item.Kind.Kind.TypeEnum() != nil:
            ret self._evalTypeEnum(item.Kind.Kind.TypeEnum())
        | item.Kind.Kind.Struct() != nil:
            ret self._evalStruct(item.Kind.Kind.Struct())
        |:
            mut d := &Data{
                Decl: true,
                Kind: item.Kind.Kind,
            }
            d.Model = d.Kind
            ret d
        }
    }

    fn evalStructStatic(mut self, mut s: &StructIns, ident: &Token): &Data {
        mut d := new(Data)

        // Method.
        const Static = true
        mut method := s.FindMethod(ident.Kind, Static)
        if method != nil {
            if !self.s.isAccessibleDefine(method.Public, method.Token) {
                self.pushErr(ident, LogMsg.IdentIsNotAccessible, ident.Kind)
                self.pushSuggestion(LogMsg.MakePubToAccess)
            }

            mut ins := method.instance()
            ins.Owner = s
            self.pushReference[&FnIns](ins)
            d.Model = &StructStaticIdentExprModel{
                Structure: s,
                Expr: d.Model,
                Method: ins,
            }
            d.Kind = &TypeKind{
                Kind: ins,
            }
            ret d
        }

        mut sttc := s.FindStatic(ident.Kind)
        if sttc != nil {
            ret self.evalVar(sttc, ident)
        }

        self.pushErr(ident, LogMsg.ObjHaveNotIdent, s.Decl.Ident, ident.Kind)
        ret nil
    }

    fn evalTraitSubIdent(mut self, mut d: &Data, mut trt: &Trait, mut ident: &Token): &Data {
        mut f := trt.FindMethod(ident.Kind)
        if f == nil {
            self.pushErr(ident, LogMsg.ObjHaveNotIdent, trt.Ident, ident.Kind)
            ret nil
        }
        ret &Data{
            Kind: &TypeKind{
                Kind: f.instance(),
            },
            Model: &TraitSubIdentExprModel{
                Token: ident,
                Expr: d.Model,
                Method: f,
                Trt: trt,
            },
        }
    }

    // This method evaluates expressions, will not check public availability.
    fn evalStructSubIdentField(mut self, mut &d: &Data, mut &s: &StructIns, mut &tok: &Token, mut &f: &FieldIns): &Data {
        mut model := &StructSubIdentExprModel{
            Token: tok,
            Expr: new(Data, *d),
            Field: f,
            Owner: s,
        }
        d.Model = model
        d.Kind = f.Kind
        d.Lvalue = true

        if f.Decl.Mutable && !d.Mutable {
            // Interior mutability.
            match type self.lookup {
            | &scopeChecker:
                scope := (&scopeChecker)(self.lookup).getRoot()
                d.Mutable = scope.owner != nil && scope.owner.Owner == s
            }
        }

        ret d
    }

    fn evalStructSubIdent(mut self, mut d: &Data, mut s: &StructIns, mut si: &SubIdentExpr, ref: bool): &Data {
        mut f := s.FindField(si.Ident.Kind)
        if f != nil {
            if !self.s.isAccessibleDefine(f.Decl.Public, f.Decl.Token) {
                self.pushErr(si.Ident, LogMsg.IdentIsNotAccessible, f.Decl.Ident)
                self.pushSuggestion(LogMsg.MakePubToAccess)
            }
            ret self.evalStructSubIdentField(d, s, si.Ident, f)
        }

        const Static = false
        mut m := s.FindMethod(si.Ident.Kind, Static)
        if m == nil {
            self.pushErr(si.Ident, LogMsg.ObjHaveNotIdent, s.Decl.Ident, si.Ident.Kind)
            ret nil
        }
        if !self.s.isAccessibleDefine(m.Public, m.Token) {
            self.pushErr(si.Ident, LogMsg.IdentIsNotAccessible, m.Ident)
            self.pushSuggestion(LogMsg.MakePubToAccess)
        }

        if m.Params[0].IsRef() && !ref {
            self.pushErr(si.Ident, LogMsg.RefMethodUsedWithNotRefInstance)
        }

        self.checkDeprecated(m.Directives, si.Ident)

        mut ins := m.instance()
        ins.Owner = s
        self.pushReference[&FnIns](ins)
        mut model := new(Data, *d)
        d.Model = &StructSubIdentExprModel{
            Token: si.Ident,
            Expr: model,
            Method: ins,
            Owner: s,
        }
        d.Kind = &TypeKind{Kind: ins}
        ret d
    }

    fn evalIntTypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.Int
        match ident.Kind {
        | "Max":
            mut c := Const.NewI64(types::MaxI(kind))
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primInt,
                untyped: true,
            }
        | "Min":
            mut c := Const.NewI64(i64(types::Min(kind)))
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primInt,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalUintTypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.Uint
        match ident.Kind {
        | "Max":
            mut c := Const.NewU64(types::MaxU(kind))
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primUint,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalI8TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.I8
        const min = types::MinI8
        const max = types::MaxI8
        match ident.Kind {
        | "Max":
            mut c := Const.NewI64(max)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primI8,
                untyped: true,
            }
        | "Min":
            mut c := Const.NewI64(min)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primI8,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalI16TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.I16
        const min = types::MinI16
        const max = types::MaxI16
        match ident.Kind {
        | "Max":
            mut c := Const.NewI64(max)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primI16,
                untyped: true,
            }
        | "Min":
            mut c := Const.NewI64(min)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primI16,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalI32TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.I32
        const min = types::MinI32
        const max = types::MaxI32
        match ident.Kind {
        | "Max":
            mut c := Const.NewI64(max)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primI32,
                untyped: true,
            }
        | "Min":
            mut c := Const.NewI64(min)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primI32,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalI64TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.I64
        const min = types::MinI64
        const max = types::MaxI64
        match ident.Kind {
        | "Max":
            mut c := Const.NewI64(max)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primI64,
                untyped: true,
            }
        | "Min":
            mut c := Const.NewI64(min)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primI64,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalU8TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.U8
        const max = types::MaxU8
        match ident.Kind {
        | "Max":
            mut c := Const.NewU64(max)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primU8,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalU16TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.U16
        const max = types::MaxU16
        match ident.Kind {
        | "Max":
            mut c := Const.NewU64(max)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primU16,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalU32TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.U32
        const max = types::MaxU32
        match ident.Kind {
        | "Max":
            mut c := Const.NewU64(max)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primU32,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalU64TypeStatic(mut self, ident: &Token): &Data {
        const kind: str = PrimKind.U64
        const max = types::MaxU64
        match ident.Kind {
        | "Max":
            mut c := Const.NewU64(max)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primU64,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalF32TypeStatic(mut self, ident: &Token): &Data {
        const kind = PrimKind.F32
        const max = types::MaxF32
        const min = types::MinF32
        const smallestNonZero = types::SmallestNonZeroF32
        match ident.Kind {
        | "Max":
            mut c := Const.NewF64(max)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primF32,
                untyped: true,
            }
        | "Min":
            mut c := Const.NewF64(min)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primF32,
                untyped: true,
            }
        | "SmallestNonZero":
            mut c := Const.NewF64(smallestNonZero)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primF32,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalF64TypeStatic(mut self, ident: &Token): &Data {
        const kind = PrimKind.F64
        const max = types::MaxF64
        const min = types::MinF64
        const smallestNonZero = types::SmallestNonZeroF64
        match ident.Kind {
        | "Max":
            mut c := Const.NewF64(max)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primF64,
                untyped: true,
            }
        | "Min":
            mut c := Const.NewF64(min)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primF64,
                untyped: true,
            }
        | "SmallestNonZero":
            mut c := Const.NewF64(smallestNonZero)
            c.Kind = kind
            ret &Data{
                Constant: c,
                Model: c,
                Kind: primF64,
                untyped: true,
            }
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalPrimStatic(mut self, kind: str, ident: &Token): &Data {
        match kind {
        | PrimKind.Int:
            ret self.evalIntTypeStatic(ident)
        | PrimKind.Uint:
            ret self.evalUintTypeStatic(ident)
        | PrimKind.I8:
            ret self.evalI8TypeStatic(ident)
        | PrimKind.I16:
            ret self.evalI16TypeStatic(ident)
        | PrimKind.I32:
            ret self.evalI32TypeStatic(ident)
        | PrimKind.I64:
            ret self.evalI64TypeStatic(ident)
        | PrimKind.U8:
            ret self.evalU8TypeStatic(ident)
        | PrimKind.U16:
            ret self.evalU16TypeStatic(ident)
        | PrimKind.U32:
            ret self.evalU32TypeStatic(ident)
        | PrimKind.U64:
            ret self.evalU64TypeStatic(ident)
        | PrimKind.F32:
            ret self.evalF32TypeStatic(ident)
        | PrimKind.F64:
            ret self.evalF64TypeStatic(ident)
        |:
            self.pushErr(ident, LogMsg.TypeHaveNotIdent, kind, ident.Kind)
            ret nil
        }
    }

    fn evalTypeStatic(mut self, mut d: &Data, mut si: &SubIdentExpr): &Data {
        match {
        | d.Kind.Prim() != nil:
            ret self.evalPrimStatic(d.Kind.Prim().Str(), si.Ident)
        | d.Kind.Enum() != nil:
            ret self.evalEnumStatic(d.Kind.Enum(), si.Ident)
        | d.Kind.TypeEnum() != nil:
            ret self.evalTypeEnumStatic(d.Kind.TypeEnum(), si.Ident)
        | d.Kind.Struct() != nil:
            ret self.evalStructStatic(d.Kind.Struct(), si.Ident)
        |:
            self.pushErr(si.Ident, LogMsg.TypeNotSupportSubFields, d.Kind.Str())
            ret nil
        }
    }

    fn comptimeObjSubIdent[ComptimeType](mut self, mut &ct: &ComptimeType, &d: &Data, &si: &SubIdentExpr): &Data {
        mut cd := ct.subIdent(si.Ident.Kind)
        if cd == nil {
            self.pushErr(si.Ident, LogMsg.ObjHaveNotIdent, d.Kind.Str(), si.Ident.Kind)
        }
        ret cd
    }

    fn tryComptimeObjSubIdent(mut self, mut &d: &Data, mut si: &SubIdentExpr): (&Data, bool) {
        match {
        | d.Kind.comptimeTypeInfo() != nil:
            mut ct := d.Kind.comptimeTypeInfo()
            ret self.comptimeObjSubIdent(ct, d, si), true
        | d.Kind.comptimeStructField() != nil:
            mut ct := d.Kind.comptimeStructField()
            ret self.comptimeObjSubIdent(ct, d, si), true
        | d.Kind.comptimeEnumField() != nil:
            mut ct := d.Kind.comptimeEnumField()
            ret self.comptimeObjSubIdent(ct, d, si), true
        | d.Kind.comptimeParam() != nil:
            mut ct := d.Kind.comptimeParam()
            ret self.comptimeObjSubIdent(ct, d, si), true
        | d.Kind.comptimeStatic() != nil:
            mut ct := d.Kind.comptimeStatic()
            ret self.comptimeObjSubIdent(ct, d, si), true
        | d.Kind.comptimeValue() != nil:
            mut ct := d.Kind.comptimeValue()
            ret self.comptimeObjSubIdent(ct, d, si), true
        | d.Kind.comptimeFile() != nil:
            mut ct := d.Kind.comptimeFile()
            ret self.comptimeObjSubIdent(ct, d, si), true
        |:
            ret nil, false
        }
    }

    fn evalObjSubIdent(mut self, mut d: &Data, mut si: &SubIdentExpr): &Data {
        if IsIgnoreIdent(si.Ident.Kind) {
            self.pushErr(si.Ident, LogMsg.InvalidSyntax)
            ret nil
        }

        {
            mut compData, ok := self.tryComptimeObjSubIdent(d, si)
            if ok {
                ret compData
            }
        }

        mut kind := d.Kind
        match {
        | d.Kind.Ptr() != nil:
            ptr := d.Kind.Ptr()
            if ptr.IsUnsafe() {
                break
            }
            if !self.isUnsafe() {
                self.pushErr(si.Ident, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            }
            kind = d.Kind.Ptr().Elem
            makeImplicitDeref(d, si.Ident)
        | d.Kind.Sptr() != nil:
            kind = d.Kind.Sptr().Elem
            makeImplicitDeref(d, si.Ident)
        }

        match {
        | d.Kind.Trait() != nil:
            ret self.evalTraitSubIdent(d, d.Kind.Trait(), si.Ident)
        | kind.Struct() != nil:
            s := kind.Struct()
            if isInstancedStruct(s) {
                mut usedReferenceElem := d.Kind.Sptr() != nil
                ret self.evalStructSubIdent(d, kind.Struct(), si, usedReferenceElem)
            }
        }
        self.pushErr(si.Ident, LogMsg.ObjNotSupportSubFields, d.Kind.Str())
        ret nil
    }

    fn evalSubIdent(mut &self, mut si: &SubIdentExpr): &Data {
        mut prefix := self.prefix
        self.prefix = nil
        defer { self.prefix = prefix }
        mut d := self.evalExprKind(si.Expr.Kind)
        if d == nil {
            ret nil
        }
        if d.Decl {
            ret self.evalTypeStatic(d, si)
        }
        ret self.evalObjSubIdent(d, si)
    }

    fn evalTuple(mut &self, mut tup: &TupleExpr): &Data {
        mut tupT := new(Tuple)
        tupT.Types = make([]&TypeKind, 0, len(tup.Expr))

        mut model := &TupleExprModel{
            Datas: make([]&Data, 0, len(tup.Expr)),
        }

        mut ok := true
        for (_, mut expr) in tup.Expr {
            mut d := self.evalExpr(expr)
            if d == nil {
                ok = false
                continue
            }
            tupT.Types = append(tupT.Types, d.Kind)
            model.Datas = append(model.Datas, d)
        }

        if !ok {
            ret nil
        }

        ret &Data{
            Kind: &TypeKind{Kind: tupT},
            Model: model,
        }
    }

    fn evalMap(mut &self, mut m: &Map, mut lit: &BraceLit): &Data {
        mut model := &MapExprModel{
            KeyKind: m.Key,
            ValKind: m.Val,
        }

        for (_, mut expr) in lit.Exprs {
            match type expr.Kind {
            | &KeyValPair:
                // Ok.
                break
            |:
                self.pushErr(lit.Token, LogMsg.InvalidSyntax)
                ret nil
            }

            mut pair := (&KeyValPair)(expr.Kind)

            mut key := self.evalExpr(pair.Key)
            if key == nil {
                ret nil
            }

            mut val := self.evalExpr(pair.Val)
            if val == nil {
                ret nil
            }

            const destIsRef = false
            if self.s.checkValidityForInitExpr(!self.immutable, destIsRef, m.Key, key, pair.Key.Token) {
                _ = self.s.checkAssignType(destIsRef, m.Key, key, pair.Key.Token)
            }
            if self.s.checkValidityForInitExpr(!self.immutable, destIsRef, m.Val, val, pair.Val.Token) {
                _ = self.s.checkAssignType(destIsRef, m.Val, val, pair.Val.Token)
            }

            model.Entries = append(model.Entries, &KeyValPairExprModel{
                Key: key.Model,
                Val: val.Model,
            })
        }

        ret &Data{
            Mutable: true,
            Kind: &TypeKind{Kind: m},
            Model: model,
        }
    }

    fn evalBraceLit(mut &self, mut lit: &BraceLit): &Data {
        match {
        | self.prefix == nil:
            self.pushErr(lit.Token, LogMsg.InvalidSyntax)
            ret nil
        | self.prefix.Map() != nil:
            ret self.evalMap(self.prefix.Map(), lit)
        | self.prefix.Struct() != nil:
            ret self.evalStructLitExplicit(self.prefix.Struct(), lit.Exprs, lit.Token)
        |:
            self.pushErr(lit.Token, LogMsg.InvalidSyntax)
            ret nil
        }
    }

    fn evalAnonFunc(mut &self, mut decl: &FnDecl): &Data {
        mut tc := typeChecker{
            s: self.s,
            rootLookup: self.lookup,
            lookup: self.lookup,
        }
        mut ins := tc.buildFunc(decl)
        if ins == nil {
            ret nil
        }
        match type self.lookup {
        | &scopeChecker:
            mut sc := (&scopeChecker)(self.lookup)
            mut scc := sc.newChildChecker()
            scc.labels = new([]&scopeLabel, nil)
            scc.gotos = new([]&scopeGoto, nil)
            scc.owner = nil
            scc.childIndex = 0
            scc.it = 0
            scc.cse = 0
            scc.owner = ins
            self.s.checkFnInsSc(ins, scc)
        |:
            self.s.checkFnIns(ins)
        }

        ret &Data{
            Kind: &TypeKind{Kind: ins},
            Model: &AnonFnExprModel{
                Func: ins,
                Global: self.isGlobal(),
            },
        }
    }

    fn evalBinary(mut &self, mut op: &BinaryExpr): &Data {
        mut bs := binaryEval.newPlain(self)
        // Apply prefix for just numericals.
        if self.prefix != nil {
            prim := self.prefix.Prim()
            if prim == nil || !types::IsNum(prim.Str()) {
                mut prefix := self.prefix
                self.prefix = nil
                defer { self.prefix = prefix }
                ret bs.eval(op)
            }
        }
        ret bs.eval(op)
    }

    fn evalExprKind(mut &self, mut kind: ExprData): &Data {
        match type kind {
        | &RangeExpr:
            mut e := (&RangeExpr)(kind)
            ret self.evalExprKind(e.Expr.Kind)
        | &LitExpr:
            ret self.evalLit((&LitExpr)(kind))
        | &IdentExpr:
            ret self.evalIdent((&IdentExpr)(kind))
        | &UnaryExpr:
            ret self.evalUnary((&UnaryExpr)(kind))
        | &VariadicExpr:
            ret self.evalVariadic((&VariadicExpr)(kind))
        | &UnsafeExpr:
            ret self.evalUnsafe((&UnsafeExpr)(kind))
        | &SliceExpr:
            ret self.evalSliceExpr((&SliceExpr)(kind))
        | &IndexingExpr:
            ret self.evalIndexing((&IndexingExpr)(kind))
        | &SlicingExpr:
            ret self.evalSlicing((&SlicingExpr)(kind))
        | &CastExpr:
            ret self.evalCast((&CastExpr)(kind))
        | &NsSelectionExpr:
            ret self.evalNsSelection((&NsSelectionExpr)(kind))
        | &StructLit:
            ret self.evalStructLit((&StructLit)(kind))
        | &TypeDecl:
            ret self.evalType((&TypeDecl)(kind))
        | &FnCallExpr:
            ret self.evalFnCall((&FnCallExpr)(kind))
        | &SubIdentExpr:
            ret self.evalSubIdent((&SubIdentExpr)(kind))
        | &TupleExpr:
            ret self.evalTuple((&TupleExpr)(kind))
        | &BraceLit:
            ret self.evalBraceLit((&BraceLit)(kind))
        | &FnDecl:
            ret self.evalAnonFunc((&FnDecl)(kind))
        | &BinaryExpr:
            ret self.evalBinary((&BinaryExpr)(kind))
        |:
            ret nil
        }
    }

    // Returns value data of evaluated expression.
    // Returns nil if error occurs.
    fn eval1(mut &self, mut expr: &Expr): &Data {
        mut d := self.evalExprKind(expr.Kind)
        if d == nil || d.Kind == nil {
            ret nil
        }

        match {
        | d.Kind.Fn() != nil:
            mut f := d.Kind.Fn()
            if f.IsBuiltin() {
                self.s.pushErr(expr.Token, LogMsg.BuiltinNotInvoked)
                break
            }
            if len(f.Generics) != len(f.Decl.Generics) {
                self.s.pushErr(expr.Token, LogMsg.HasGenerics)
            }
            if !f.Decl.Statically && f.Decl.IsMethod() {
                self.s.pushErr(expr.Token, LogMsg.MethodNotInvoked)
            }
        }

        ret d
    }

    // Returns value data of evaluated expression.
    // Returns nil if error occurs.
    // Accepts comptime expressions as invalid.
    fn eval(mut &self, mut expr: &Expr): &Data {
        mut d := self.eval1(expr)
        if d == nil {
            ret nil
        }
        if (self.owner == nil || !self.owner.Constant) && d.Kind.comptime() {
            self.s.pushErr(expr.Token, LogMsg.ComptimeAsExpr)
            ret nil
        }
        ret d
    }

    // Returns value data of evaluated expression.
    // Returns nil if error occurs.
    // Accepts decls as invalid expression.
    fn evalExpr1(mut &self, mut expr: &Expr): &Data {
        mut d := self.eval1(expr)
        match {
        | d == nil:
            ret nil
        | d.Decl:
            self.pushErr(expr.Token, LogMsg.InvalidExpr)
            ret nil
        |:
            ret d
        }
    }

    // Returns value data of evaluated expression.
    // Returns nil if error occurs.
    // Accepts decls as invalid expression.
    fn evalExpr(mut &self, mut expr: &Expr): &Data {
        mut d := self.eval(expr)
        match {
        | d == nil:
            ret nil
        | d.Decl:
            self.pushErr(expr.Token, LogMsg.InvalidExpr)
            ret nil
        |:
            ret d
        }
    }
}

struct unaryEval {
    e: &Eval
    d: &Data
    u: &UnaryExpr
}

impl unaryEval {
    static fn new(mut e: &Eval): unaryEval {
        ret unaryEval{
            e: e,
        }
    }

    fn minus(mut self) {
        match {
        | self.d.Kind == nil:
            self.d = nil
            ret
        | self.d.Kind.Prim() != nil:
            if !types::IsNum(self.d.Kind.Str()) {
                self.d = nil
                ret
            }
        | self.d.Kind.Struct() != nil:
            if self.d.Kind.Struct().Operators.Neg == nil {
                self.d = nil
                ret
            }
        |:
            self.d = nil
            ret
        }

        self.d.Lvalue = false
        self.d.Mutable = true

        if self.d.IsConst() {
            match {
            | self.d.Constant.IsF64():
                self.d.Constant.SetF64(-self.d.Constant.ReadF64())
            | self.d.Constant.IsI64():
                self.d.Constant.SetI64(-self.d.Constant.ReadI64())
            | self.d.Constant.IsU64():
                self.d.Constant.SetI64(-self.d.Constant.AsI64())
            |:
                panic("unimplemented constant type for unary.minus, this panic call should be unreachable")
            }
            // Do not self model for constant expressions. It's a overhead,
            // because model will be changed to constant by following algorithm.
            ret
        }

        self.d.Model = &UnaryExprModel{
            Expr: new(Data, *self.d),
            Op: self.u.Op,
        }
    }

    fn plus(mut self) {
        match {
        | self.d.Kind == nil:
            self.d = nil
            ret
        | self.d.Kind.Prim() != nil:
            if !types::IsNum(self.d.Kind.Str()) {
                self.d = nil
                ret
            }
        | self.d.Kind.Struct() != nil:
            if self.d.Kind.Struct().Operators.Pos == nil {
                self.d = nil
                ret
            }
        |:
            self.d = nil
            ret
        }

        self.d.Lvalue = false
        self.d.Mutable = true

        if self.d.IsConst() {
            match {
            | self.d.Constant.IsF64():
                self.d.Constant.SetF64(+self.d.Constant.ReadF64())
            | self.d.Constant.IsI64():
                self.d.Constant.SetI64(+self.d.Constant.ReadI64())
            | self.d.Constant.IsU64():
                self.d.Constant.SetI64(+self.d.Constant.AsI64())
            |:
                panic("unimplemented constant type for unary.plus, this panic call should be unreachable")
            }
            // Do not self model for constant expressions. It's a overhead,
            // because model will be changed to constant by following algorithm.
            ret
        }

        self.d.Model = &UnaryExprModel{
            Expr: new(Data, *self.d),
            Op: self.u.Op,
        }
    }

    fn caret(mut self) {
        match {
        | self.d.Kind == nil:
            self.d = nil
            ret
        | self.d.Kind.Prim() != nil:
            if !types::IsInt(self.d.Kind.Str()) {
                self.d = nil
                ret
            }
        | self.d.Kind.Struct() != nil:
            if self.d.Kind.Struct().Operators.BitNot == nil {
                self.d = nil
                ret
            }
        |:
            self.d = nil
            ret
        }

        self.d.Lvalue = false
        self.d.Mutable = true

        if self.d.IsConst() {
            match {
            | self.d.Constant.IsI64():
                self.d.Constant.SetI64(^self.d.Constant.ReadI64())
            | self.d.Constant.IsU64():
                self.d.Constant.SetU64(^self.d.Constant.ReadU64())
            |:
                panic("unimplemented constant type for unary.caret, this panic call should be unreachable")
            }
            // Do not self model for constant expressions. It's a overhead,
            // because model will be changed to constant by following algorithm.
            ret
        }

        self.d.Model = &UnaryExprModel{
            Expr: new(Data, *self.d),
            Op: self.u.Op,
        }
    }

    fn excl(mut self) {
        t := self.d.Kind.Prim()
        if t == nil || !t.IsBool() {
            self.d = nil
            ret
        }

        self.d.Lvalue = false
        self.d.Mutable = true

        if self.d.IsConst() {
            match {
            | self.d.Constant.IsBool():
                self.d.Constant.SetBool(!self.d.Constant.ReadBool())
            |:
                panic("unimplemented constant type for unary.excl, this panic call should be unreachable")
            }
            // Do not self model for constant expressions. It's a overhead,
            // because model will be changed to constant by following algorithm.
            ret
        }

        self.d.Model = &UnaryExprModel{
            Expr: new(Data, *self.d),
            Op: self.u.Op,
        }
    }

    fn star(mut self) {
        self.d.Model = &UnaryExprModel{
            Expr: new(Data, *self.d),
            Op: self.u.Op,
        }

        match {
        | self.d.Kind.Ptr() != nil:
            if !self.e.isUnsafe() {
                self.e.pushErr(self.u.Op, LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
            }

            mut t := self.d.Kind.Ptr()
            if t.IsUnsafe() {
                self.d = nil
                ret
            }
            self.d.Kind = t.Elem
            self.d.Mutable = true
        | self.d.Kind.Sptr() != nil:
            self.d.Kind = self.d.Kind.Sptr().Elem
        |:
            self.d = nil
            ret
        }

        self.d.Constant = nil
        self.d.untyped = false
        self.d.Lvalue = true
    }

    fn amper(mut self) {
        match type self.d.Model {
        | &StructLitExprModel:
            mut lit := (&StructLitExprModel)(self.d.Model)
            makeStructLitAlloc(self.d, lit)
        |:
            match {
            | canGetPtr(self.d):
                self.d.Kind = &TypeKind{
                    Kind: &Ptr{Elem: self.d.Kind},
                }
                self.d.Model = &UnaryExprModel{
                    Expr: new(Data, *self.d),
                    Op: self.u.Op,
                }
            |:
                self.d = nil
                ret
            }
        }

        self.d.Constant = nil
        self.d.untyped = false
        self.d.Lvalue = false
        self.d.Mutable = true
    }

    fn typeDecl(mut self) {
        mut tc := typeChecker{
            s: self.e.s,
            rootLookup: self.e.lookup,
            lookup: self.e.lookup,
            errorToken: self.u.Op,
        }
        match self.u.Op.Id {
        | TokenId.Star:
            self.d.Kind = &TypeKind{Kind: tc.buildPtrFromType(self.d.Kind)}
            self.d.Model = self.d.Kind
        | TokenId.Amper:
            self.d.Kind = &TypeKind{Kind: tc.buildSptrFromType(self.d.Kind)}
            self.d.Model = self.d.Kind
        |:
            self.e.pushErr(self.u.Op, LogMsg.InvalidExprForUnary, self.u.Op.Kind, self.d.Kind.Str())
            self.d = nil
            ret
        }
        self.d.Decl = true
    }

    fn evalData(mut self) {
        match self.u.Op.Id {
        | TokenId.Star
        | TokenId.Amper:
            mut prefix := self.e.prefix
            self.e.prefix = nil
            self.d = self.e.eval(self.u.Expr)
            self.e.prefix = prefix
        |:
            self.d = self.e.eval(self.u.Expr)
        }
    }

    fn eval(mut self, mut u: &UnaryExpr): &Data {
        self.u = u
        self.evalData()
        if self.d == nil {
            ret nil
        }
        if self.d.Decl {
            self.typeDecl()
            ret self.d
        }

        kind := self.d.Kind
        match self.u.Op.Id {
        | TokenId.Minus:
            self.minus()
        | TokenId.Plus:
            self.plus()
        | TokenId.Caret:
            self.caret()
        | TokenId.Excl:
            self.excl()
        | TokenId.Star:
            self.star()
        | TokenId.Amper:
            self.amper()
        |:
            self.d = nil
        }

        match {
        | self.d == nil:
            self.e.pushErr(self.u.Op, LogMsg.InvalidExprForUnary, self.u.Op.Kind, kind.Str())
            ret nil
        | self.d.IsConst():
            self.d.Model = self.d.Constant
        }
        ret self.d
    }
}

struct binaryEval {
    e:  &Eval
    l:  &Data
    r:  &Data
    op: &Token
}

impl binaryEval {
    static fn newPlain(mut e: &Eval): binaryEval {
        ret binaryEval{
            e: e,
        }
    }

    static fn new(mut e: &Eval, mut op: &Token): binaryEval {
        ret binaryEval{
            e: e,
            op: op,
        }
    }

    // Reports whether types are compatible.
    // Also logs error message about incompatibility if types are incompatible.
    fn checkTypeCompatibility(mut self): bool {
        ret self.e.s.checkTypeCompatibility1(self.l.Kind, self.r, self.op)
    }

    fn checkStructCommonOperatorCompatibility(mut self): bool {
        let mut overload: &FnIns = nil
        match self.op.Id {
        | TokenId.Shl:
            overload = self.l.Kind.Struct().Operators.Shl
        | TokenId.Shr:
            overload = self.l.Kind.Struct().Operators.Shr
        | TokenId.Plus:
            overload = self.l.Kind.Struct().Operators.Add
        | TokenId.Minus:
            overload = self.l.Kind.Struct().Operators.Sub
        | TokenId.Solidus:
            overload = self.l.Kind.Struct().Operators.Div
        | TokenId.Star:
            overload = self.l.Kind.Struct().Operators.Mul
        | TokenId.Percent:
            overload = self.l.Kind.Struct().Operators.Mod
        | TokenId.Amper:
            overload = self.l.Kind.Struct().Operators.BitAnd
        | TokenId.Vline:
            overload = self.l.Kind.Struct().Operators.BitOr
        | TokenId.Caret:
            overload = self.l.Kind.Struct().Operators.BitXor
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret false
        }

        if overload == nil {
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret false
        }

        mut p := overload.Params[1]
        ret self.e.s.checkAssignType(p.Decl.Reference, p.Kind, self.r, self.op)
    }

    fn evalComptimeTypeInfo(mut self): &Data {
        mut r := self.r.Kind.comptimeTypeInfo()
        if r == nil {
            self.e.pushErr(self.op, LogMsg.IncompatibleTypes, "comptimeTypeInfo", self.r.Kind.Str())
            ret nil
        }
        mut l := self.l.Kind.comptimeTypeInfo()
        match self.op.Id {
        | TokenId.Eqs:
            mut constant := Const.NewBool(l.base.Equal(r.base))
            ret &Data{
                Kind: primBool,
                Constant: constant,
                Model: constant,
            }
        | TokenId.NotEq:
            mut constant := Const.NewBool(!l.base.Equal(r.base))
            ret &Data{
                Kind: primBool,
                Constant: constant,
                Model: constant,
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalNil(mut self): &Data {
        if !self.r.Kind.NilCompatible() {
            self.e.pushErr(self.op, LogMsg.IncompatibleTypes, "nil", self.r.Kind.Str())
            ret nil
        }

        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq:
            ret &Data{
                Kind: primBool,
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, "nil")
            ret nil
        }
    }

    fn evalEnum(mut self): &Data {
        mut enm := self.l.Kind.Enum()
        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq:
            mut rkind := self.r.Kind
            if self.r.Kind.Enum() != nil {
                rkind = self.r.Kind.Enum().Kind.Kind
            }
            if !self.e.s.checkTypeCompatibility(enm.Kind.Kind, rkind, self.op) {
                ret nil
            }
            ret &Data{
                Kind: primBool,
            }
        }

        if self.r.Kind.Enum() == nil || enm != self.r.Kind.Enum() {
            self.e.pushErr(self.op, LogMsg.IncompatibleTypes, enm.Ident, self.r.Kind.Str())
            ret nil
        }

        match self.op.Id {
        | TokenId.Gt
        | TokenId.Lt
        | TokenId.GtEq
        | TokenId.LtEq:
            if !types::IsNum(enm.Kind.Kind.Str()) {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Ident)
                ret nil
            }
            ret &Data{
                Kind: primBool,
            }
        | TokenId.Amper:
            first := enm.Items[0]
            match {
            | first.Value.Data.Constant.IsI64():
                if first.Value.Data.Constant.ReadI64() == 0 {
                    goto next
                }
                goto err
            | first.Value.Data.Constant.IsU64():
                if first.Value.Data.Constant.ReadU64() == 0 {
                    goto next
                }
                goto err
            |:
                panic("unimplemented enum type, this panic call should be unreachable")
            }
        err:
            self.e.pushErr(self.op, LogMsg.AmperOpForEnum, enm.Ident, self.op.Kind)
            self.e.pushSuggestion(LogMsg.DefineZeroDefaultToUseAmper)
        next:
            fall
        | TokenId.Vline
        | TokenId.Caret:
            if enm.Kind.Kind.Prim() == nil || !types::IsInt(enm.Kind.Kind.Prim().Str()) {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Ident)
            }
            ret self.l
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Ident)
            ret nil
        }
    }

    fn evalTypeEnum(mut self): &Data {
        mut enm := self.l.Kind.TypeEnum()
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq:
            ret &Data{
                Kind: primBool,
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Str())
            ret nil
        }
    }

    fn evalSptr(mut self): &Data {
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq:
            ret &Data{
                Kind: primBool,
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalPtr(mut self): &Data {
        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq
        | TokenId.Lt
        | TokenId.Gt
        | TokenId.LtEq
        | TokenId.GtEq:
            if !self.checkTypeCompatibility() {
                ret nil
            }
            ret &Data{
                Kind: primBool,
            }
        | TokenId.Plus
        | TokenId.Minus:
            if self.l.Kind.Ptr() == nil {
                self.l, self.r = self.r, self.l
            }
            if self.l.Kind.Ptr().IsUnsafe() {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            }
            if !isPtrArithmeticCompatible(self.l, self.r) {
                self.e.pushErr(self.op, LogMsg.IncompatibleTypeForPtrArithmetic, self.r.Kind.Str())
                ret nil
            }
            ret self.l
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalArr(mut self): &Data {
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq:
            ret &Data{
                Kind: primBool,
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalSlc(mut self): &Data {
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq:
            ret &Data{
                Kind: primBool,
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalStruct(mut self): &Data {
        match self.op.Id {
        | TokenId.Gt:
            if self.l.Kind.Struct().Operators.Gt == nil {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
                ret nil
            }
            ret &Data{
                Kind: primBool,
            }
        | TokenId.GtEq:
            if self.l.Kind.Struct().Operators.GtEq == nil {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
                ret nil
            }
            ret &Data{
                Kind: primBool,
            }
        | TokenId.Lt:
            if self.l.Kind.Struct().Operators.Lt == nil {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
                ret nil
            }
            ret &Data{
                Kind: primBool,
            }
        | TokenId.LtEq:
            if self.l.Kind.Struct().Operators.LtEq == nil {
                self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
                ret nil
            }
            ret &Data{
                Kind: primBool,
            }
        | TokenId.Eqs
        | TokenId.NotEq:
            if !self.checkTypeCompatibility() {
                ret nil
            }
            ret &Data{
                Kind: primBool,
            }
        }

        if !self.checkStructCommonOperatorCompatibility() {
            ret nil
        }
        ret self.l
    }

    fn evalTrait(mut self): &Data {
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq:
            ret &Data{
                Kind: primBool,
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalAny(mut self): &Data {
        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq:
            ret &Data{
                Kind: primBool,
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, PrimKind.Any)
            ret nil
        }
    }

    fn evalBool(mut self): &Data {
        if !self.checkTypeCompatibility() {
            ret nil
        }

        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq
        | TokenId.DblAmper
        | TokenId.DblVline:
            ret self.l
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalStr(mut self): &Data {
        mut rk := self.r.Kind.Str()
        if rk != PrimKind.Str {
            self.e.pushErr(self.op, LogMsg.IncompatibleTypes, PrimKind.Str, rk)
            ret nil
        }

        match self.op.Id {
        | TokenId.Plus:
            ret self.l
        | TokenId.Eqs
        | TokenId.NotEq
        | TokenId.Lt
        | TokenId.Gt
        | TokenId.GtEq
        | TokenId.LtEq:
            ret &Data{
                Kind: primBool,
            }
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, PrimKind.Str)
            ret nil
        }
    }

    fn setTypeToGreater(mut self) {
        lp := self.l.Kind.Prim()
        rp := self.r.Kind.Prim()
        if self.l.IsConst() {
            if !self.r.IsConst() {
                self.l.Kind = self.r.Kind
                self.l.Constant.Kind = rp.Kind
                ret
            }
            goto set
        }
        if self.r.IsConst() {
            self.r.Constant.Kind = lp.Kind
            ret
        }
    set:
        if self.l.untyped && !self.r.untyped {
            self.l.Kind = self.r.Kind
            if self.l.IsConst() {
                self.l.Constant.Kind = rp.Kind
            }
            self.l.untyped = false
            ret
        } else if !self.l.untyped && self.r.untyped {
            ret
        }
        if types::IsGreater(rp.Kind, lp.Kind) {
            self.l.Kind = self.r.Kind
            if self.l.IsConst() {
                self.l.Constant.Kind = rp.Kind
            }
        }
    }

    fn checkModData(mut self, mut &d: &Data) {
        if !d.IsConst() {
            if d.Kind.Prim() == nil || !types::IsInt(d.Kind.Prim().Kind) {
                self.e.pushErr(self.op, LogMsg.ModuloWithNotInt)
            }
            ret
        }
        match {
        | sigAssignable(PrimKind.I64, d):
            d.Constant.SetI64(d.Constant.AsI64())
        | unsigAssignable(PrimKind.U64, d):
            d.Constant.SetU64(d.Constant.AsU64())
        |:
            self.e.pushErr(self.op, LogMsg.ModuloWithNotInt)
        }
    }

    fn mod(mut self) {
        self.checkModData(self.l)
        self.checkModData(self.r)
    }

    fn numbersAreCompatibile(self, &lk: str, &rk: str): bool {
        if !types::IsNum(rk) {
            ret false
        }
        if self.l.IsConst() && self.l.untyped {
            ret true
        }
        if lk == types::TypeKind.F32 {
            if self.r.IsConst() && self.r.untyped {
                ret floatAssignable(lk, self.r)
            }
            ret rk == types::TypeKind.F32
        }
        if lk == types::TypeKind.F64 {
            if self.r.IsConst() && self.r.untyped {
                ret floatAssignable(lk, self.r)
            }
            ret rk == types::TypeKind.F64
        }
        if self.r.IsConst() && self.r.untyped {
            ret intAssignable(lk, self.r)
        }
        ret lk == rk
    }

    fn evalFloat(mut self): &Data {
        lk := self.l.Kind.Prim().Kind // Float guaranteed.
        rk := self.r.Kind.Prim().Kind // Primitive guaranteed.
        if !self.numbersAreCompatibile(lk, rk) {
            self.e.s.pushCompatiblityError(self.l.Kind, self.r, self.op)
            ret nil
        }

        match self.op.Id {
        | TokenId.Shl
        | TokenId.Shr:
            if !self.l.IsConst() || !intAssignable(PrimKind.I64, self.l) {
                self.e.pushErr(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            if !self.r.IsConst() || !intAssignable(PrimKind.U64, self.r) {
                self.e.pushErr(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            self.l.Constant.SetI64(self.l.Constant.AsI64())
            self.r.Constant.SetU64(self.r.Constant.AsU64())
            if !isOkForShifting(self.r) {
                self.e.pushErr(self.op, LogMsg.BitShiftMustUnsigned)
                ret nil
            }
            ret self.l
        }

        // Logicals.
        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq
        | TokenId.Lt
        | TokenId.Gt
        | TokenId.GtEq
        | TokenId.LtEq:
            self.setTypeToGreater()
            ret &Data{
                Kind: primBool,
            }
        }

        // Arithmetics.
        match self.op.Id {
        | TokenId.Plus
        | TokenId.Minus
        | TokenId.Star
        | TokenId.Solidus:
            self.setTypeToGreater()
            ret self.l
        | TokenId.Percent:
            if !types::IsInt(rk) {
                self.e.pushErr(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            self.mod()
            self.setTypeToGreater()
            ret self.r
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForFloat, self.op.Kind)
            ret nil
        }
    }

    fn evalInt(mut self): &Data {
        lk := self.l.Kind.Prim().Kind // Integer guaranteed.
        rk := self.r.Kind.Prim().Kind // Primitive guaranteed.

        match self.op.Id {
        | TokenId.Shl
        | TokenId.Shr:
            if !types::IsInt(lk) || !types::IsInt(rk) {
                self.e.pushErr(self.op, LogMsg.IncompatibleTypes, lk, rk)
                ret nil
            }
            if !isOkForShifting(self.r) {
                self.e.pushErr(self.op, LogMsg.BitShiftMustUnsigned)
                ret nil
            }
            ret self.l
        }

        if !self.numbersAreCompatibile(lk, rk) {
            self.e.s.pushCompatiblityError(self.l.Kind, self.r, self.op)
            ret nil
        }

        // Logicals.
        match self.op.Id {
        | TokenId.Eqs
        | TokenId.NotEq
        | TokenId.Lt
        | TokenId.Gt
        | TokenId.GtEq
        | TokenId.LtEq:
            ret &Data{
                Kind: primBool,
            }
        }

        // Arithmetics.
        match self.op.Id {
        | TokenId.Plus
        | TokenId.Minus
        | TokenId.Star
        | TokenId.Solidus
        | TokenId.Amper
        | TokenId.Vline
        | TokenId.Caret:
            self.setTypeToGreater()
            ret self.l
        | TokenId.Percent:
            self.mod()
            self.setTypeToGreater()
            ret self.l
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForInt, self.op.Kind)
            ret nil
        }
    }

    fn evalPrim(mut self): &Data {
        prim := self.l.Kind.Prim()
        match {
        | prim.IsBool():
            ret self.evalBool()
        | prim.IsStr():
            ret self.evalStr()
        }

        if self.r.Kind.Prim() == nil {
            self.e.pushErr(self.op, LogMsg.IncompatibleTypes, prim.Str(), self.r.Kind.Str())
            ret nil
        }

        match {
        | types::IsFloat(prim.Kind):
            ret self.evalFloat()
        | types::IsInt(prim.Kind):
            ret self.evalInt()
        |:
            ret nil
        }
    }

    fn checkSpecialCases(mut self) {
        if !self.l.Kind.Comparable() && !self.r.Kind.IsNil() {
            self.e.pushErr(self.op, LogMsg.TypeIsNotComparable, self.l.Kind.Str())
        } else if !self.r.Kind.Comparable() && !self.l.Kind.IsNil() {
            self.e.pushErr(self.op, LogMsg.TypeIsNotComparable, self.r.Kind.Str())
        }
    }

    fn evalOp(mut self): &Data {
        self.checkSpecialCases()
        match {
        | self.l.Kind.Void():
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, "void")
            ret nil
        | self.r.Kind.comptimeTypeInfo() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.comptimeTypeInfo() != nil:
            ret self.evalComptimeTypeInfo()
        | self.r.Kind.Prim() != nil && self.r.Kind.Prim().IsAny():
            self.l, self.r = self.r, self.l
            fall
        | self.r.Kind.IsNil():
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.IsNil():
            ret self.evalNil()
        | self.l.Kind.Prim() != nil && self.l.Kind.Prim().IsAny():
            ret self.evalAny()
        | self.r.Kind.TypeEnum() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.TypeEnum() != nil:
            ret self.evalTypeEnum()
        | self.r.Kind.Enum() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.Enum() != nil:
            ret self.evalEnum()
        | self.r.Kind.Sptr() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.Sptr() != nil:
            ret self.evalSptr()
        | self.r.Kind.Ptr() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.Ptr() != nil:
            ret self.evalPtr()
        | self.l.Kind.Arr() != nil:
            ret self.evalArr()
        | self.l.Kind.Slc() != nil:
            ret self.evalSlc()
        | self.r.Kind.Trait() != nil:
            self.l, self.r = self.r, self.l
            fall
        | self.l.Kind.Trait() != nil:
            ret self.evalTrait()
        | self.l.Kind.Struct() != nil:
            ret self.evalStruct()
        | self.l.Kind.Prim() != nil:
            ret self.evalPrim()
        |:
            self.e.pushErr(self.op, LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Kind.Str())
            ret nil
        }
    }

    fn evalConst(mut self, mut &d: &Data) {
        match {
        | d == nil
        | self.l.Model == nil
        | self.r.Model == nil:
            ret
        | !self.l.IsConst()
        | !self.r.IsConst():
            d.Constant = nil
            d.untyped = false
            ret
        }

        match self.op.Id {
        | TokenId.Eqs:
            d.Constant = Const.NewBool(self.l.Constant.Eq(*self.r.Constant))
        | TokenId.NotEq:
            d.Constant = Const.NewBool(!self.l.Constant.Eq(*self.r.Constant))
        | TokenId.DblVline:
            d.Constant = Const.NewBool(self.l.Constant.Or(*self.r.Constant))
        | TokenId.DblAmper:
            d.Constant = Const.NewBool(self.l.Constant.And(*self.r.Constant))
        | TokenId.Gt:
            d.Constant = Const.NewBool(self.l.Constant.Gt(*self.r.Constant))
        | TokenId.Lt:
            d.Constant = Const.NewBool(self.l.Constant.Lt(*self.r.Constant))
        | TokenId.GtEq:
            d.Constant = Const.NewBool(self.l.Constant.GtEq(*self.r.Constant))
        | TokenId.LtEq:
            d.Constant = Const.NewBool(self.l.Constant.LtEq(*self.r.Constant))
        | TokenId.Plus:
            _ = self.l.Constant.Add(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenId.Minus:
            _ = self.l.Constant.Sub(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenId.Star:
            _ = self.l.Constant.Mul(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenId.Solidus:
            ok := self.l.Constant.Div(*self.r.Constant)
            if !ok && self.r.Constant.AsF64() == 0 {
                self.e.pushErr(self.op, LogMsg.DivByZero)
            }
            d.Constant = self.l.Constant
            mut prim := d.Kind.Prim()
            match {
            | types::IsSigInt(prim.Kind):
                d.Constant.SetI64(d.Constant.AsI64())
            | types::IsUnsigInt(prim.Kind):
                d.Constant.SetU64(d.Constant.AsU64())
            }
        | TokenId.Percent:
            ok := self.l.Constant.Mod(*self.r.Constant)
            if !ok && self.r.Constant.AsF64() == 0 {
                self.e.pushErr(self.op, LogMsg.DivByZero)
            }
            d.Constant = self.l.Constant
        | TokenId.Vline:
            _ = self.l.Constant.BitwiseOr(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenId.Amper:
            _ = self.l.Constant.BitwiseAnd(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenId.Caret:
            _ = self.l.Constant.Xor(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenId.Shl:
            _ = self.l.Constant.Lshift(*self.r.Constant)
            d.Constant = self.l.Constant
        | TokenId.Shr:
            _ = self.l.Constant.Rshift(*self.r.Constant)
            d.Constant = self.l.Constant
        }
        d.Model = d.Constant
        applyCastModelByEnum(d, d.Kind.Enum(), self.op)
    }

    fn checkData(mut self, mut &d: &Data) {
        f := d.Kind.Fn()
        if f != nil && f.Decl != nil && f.Decl.IsMethod() {
            self.e.pushErr(self.op, LogMsg.InvalidExprForBinary)
        }
    }

    fn checkDatas(mut self) {
        self.checkData(self.l)
        self.checkData(self.r)
    }

    fn setModel(mut self, mut &d: &Data) {
        if d.IsConst() {
            if self.l.IsConst() && self.r.IsConst() ||
                self.l.Model == nil && self.r.Model == nil {
                // Left and right are pure constant or comptime expression.
                // Do not break this with changing Model.
                ret
            }
        }
        mut l, mut r := self.l, self.r
        if !l.GoodOperand(r) {
            l, r = r, l
        }

        d.Model = &BinaryExprModel{
            Left: &OperandExprModel{
                Kind: l.Kind,
                Model: l.Model,
            },
            Right: &OperandExprModel{
                Kind: r.Kind,
                Model: r.Model,
            },
            Op: self.op,
        }
    }

    fn postEval(mut self, mut &d: &Data) {
        d.Lvalue = false
        self.setModel(d)
    }

    fn solveExplicit(mut self, mut &l: &Data, mut &r: &Data): &Data {
        self.l, self.r = l, r

        self.checkDatas()

        mut d := self.evalOp()

        // Save normal order
        self.l, self.r = l, r

        self.evalConst(d)

        if d != nil {
            d.Mutable = true
            self.postEval(d)
        }

        ret d
    }

    fn eval(mut self, mut &op: &BinaryExpr): &Data {
        if op.Op.Id == TokenId.Eq {
            self.e.pushErr(op.Op, LogMsg.AssignInExpr)
            self.e.pushSuggestion(LogMsg.UseImperative)
            ret nil
        }

        mut l := self.e.evalExpr1(op.Left)
        if l == nil || l.Kind == nil {
            ret nil
        }

        mut prefix := self.e.prefix
        self.e.prefix = l.Kind
        defer { self.e.prefix = prefix }
        mut r := self.e.evalExpr1(op.Right)
        if r == nil || r.Kind == nil {
            ret nil
        }

        self.op = op.Op

        mut d := self.solveExplicit(l, r)

        // Save rune type.
        if d != nil && l.IsRune && r.IsRune {
            d.IsRune = true
        }

        ret d
    }
}

// Returns directive if exist.
fn findDirective(mut &directives: []&ast::Directive, d: Directive): &ast::Directive {
    for (_, mut dr) in directives {
        if dr.Tag.Kind == d {
            ret dr
        }
    }
    ret nil
}

fn findBuiltinsImport(&ident: str, imp: &ImportInfo): any {
    ret findPackageBuiltinDef(imp.LinkPath, ident)
}

// If current type is not enough to store constant data, update to minimum type
// that can store constant data. This function designed for numerical types only.
// Data should be numerical constant of course. Also fits types for integers.
// If data is signed but kind is unsigned, type will be fit to signed and same
// thing for unsigned data and signed kinds.
fn fitBitsize(mut &d: &Data) {
    mut prim := d.Kind.Prim()
    z := types::BitsizeOf(prim.Str())
    match {
    | d.Constant.IsI64():
        k := types::BitsizeOfInt(d.Constant.ReadI64())
        if k > z || types::IsUnsigInt(prim.Kind) {
            d.Constant.Kind = types::IntFromBits(k)
            d.Kind = findBuiltinTypeAlias(d.Constant.Kind).Kind.Kind
        }
    | d.Constant.IsU64():
        k := types::BitsizeOfUint(d.Constant.ReadU64())
        if k > z || types::IsSigInt(prim.Kind) {
            d.Constant.Kind = types::UintFromBits(k)
            d.Kind = findBuiltinTypeAlias(d.Constant.Kind).Kind.Kind
        }
    | d.Constant.IsF64():
        if z == 1<<6 {
            // z is already equals to biggest bitsize.
            ret
        }
        k := types::BitsizeOfFloat(d.Constant.ReadF64())
        if k > z {
            d.Constant.Kind = types::FloatFromBits(k)
            d.Kind = findBuiltinTypeAlias(d.Constant.Kind).Kind.Kind
        }
    }
}

fn makeStructLitAlloc(mut &d: &Data, mut &lit: &StructLitExprModel) {
    d.Kind = &TypeKind{
        Kind: &Sptr{
            Elem: &TypeKind{Kind: lit.Strct},
        },
    }
    d.Model = &AllocStructLitExprModel{
        Lit: lit,
    }
}

fn buildErrorVar(mut &s: &Scope, mut &fc: &FnCallExpr): &Var {
    ret &Var{
        Used: true,
        Reference: false,
        Mutable: true,
        Ident: "error",
        Token: fc.Token,
        Kind: findBuiltinTypeAlias(PrimKind.Any).Kind,
        Scope: s,
        Value: &Value{
            Data: new(Data),
        },
    }
}

fn findBuiltinsSema(&ident: str, mut s: &Sema): any {
    for (_, mut imp) in s.file.Imports {
        if imp.ImportAll || imp.existIdent(ident) {
            mut def := findBuiltinsImport(ident, imp)
            if def != nil {
                ret def
            }
        }
    }

    // If package is std, check for internal builtin defines.
    mut ppath := s.file.File.Dir()
    if strings::HasPrefix(ppath, PathStdlib) {
        // Remove STDLIB directory path.
        ppath = ppath[len(PathStdlib):]
        // Add "std" to beginning without separator
        // because path has separator at beginning.
        ppath = "std" + strings::Replace(ppath, str(path::Separator), "::", -1)

        ret findPackageBuiltinDef(ppath, ident)
    }

    ret nil
}

fn isOkForShifting(mut &d: &Data): bool {
    if d.IsConst() {
        match {
        | d.Constant.IsI64():
            ret d.Constant.ReadI64() >= 0
        | d.Constant.IsU64():
            ret true
        | d.Constant.IsF64():
            ret d.Constant.ReadF64() >= 0
        |:
            ret false
        }
    }
    prim := d.Kind.Prim()
    ret prim != nil && types::IsInt(prim.Str())
}

fn isInstancedStruct(s: &StructIns): bool {
    ret len(s.Decl.Generics) == len(s.Generics)
}

fn isPtrArithmeticCompatible(mut &l: &Data, mut &r: &Data): bool {
    ptr := r.Kind.Ptr()
    if ptr != nil {
        ret l.Kind.Ptr().Elem.Equal(ptr.Elem)
    }
    if r.IsConst() {
        ret intAssignable(types::TypeKind.Int, r)
    }
    mut tcc := typeCompatibilityChecker{
        dest: primInt,
        src: r.Kind,
    }
    ret tcc.check()
}

fn applyCastKindModel(mut &d: &Data, mut &t: &TypeKind, mut &token: &Token) {
    d.Model = &CastingExprModel{
        Token: token,
        Expr: new(Data, *d),
        Kind: t,
        ExprKind: d.Kind,
    }
}

fn applyCastKind(mut &d: &Data, mut &t: &TypeKind, mut &token: &Token) {
    applyCastKindModel(d, t, token)
    d.Kind = t
}

fn buildVoidData(): &Data {
    ret &Data{
        Kind: primVoid,
    }
}

fn checkDataForIntegerIndexing(mut &d: &Data, mut &token: &Token): (errFmt: LogMsg) {
    if d == nil {
        ret LogMsg.Empty
    }

    match {
    | d.Kind.Prim() == nil:
        ret LogMsg.InvalidTypeForIndexing
    | !types::IsInt(d.Kind.Prim().Str()):
        ret LogMsg.InvalidTypeForIndexing
    | d.IsConst():
        if d.Constant.AsF64() < 0 {
            ret LogMsg.OverflowLimits
        }
    | d.Kind.Prim() == nil
    | d.IsConst()
    | types::RealKindOf(d.Kind.Prim().Str()) != types::RealKindOf(PrimKind.Int):
        applyCastKind(d, primInt, token)
    }
    ret LogMsg.Empty
}

// Applies casting Model: to data by enum.
// This is necessary to keep exact same type of enum's field type.
// The parameter d should be constant data.
fn applyCastModelByEnum(mut &d: &Data, mut e: &Enum, mut &token: &Token) {
    if e == nil {
        ret
    }
    p := e.Kind.Kind.Prim()
    if p.IsStr() {
        ret
    }
    applyCastKindModel(d, e.Kind.Kind, token)
}

fn castConstByType(&t: str, mut &d: &Data) {
    match {
    | types::IsSigInt(t):
        match types::BitsizeOf(types::RealKindOf(t)) {
        | 1 << 6:
            d.Constant.SetI64(d.Constant.AsI64())
        | 1 << 5:
            d.Constant.SetI64(i64(i32(d.Constant.AsI64())))
        | 1 << 4:
            d.Constant.SetI64(i64(i16(d.Constant.AsI64())))
        | 1 << 3:
            d.Constant.SetI64(i64(i8(d.Constant.AsI64())))
        }
    | types::IsUnsigInt(t):
        match types::BitsizeOf(types::RealKindOf(t)) {
        | 1 << 6:
            d.Constant.SetU64(d.Constant.AsU64())
        | 1 << 5:
            d.Constant.SetU64(u64(u32(d.Constant.AsU64())))
        | 1 << 4:
            d.Constant.SetU64(u64(u16(d.Constant.AsU64())))
        | 1 << 3:
            d.Constant.SetU64(u64(u8(d.Constant.AsU64())))
        }
    | types::IsFloat(t):
        match types::BitsizeOf(types::RealKindOf(t)) {
        | 1 << 6:
            d.Constant.SetF64(d.Constant.AsF64())
        | 1 << 5:
            d.Constant.SetF64(f64(f32(d.Constant.AsF64())))
        }
    }
}

fn updateModelToGenericIns(mut &m: ExprModel, mut &f: &FnIns) {
    match type m {
    | &FnIns:
        m = f
    | &StructSubIdentExprModel:
        (&StructSubIdentExprModel)(m).Method = f
    | &StructStaticIdentExprModel:
        (&StructStaticIdentExprModel)(m).Method = f
    }
}

fn pushSubIdentFromExpr(mut expr: ExprData, mut &t: &SubIdentTypeDecl): bool {
    match type expr {
    | &IdentExpr:
        mut e := (&IdentExpr)(expr)
        t.Idents = append(t.Idents, &IdentTypeDecl{
            Token: e.Token,
            Ident: e.Ident,
        })
    | &SubIdentExpr:
        mut e := (&SubIdentExpr)(expr)
        if !pushSubIdentFromExpr(e.Expr.Kind, t) {
            ret false
        }
        t.Idents = append(t.Idents, &IdentTypeDecl{
            Token: e.Ident,
            Ident: e.Ident.Kind,
        })
    |:
        ret false
    }
    ret true
}

fn constoa(&c: &Const): str {
    match {
    | c.IsI64():
        ret conv::FmtInt(c.ReadI64(), 10)
    | c.IsU64():
        ret conv::FmtUint(c.ReadU64(), 10)
    |:
        ret ""
    }
}

fn evalEnumStatic(mut &enm: &Enum, mut &item: &EnumItem, mut &token: &Token): &Data {
    mut d := &Data{
        Kind: &TypeKind{
            Kind: enm,
        },
    }
    if item != nil {
        d.Constant = new(Const, *item.Value.Data.Constant)
        d.Model = d.Constant
        applyCastModelByEnum(d, enm, token)
    }
    ret d
}

// Reports whether expression model is literal-based.
// Works for literals, sub-idents and castings.
// Returns nil if not, otherwise returns the literal model.
fn isLitBased(mut &m: ExprModel): &StructLitExprModel {
    match type m {
    | &StructLitExprModel:
        ret (&StructLitExprModel)(m)
    | &AllocStructLitExprModel:
        ret (&AllocStructLitExprModel)(m).Lit
    | &StructSubIdentExprModel:
        mut ssi := (&StructSubIdentExprModel)(m)
        ret isLitBased(ssi.Expr.Model)
    | &CastingExprModel:
        mut c := (&CastingExprModel)(m)
        ret isLitBased(c.Expr.Model)
    |:
        ret nil
    }
}

fn makeImplicitDeref(mut &d: &Data, mut baseToken: &Token) {
    mut unary := &UnaryExprModel{
        Expr: new(Data, *d),
        Op: new(Token, *baseToken),
    }
    unary.Op.Id = TokenId.Star
    unary.Op.Kind = TokenKind.Star
    d.Model = unary
}

// Updates ref's old references to new.
fn updateRefer[T](mut ref: &ReferenceStack, &old: T, mut &new: T) {
    for i, sym in ref.buffer {
        if sym == old {
            ref.buffer[i] = new
        }
    }
}