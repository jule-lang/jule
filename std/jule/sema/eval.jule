// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/conv"
use "std/jule"
use "std/jule/ast"
use "std/jule/build"
use "std/jule/constant"
use "std/jule/constant/lit"
use "std/jule/internal/mod"
use "std/jule/token"
use "std/jule/types"
use "std/os/filepath"
use "std/strings"
use "std/unsafe"

// Value data.
struct Data {
	// Means data is constant numeric and have not any exact type.
	// Since data is constant numeric, it also implies kind is primitive.
	untyped: bool

	Type:      &Type
	Mutable:   bool
	Reference: bool
	Lvalue:    bool
	IsRune:    bool
	Model:     Expr

	// True if kind is declaration such as:
	//  - &Enum
	//  - &Struct
	//  - int type
	//  - bool type
	Decl: bool

	// Constant expression data.
	Constant: &constant::Const
}

impl Data {
	// Reports whether Data is nil literal.
	fn IsNil(self): bool {
		ret self.Type.IsNil()
	}

	// Reports whether Data is void.
	fn IsVoid(self): bool {
		ret self.Type.Void()
	}

	// Reports whether Data is constant expression.
	fn IsConst(self): bool {
		ret self.Constant != nil
	}

	// See developer reference (9.2).
	// Reports left and right operand is good order.
	// If reports false, left and right operand should be swapped.
	// Accepts itself as left operand.
	fn GoodOperand(self, mut &other: &Data): bool {
		if other.Type.TypeEnum() != nil {
			ret false
		}
		ret (other.Type.Prim() == nil || !other.Type.Prim().IsAny()) &&
			other.Type.Trait() == nil &&
			!self.Type.IsNil()
	}
}

// Value.
struct Value {
	Expr: &ast::Expr
	Data: &Data
}

// Informations about expressions that evaluating for assignments.
struct target {
	ignored: bool // whether the destination ignores the evaluated expression.
	mutable: bool // Will be assigned to the mutable storage.
}

// Evaluator.
struct eval {
	s:          &sema // Used for error logging.
	lookup:     Lookup
	prefix:     &Type
	unsafety:   bool
	disBuiltin: bool // Disallow/suppress Jule's built-in defines.
	owner:      &Var
	field:      &FieldIns // Field of this default expression. Used for checking cycles and dependency collection.
	target:     target
}

impl eval {
	fn pushErr(mut self, token: &token::Token, fmt: build::LogMsg, args: ...any) {
		self.s.pushErr(token, fmt, args...)
	}

	// Push suggestion to last log.
	fn pushSuggestion(mut self, fmt: build::LogMsg, args: ...any) {
		self.s.pushSuggestion(fmt, args...)
	}

	fn allowBuiltin(mut self) {
		self.disBuiltin = false
	}

	fn disallowBuiltin(mut self) {
		self.disBuiltin = true
	}

	// Reports whether evaluation in unsafe scope.
	fn isUnsafe(self): bool {
		ret self.unsafety
	}

	// Reports whether evaluated expression is in global scope.
	fn isGlobal(self): bool {
		match type self.lookup {
		| &sema:
			ret true
		|:
			ret false
		}
	}

	fn applyNumericPrefix(mut self, mut &d: &Data): bool {
		if d == nil ||
			!d.IsConst() ||
			d.Type.Prim() == nil ||
			self.prefix == nil {
			ret false
		}
		prim := self.prefix.Prim()
		if prim == nil {
			ret false
		}

		match {
		| types::IsFloat(prim.Str()):
			d.Type = new(Type, *self.prefix)
			d.Constant.SetF64(d.Constant.AsF64())
			d.Constant.Kind = prim.Kind
		| types::IsSigInt(prim.Str()):
			if !sigAssignable(prim.Str(), d) {
				ret false
			}
			d.Type = new(Type, *self.prefix)
			d.Constant.SetI64(d.Constant.AsI64())
			d.Constant.Kind = prim.Kind
		| types::IsUnsigInt(prim.Str()):
			if !unsigAssignable(prim.Str(), d) {
				ret false
			}
			d.Type = new(Type, *self.prefix)
			d.Constant.SetU64(d.Constant.AsU64())
			d.Constant.Kind = prim.Kind
		}
		ret true
	}

	fn litStr(self, &l: &ast::LitExpr): &Data {
		mut s := ""
		if token::IsRawStr(l.Value) {
			s = lit::ToRawStr(l.Value)
		} else {
			s = lit::ToStr(l.Value)
		}
		mut constant := constant::Const.NewStr(s)

		ret &Data{
			Mutable: true,
			Constant: constant,
			Type: primStr,
			Model: constant,
		}
	}

	fn litRune(self, &l: &ast::LitExpr): &Data {
		r := lit::ToRune(l.Value)
		mut data := &Data{
			Constant: constant::Const.NewI64(i64(r)),
		}

		if r <= 255 {
			data.Type = primU8 // Byte
		} else {
			data.Type = primI32 // Rune
		}

		data.Model = &RuneExpr{Code: r}
		data.Mutable = true
		data.IsRune = true
		data.untyped = true
		ret data
	}

	fn litFloat(self, &l: &ast::LitExpr): &Data {
		f := conv::ParseFloat(l.Value, 64) else { use f64.Max }
		mut constant := constant::Const.NewF64(f)
		ret &Data{
			untyped: true,
			Mutable: true,
			Constant: constant,
			Type: primF64,
			Model: constant,
		}
	}

	fn litInt(mut self, &l: &ast::LitExpr): &Data {
		const BitSize = 1 << 6

		mut lit := l.Value
		mut base := 0

		match {
		| strings::HasPrefix(lit, "0x"): // Hexadecimal
			lit = lit[2:]
			base = 1 << 4
		| strings::HasPrefix(lit, "0b"): // Binary
			lit = lit[2:]
			base = 1 << 1
		| strings::HasPrefix(lit, "0o"): // Ocatal
			lit = lit[2:]
			base = 1 << 3
		| lit[0] == '0' && len(lit) > 1: // Octal
			lit = lit[1:]
			base = 1 << 3
		|:
			// Decimal
			base = 1<<3 + 2
		}

		mut d := new(Data)

		mut ok := true
		sig := conv::ParseInt(lit, base, BitSize) else {
			ok = false
			use 0
		}
		if ok {
			d.Constant = constant::Const.NewI64(sig)
			d.Type = primInt
		} else {
			unsig := conv::ParseUint(lit, base, BitSize) else {
				self.pushErr(l.Token, build::LogMsg.InvalidNumericRange)
				self.pushSuggestion(build::LogMsg.TryFloatingPoint)
				use u64.Max
			}
			d.Constant = constant::Const.NewU64(unsig)
			d.Type = primUint
		}

		d.Model = d.Constant
		d.untyped = true
		if !self.applyNumericPrefix(d) {
			// If prefix is not implemented, check constant bitsize.
			// Arcihtecture bitsize type might be insufficient to store constant data.
			// If this concern is true, set kind to minimum type that has enough bitsize.
			fitBitsize(d)
		}
		ret d
	}

	fn litNum(mut self, &l: &ast::LitExpr): &Data {
		match {
		| token::IsFloat(l.Value):
			ret self.litFloat(l)
		|:
			ret self.litInt(l)
		}
	}

	fn evalLit(mut self, lit: &ast::LitExpr): &Data {
		match {
		| token::IsStr(lit.Value):
			ret self.litStr(lit)
		| token::IsRune(lit.Value):
			ret self.litRune(lit)
		| token::IsNum(lit.Value):
			ret self.litNum(lit)
		|:
			ret nil
		}
	}

	fn findBuiltins(mut self, &ident: str): any {
		if mod::IsPub(ident) {
			match type self.lookup {
			| &ImportInfo:
				mut def := findBuiltinsImport(ident, (&ImportInfo)(self.lookup))
				if def != nil {
					ret def
				}
			| &sema:
				mut def := findBuiltinsSema(ident, (&sema)(self.lookup))
				if def != nil {
					ret def
				}
			| &scopeChecker:
				mut def := findBuiltinsSema(ident, (&scopeChecker)(self.lookup).s)
				if def != nil {
					ret def
				}
			}
			ret nil
		}
		if self.disBuiltin {
			ret nil
		}
		ret findBuiltinDef(ident)
	}

	fn getDef(mut self, &ident: str, binded: bool): any {
		// Find variables and type aliases first.
		// Because self.lookup might be a scopeChecker, and shadowing may occurred.
		// If any variable or type aliases is shadowing other declarations such us structure,
		// it will result as wrong expression evaluation.
		mut v := self.lookup.FindVar(ident, binded)
		if v != nil {
			ret v
		}

		mut ta := self.lookup.FindTypeAlias(ident, binded)
		if ta != nil {
			ret ta
		}

		if !binded {
			mut enm := self.lookup.FindEnum(ident)
			if enm != nil {
				ret enm
			}

			mut tenm := self.lookup.FindTypeEnum(ident)
			if tenm != nil {
				ret tenm
			}
		}

		mut f := self.lookup.FindFn(ident, binded)
		if f != nil {
			ret f
		}

		mut s := self.lookup.FindStruct(ident, binded)
		if s != nil {
			ret s
		}

		ret self.findBuiltins(ident)
	}

	fn getOwnerRefers(mut self): &ReferenceStack {
		match type self.lookup {
		| &scopeChecker:
			ret (&scopeChecker)(self.lookup).getOwnerRefers()
		|:
			// Push reference to owner if global.
			if self.owner != nil &&
				self.owner.Scope == nil {
				ret self.owner.Refers
			}
			// If field exist, push reference to struct.
			if self.field != nil {
				ret self.field.Owner.Refers
			}
		}
		ret nil
	}

	fn pushReference[T](mut self, mut &ref: T) {
		mut refers := self.getOwnerRefers()
		if refers != nil && !refers.Exist[T](ref) {
			refers.Push(ref)
		}
	}

	fn _evalEnum(self, mut enm: &Enum): &Data {
		ret &Data{
			Decl: true,
			Type: &Type{
				Kind: enm,
			},
		}
	}

	fn evalEnum(mut self, mut enm: &Enum, errorToken: &token::Token): &Data {
		if !self.s.isAccessibleDefine(enm.Public, enm.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, enm.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}
		ret self._evalEnum(enm)
	}

	fn _evalTypeEnum(self, mut enm: &TypeEnum): &Data {
		ret &Data{
			Decl: true,
			Type: &Type{
				Kind: enm,
			},
		}
	}

	fn evalTypeEnum(mut self, mut enm: &TypeEnum, errorToken: &token::Token): &Data {
		if !self.s.isAccessibleDefine(enm.Public, enm.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, enm.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}
		ret self._evalTypeEnum(enm)
	}

	fn _evalStruct(self, mut s: &StructIns): &Data {
		mut d := &Data{
			Decl: true,
			Type: &Type{
				Kind: s,
			},
			Model: s,
		}
		if s.Decl != nil && s.Decl.Binded {
			d.Type.BindIdent = s.Decl.Ident
		}
		ret d
	}

	fn evalStruct(mut self, mut s: &Struct, mut errorToken: &token::Token): &Data {
		if !self.s.isAccessibleDefine(s.Public, s.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, s.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}

		self.checkDeprecated(s.Directives, errorToken)

		mut ins := s.instance()
		if len(s.Generics) == 0 {
			// For generics; it is safe. Because compiler should disallow using
			// genericed structures without instantiation. So, structures should be
			// instantiated. But, there is no generics, structure may have different
			// instances. So, append instance to structure if not exist, use
			// the existing instance if exist already.
			mut exist := s.appendInstance(ins)
			if exist != nil {
				ins = exist
			} else {
				// If this is a new instance; precheck structure instance to make ready.
				if !self.s.precheckStructIns(ins, errorToken) {
					ret nil
				}
			}
		}
		self.pushReference[&StructIns](ins)
		ret self._evalStruct(ins)
	}

	fn evalFnIns(self, mut f: &FnIns): &Data {
		ret &Data{
			Type: &Type{
				Kind: f,
			},
			Model: f,
		}
	}

	fn checkDeprecated(mut self, mut &directives: []&ast::Directive, tok: &token::Token) {
		if self.isUnsafe() {
			ret
		}

		d := findDirective(directives, build::Directive.Deprecated)
		if d != nil {
			if len(d.Args) == 0 {
				self.pushErr(tok, build::LogMsg.UsingDeprecated, "this code is deprecated")
			} else {
				self.pushErr(tok, build::LogMsg.UsingDeprecated, d.Args[0].Kind)
			}
			self.pushSuggestion(build::LogMsg.UseUnsafeForDeprecated)
		}
	}

	fn evalFn(mut self, mut f: &Fn, errorToken: &token::Token): &Data {
		if !self.s.isAccessibleDefine(f.Public, f.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, f.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}

		self.checkDeprecated(f.Directives, errorToken)

		mut ins := f.instance()
		if len(f.Generics) == 0 {
			// For generics; it is safe. Because compiler should disallow using
			// genericed functions without instantiation. So, functions should be
			// instantiated. But, there is no generics, function may have different
			// instances. So, append instance to function if not exist, use
			// the existing instance if exist already.
			mut exist := f.appendInstance(ins)
			if exist != nil {
				ins = exist
			}
		}
		self.pushReference[&FnIns](ins)
		ret self.evalFnIns(ins)
	}

	fn pushIllegalCycleError(mut self, &v1: &Var, &v2: &Var, mut &message: strings::Builder) {
		const Padding = 7
		refersTo := build::Logf(build::LogMsg.RefersTo, v1.Ident, v2.Ident)
		buf := unsafe { message.Buf() }
		message.WriteStr(strings::Repeat(" ", Padding))!
		message.WriteStr(refersTo)!
		message.WriteByte('\n')!
		message.Write(buf)!
	}

	fn checkCrossCycle(mut self, &v: &Var, mut &message: strings::Builder): bool {
		for _, d in v.Depends {
			if d == self.owner {
				self.pushIllegalCycleError(v, d, message)
				ret false
			}
			if !self.checkCrossCycle(d, message) {
				self.pushIllegalCycleError(v, d, message)
				ret false
			}
		}
		ret true
	}

	// Checks owner illegal cycles.
	// Appends depend to depends if there is no illegal cycle.
	// Returns true if e.owner is nil.
	fn checkIllegalCycles(mut self, mut &v: &Var, declToken: &token::Token): (ok: bool) {
		// Skip cycle checking if owner is nil or not global.
		if self.owner == nil || self.owner.Scope != nil {
			ret true
		}

		// Check illegal cycle for itself.
		// Because refers's owner is ta.
		if self.owner == v {
			self.pushErr(self.owner.Token, build::LogMsg.IllegalCycleRefersItself, self.owner.Ident)
			ret false
		}

		mut message := strings::Builder.New(1 << 5)

		if !self.checkCrossCycle(v, message) {
			mut errMsg := message.Str()
			message.Clear()
			self.pushIllegalCycleError(self.owner, v, message)
			errMsg += message.Str()
			self.pushErr(declToken, build::LogMsg.IllegalCrossCycle, errMsg)
			ret false
		}

		self.owner.Depends = append(self.owner.Depends, v)
		ret true
	}

	fn evalVar(mut self, mut v: &Var, errorToken: &token::Token): &Data {
		if !self.s.isAccessibleDefine(v.Public, v.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, v.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}

		self.checkDeprecated(v.Directives, errorToken)

		if v.Token == nil {
			// Variable is built-in.
			goto data
		}

		match type self.lookup {
		| &sema:
			// Check cycles for global scope.
			ok := self.checkIllegalCycles(v, errorToken)
			if !ok {
				ret nil
			}
		| &scopeChecker:
			mut s := (&scopeChecker)(self.lookup)
			mut root := s.getRoot()
			if v.Scope != nil && !v.Constant && root.captured != nil && isVarCaptured(root, s, v) {
				// Push variable if it is not constant and global.
				// Only capture scope variables.
				root.pushCaptured(v)
			}
			if !v.Reference || self.isUnsafe() {
				break
			}
			for s.owner == nil && s.parent != nil {
				s = s.parent
			}
			if s.owner != nil && s.owner.Anon && v.Scope != s.owner.Scope {
				self.pushErr(errorToken, build::LogMsg.UsedRefInAnonFnFromParentScope, v.Ident)
			}
		}

		// Push reference to global variable.
		if v.Scope == nil {
			self.pushReference[&Var](v)
		}

		// Value is nil, kind is not determined.
		// In other word, not analyzed yet.
		// But this variable is dependency, therefore check this for eval.
		// Do not check if v.Used is true. It means it already analyzed.
		// If variable is global, it should be have initialize expression.
		// So, nil value means something may be wrong.
		if !v.Used && !v.Binded && v.Scope == nil && (v.Value == nil || v.Value.Data == nil) {
			// Save source file of global variable.
			// Use it for evaluation and checking for correct analysis.
			// Otherwise, evaluation problems may occur.
			// Especially if variable uses use declaration namespaces in expression.
			mut varfile := findVarFileInPackage(self.s.files, v)
			mut file := self.s.getCurrentFile()
			self.s.setCurrentFile(varfile)

			// Variable is in global scope.
			// Use sema for lookup.
			self.s.checkVar(v, self.s)

			// Save the original file.
			self.s.setCurrentFile(file)
		}
		// variable guaranteed to be checked
		// any missing information means analysis failed
		// kind should not be nil because each variable must have a valid type
		v.Used = true
		if v.TypeSym == nil || v.TypeSym.Type == nil {
			ret nil
		}

	data:
		mut d := &Data{
			Lvalue: !v.Constant,
			Mutable: v.Mutable,
			Reference: v.Reference,
			Type: v.TypeSym.Type,
			Model: v,
		}
		if v.Value != nil && v.Value.Data != nil {
			if !v.Binded && v.IsInitialized() {
				d.IsRune = v.Value.Data.IsRune
			}
			if v.Constant && v.Value.Data.Constant != nil {
				d.Constant = new(constant::Const, *v.Value.Data.Constant)
				d.Model = d.Constant
				if v.untypedConstant() {
					self.applyNumericPrefix(d)
					d.untyped = true
				}
			}
		}

		ret d
	}

	fn evalTypeAlias(mut self, mut ta: &TypeAlias, errorToken: &token::Token): &Data {
		if !self.s.isAccessibleDefine(ta.Public, ta.Token) {
			self.pushErr(errorToken, build::LogMsg.IdentIsNotAccessible, ta.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
			ret nil
		}

		ta.Used = true

		mut kind := ta.TypeSym.Type.Kind
		let mut d: &Data = nil
		match type kind {
		| &StructIns:
			// Eval structure instance directly.
			// No risk for instantiation because type aliases always points to
			// valid instance even with generics.
			d = self._evalStruct((&StructIns)(kind))
		| &Enum:
			d = self._evalEnum((&Enum)(kind))
		| &TypeEnum:
			d = self._evalTypeEnum((&TypeEnum)(kind))
		|:
			d = &Data{
				Decl: true,
				Type: &Type{
					Kind: ta.TypeSym.Type.Kind,
				},
			}
			if ta.Binded {
				d.Type.BindIdent = ta.Ident
			} else {
				d.Type.BindIdent = ta.TypeSym.Type.BindIdent
			}
			d.Model = d.Type
		}
		d.Type.Generic = ta.Generic
		ret d
	}

	fn evalDef(mut self, mut &def: any, mut ident: &token::Token): &Data {
		match type def {
		| &Var:
			ret self.evalVar((&Var)(def), ident)
		| &Enum:
			ret self.evalEnum((&Enum)(def), ident)
		| &TypeEnum:
			ret self.evalTypeEnum((&TypeEnum)(def), ident)
		| &Struct:
			ret self.evalStruct((&Struct)(def), ident)
		| &Fn:
			mut f := (&Fn)(def)
			if f.Ident != jule::InitFn {
				ret self.evalFn(f, ident)
			}
		| &FnIns:
			ret self.evalFnIns((&FnIns)(def))
		| &TypeAlias:
			ret self.evalTypeAlias((&TypeAlias)(def), ident)
		}
		self.pushErr(ident, build::LogMsg.IdentNotExist, ident.Kind)
		ret nil
	}

	fn evalIdent(mut self, mut ident: &ast::IdentExpr): &Data {
		mut def := self.getDef(ident.Ident, ident.Binded)
		ret self.evalDef(def, ident.Token)
	}

	fn evalUnary(mut &self, mut u: &ast::UnaryExpr): &Data {
		mut unary := unaryEval.new(self)
		ret unary.eval(u)
	}

	fn evalVariadic(mut &self, mut v: &ast::VariadicExpr): &Data {
		if v.Expr == nil {
			self.pushErr(v.Token, build::LogMsg.InvalidExpr)
			ret nil
		}

		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		mut d := self.evalExpr(v.Expr)
		if d == nil {
			ret nil
		}
		if !d.Type.Variadicable() {
			self.pushErr(v.Token, build::LogMsg.VariadicWithNonVariadicable, d.Type.Str())
			ret nil
		}
		makeVariadic(d, d.Type.Slc().Elem)
		ret d
	}

	fn evalUnsafe(mut &self, mut u: &ast::UnsafeExpr): &Data {
		unsafety := self.unsafety
		self.unsafety = true
		mut d := self.evalExpr(u.Expr)
		self.unsafety = unsafety
		ret d
	}

	fn evalArr(mut &self, mut s: &ast::SliceExpr): &Data {
		// Arrays always has type prefixes.
		mut pt := self.prefix.Arr()

		mut arr := &Arr{
			Auto: false,
			N: 0,
			Elem: pt.Elem,
		}

		mut filled := false

		if len(s.Exprs) == 2 {
			match type s.Exprs[1].Kind {
			| &ast::VariadicExpr:
				if (&ast::VariadicExpr)(s.Exprs[1].Kind).Expr != nil {
					break
				}
				// Filled.

				if pt.Auto {
					self.pushErr(s.Token, build::LogMsg.AutoSizedArrFilled)
					ret nil
				}

				filled = true
				s.Exprs = s.Exprs[:1]
			}
		}

		arr.N = len(s.Exprs)
		if !pt.Auto {
			if arr.N > pt.N {
				self.pushErr(s.Token, build::LogMsg.OverflowLimits)
			} else if arr.N < pt.N {
				arr.N = pt.N
			}
		}

		mut model := &ArrayExpr{
			Kind: arr,
		}
		if filled {
			model.Elems = make([]Expr, 0, 2)
		} else {
			model.Elems = make([]Expr, 0, len(s.Exprs))
		}

		mut prefix := self.prefix
		self.prefix = arr.Elem
		for (_, mut elem) in s.Exprs {
			mut d := self.evalExpr(elem)
			if d == nil {
				continue
			}
			const destIsRef = false
			if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, arr.Elem, d, elem.Token) {
				_ = self.s.checkAssignType(destIsRef, arr.Elem, d, elem.Token, self.getOwnerRefers())
			}
			model.Elems = append(model.Elems, d.Model)
		}
		self.prefix = prefix

		if filled {
			// Fill mark.
			model.Elems = append(model.Elems, nil)
		}

		ret &Data{
			Mutable: true,
			Type: &Type{
				Kind: arr,
			},
			Model: model,
		}
	}

	fn evalExpSlc(mut &self, mut s: &ast::SliceExpr, mut t: &Type, mut first: Expr): &Data {
		mut slc := &Slc{
			Elem: t,
		}

		mut i := 0
		mut model := &SliceExpr{
			ElemType: t,
			Elems: make([]Expr, 0, len(s.Exprs)),
		}
		if first != nil {
			model.Elems = append(model.Elems, first)
			i = 1
		}

		mut prefix := self.prefix
		self.prefix = slc.Elem
		for (_, mut elem) in s.Exprs[i:] {
			mut d := self.evalExpr(elem)
			if d != nil {
				const destIsRef = false
				if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, slc.Elem, d, elem.Token) {
					_ = self.s.checkAssignType(destIsRef, slc.Elem, d, elem.Token, self.getOwnerRefers())
				}
				model.Elems = append(model.Elems, d.Model)
			}
		}
		self.prefix = prefix

		ret &Data{
			Mutable: true,
			Type: &Type{
				Kind: slc,
			},
			Model: model,
		}
	}

	fn evalSliceExpr(mut &self, mut s: &ast::SliceExpr): (d: &Data) {
		if self.prefix != nil {
			match {
			| self.prefix.Arr() != nil:
				d = self.evalArr(s)
			| self.prefix.Slc() != nil:
				mut pt := self.prefix.Slc()
				d = self.evalExpSlc(s, pt.Elem, nil)
			|:
				goto autoDetermine
			}
			if d != nil {
				mut strct := self.prefix.softStruct()
				if strct != nil && strct.Source != nil {
					d.Type = &Type{Kind: strct}
				}
			}
			ret
		}
	autoDetermine:
		mut prefix := self.prefix
		self.prefix = nil

		if len(s.Exprs) == 0 {
			self.pushErr(s.Token, build::LogMsg.DynamicTypeAnnotationFailed)
			ret nil
		}

		mut firstExpr := s.Exprs[0]
		mut firstElem := self.evalExpr(firstExpr)
		if firstElem == nil {
			ret nil
		}

		// Check mutability for first element.
		const destIsRef = false
		self.s.checkValidityForInitExpr(self.target.mutable, destIsRef,
			firstElem.Type, firstElem, firstExpr.Token)

		d = self.evalExpSlc(s, firstElem.Type, firstElem.Model)

		self.prefix = prefix
		ret d
	}

	fn checkIntegerIndexingByData(mut self, mut &d: &Data, mut token: &token::Token): bool {
		errKey := checkDataForIntegerIndexing(self.s, d, token, self.getOwnerRefers())
		match errKey {
		| build::LogMsg.Empty:
			ret true
		| build::LogMsg.InvalidTypeForIndexing:
			self.pushErr(token, errKey, d.Type.Str())
		|:
			self.pushErr(token, errKey)
		}
		ret false
	}

	fn indexingPtr(mut self, mut &d: &Data, mut &index: &Data, mut &i: &ast::IndexingExpr) {
		self.checkIntegerIndexingByData(index, i.Token)
		d.Lvalue = true

		mut ptr := d.Type.Ptr()
		match {
		| ptr.IsUnsafe():
			self.pushErr(i.Token, build::LogMsg.UnsafePtrIndexing)
			ret
		| !self.isUnsafe():
			self.pushErr(i.Token, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
		}

		d.Type = ptr.Elem
	}

	fn indexingArr(mut self, mut &d: &Data, mut &index: &Data, mut &i: &ast::IndexingExpr) {
		mut arr := d.Type.Arr()
		d.Type = arr.Elem
		self.checkIntegerIndexingByData(index, i.Token)
		d.Lvalue = true
		if index.IsConst() && index.Constant.AsF64() >= f64(arr.N) {
			self.pushErr(i.Token, build::LogMsg.OverflowLimits)
		}
	}

	fn indexingSlc(mut self, mut &d: &Data, mut &index: &Data, mut &i: &ast::IndexingExpr) {
		mut slc := d.Type.Slc()
		d.Type = slc.Elem
		self.checkIntegerIndexingByData(index, i.Token)
		d.Lvalue = true

		// Check compile-time bounds.
		if !index.IsConst() {
			ret
		}
		match type d.Model {
		| &SliceExpr:
			mut m := (&SliceExpr)(d.Model)
			indx := index.Constant.AsF64()
			if indx >= f64(len(m.Elems)) {
				self.pushErr(i.Token, build::LogMsg.OverflowLimits)
			} else {
				d.Model = m.Elems[u64(indx)]
				d.Decl = true // Set Model: flag.
			}
		}
	}

	fn indexingMap(mut self, mut &d: &Data, mut &index: &Data, mut &i: &ast::IndexingExpr) {
		d.Lvalue = true
		if index == nil {
			ret
		}
		mut m := d.Type.Map()
		mut atc := assignTypeChecker{
			s: self.s,
			dest: m.Key,
			d: index,
			errorToken: i.Token,
			refers: self.getOwnerRefers(),
		}
		_ = atc.check()
		d.Type = m.Val
	}

	fn indexingStr(mut self, mut &d: &Data, mut &index: &Data, mut &i: &ast::IndexingExpr) {
		d.Type = primU8 // Byte
		d.Mutable = false
		d.Lvalue = true

		if index == nil {
			ret
		}

		self.checkIntegerIndexingByData(index, i.Token)

		if !index.IsConst() {
			d.Constant = nil
			d.untyped = false
			ret
		}

		if d.IsConst() {
			j := index.Constant.AsI64()
			s := d.Constant.ReadStr()
			if int(j) >= len(s) {
				self.pushErr(i.Token, build::LogMsg.OverflowLimits)
			} else {
				d.Constant.SetU64(u64(s[j]))
			}
		}
	}

	fn comptimeRange(mut self, mut &d: &Data, mut &index: &Data, mut &i: &ast::IndexingExpr) {
		if index == nil {
			d = nil
			ret
		}
		if !self.checkIntegerIndexingByData(index, i.Index.Token) {
			d = nil
			ret
		}
		if !index.IsConst() {
			d = nil
			self.pushErr(i.Index.Token, build::LogMsg.ExprNotConst)
			ret
		}
		// guaranteed: index >= 0
		j := int(index.Constant.AsI64())
		mut ci := d.Type.comptimeRange()
		if j >= ci.kind.len() {
			d = nil
			self.pushErr(i.Index.Token, build::LogMsg.OverflowLimits)
			ret
		}
		ci.kind.index(d, j)
	}

	fn toIndexing(mut self, mut &d: &Data, mut &index: &Data, mut &i: &ast::IndexingExpr) {
		match {
		| d.Type.Ptr() != nil:
			self.indexingPtr(d, index, i)
			ret
		| d.Type.Arr() != nil:
			self.indexingArr(d, index, i)
			ret
		| d.Type.Slc() != nil:
			self.indexingSlc(d, index, i)
			ret
		| d.Type.Map() != nil:
			self.indexingMap(d, index, i)
			ret
		| d.Type.Prim() != nil:
			prim := d.Type.Prim()
			match {
			| prim.IsStr():
				self.indexingStr(d, index, i)
				ret
			}
		| d.Type.comptimeRange() != nil:
			self.comptimeRange(d, index, i)
			ret
		}
		self.pushErr(i.Token, build::LogMsg.NotSupportsIndexing, d.Type.Str())
	}

	fn pushGenericsFromExprSubIdent(mut &self, mut &sexpr: &ast::SubIdentExpr,
		mut &generics: []&ast::TypeDecl, mut &expr: &ast::Expr): bool {
		mut t := new(ast::SubIdentTypeDecl)
		if !pushSubIdentFromExpr(sexpr, t) {
			self.pushErr(expr.Token, build::LogMsg.InvalidSyntax)
			ret false
		}
		generics = append(generics, &ast::TypeDecl{Kind: t})
		ret true
	}

	fn pushGenericsFromData(mut &self, mut &generics: []&ast::TypeDecl, mut &expr: &ast::Expr): bool {
		match type expr.Kind {
		| &ast::UnaryExpr:
			mut u := (&ast::UnaryExpr)(expr.Kind)
			match u.Op.Id {
			| token::Id.Star:
				mut kind := new(ast::PtrTypeDecl)
				mut _generics := make([]&ast::TypeDecl, 0, 1)
				self.pushGenericsFromData(_generics, u.Expr)
				kind.Elem = _generics[0]
				generics = append(generics, &ast::TypeDecl{
					Token: expr.Token,
					Kind: kind,
				})
			| token::Id.Amper:
				mut kind := new(ast::SptrTypeDecl)
				mut _generics := make([]&ast::TypeDecl, 0, 1)
				self.pushGenericsFromData(_generics, u.Expr)
				kind.Elem = _generics[0]
				generics = append(generics, &ast::TypeDecl{
					Token: expr.Token,
					Kind: kind,
				})
			|:
				self.pushErr(u.Op, build::LogMsg.InvalidType)
				ret false
			}
		| &ast::TypeDecl:
			generics = append(generics, (&ast::TypeDecl)(expr.Kind))
		| &ast::SubIdentExpr:
			mut sexpr := (&ast::SubIdentExpr)(expr.Kind)
			ret self.pushGenericsFromExprSubIdent(sexpr, generics, expr)
		| &ast::IdentExpr:
			mut ident := (&ast::IdentExpr)(expr.Kind)
			generics = append(generics, &ast::TypeDecl{
				Kind: &ast::IdentTypeDecl{
					Binded: ident.Binded,
					Token: ident.Token,
					Ident: ident.Ident,
				},
			})
		| &ast::TupleExpr:
			for (_, mut texpr) in (&ast::TupleExpr)(expr.Kind).Expr {
				if !self.pushGenericsFromData(generics, texpr) {
					ret false
				}
			}
		| &ast::NamespaceExpr:
			mut ns := (&ast::NamespaceExpr)(expr.Kind)
			mut decl := &ast::IdentTypeDecl{
				Token: ns.Ident,
				Ident: ns.Ident.Kind,
			}
			generics = append(generics, &ast::TypeDecl{
				Token: decl.Token,
				Kind: &ast::NamespaceTypeDecl{
					Namespace: ns.Namespace,
					Kind: &ast::TypeDecl{
						Token: decl.Token,
						Kind: decl,
					},
				},
			})
		|:
			self.pushErr(expr.Token, build::LogMsg.InvalidSyntax)
			ret false
		}
		ret true
	}

	fn evalIdentDeclFromIndexing(mut &self, mut &d: &Data, mut &i: &ast::IndexingExpr) {
		mut s := d.Type.Struct()
		if s == nil {
			self.pushErr(i.Expr.Token, build::LogMsg.TypeNotSupportsGenerics, d.Type.Str())
			d = nil
			ret
		}

		let mut decl: &ast::IdentTypeDecl = nil
		match type i.Expr.Kind {
		| &ast::IdentExpr:
			mut expr := (&ast::IdentExpr)(i.Expr.Kind)
			decl = &ast::IdentTypeDecl{
				Binded: expr.Binded,
				Token: expr.Token,
				Ident: expr.Ident,
			}
		| &ast::NamespaceExpr:
			mut expr := (&ast::NamespaceExpr)(i.Expr.Kind)
			decl = &ast::IdentTypeDecl{
				Token: expr.Ident,
				Ident: expr.Ident.Kind,
			}
		|:
			self.pushErr(i.Token, build::LogMsg.InvalidSyntax)
			d = nil
			ret
		}
		if !self.pushGenericsFromData(decl.Generics, i.Index) {
			d = nil
			ret
		}

		s = self.typeChecker().fromStruct(decl, s.Decl)
		if s == nil {
			d = nil
			ret
		}
		d.Type.Kind = s
	}

	// Checks new generics function instance.
	// If instance is already exist, f will point to exist instantantiation.
	fn checkGenericFn(mut &self, mut &f: &FnIns, mut &et: &token::Token, mut &model: Expr): (ok: bool, exist: bool) {
		mut old := f
		ok, exist = self.s.checkGenericFn(f, et)
		if ok && exist {
			// Update model by exist function instance.
			// Generic functions returns always new instance, because might be
			// generics are inferred. Therefore, always returns new instance for requests.
			// So, if this absolute instance is already exist, update model.
			// Otherwise, model's instance will be a dangling, because it never
			// be appended into instances of function declaration since already exist.
			updateModelToGenericIns(model, f)
			updateRefer(self.getOwnerRefers(), old, f)
		}
		ret
	}

	fn evalFnGenericFromIndexing(mut &self, mut &d: &Data, mut &i: &ast::IndexingExpr) {
		mut generics := make([]&ast::TypeDecl, 0, 1<<3)
		if !self.pushGenericsFromData(generics, i.Index) {
			d = nil
			ret
		}

		mut f := d.Type.Fn()
		mut genericsLen := 0
		if f.Decl != nil {
			genericsLen = len(f.Decl.Generics)
		}
		if !self.s.checkGenericQuantity(genericsLen, len(generics), i.Expr.Token) {
			d = nil
			ret
		}

		// Build real kinds of generic types.
		f.Generics = make([]&InsGeneric, 0, len(f.Decl.Generics))
		for (_, mut g) in generics {
			mut k := self.evalType(g)
			if k == nil {
				d = nil
				ret
			}
			f.Generics = append(f.Generics, &InsGeneric{Type: k.Type})
		}

		if f.IsBuiltin() {
			ret
		}

		ok, _ := self.checkGenericFn(f, i.Expr.Token, d.Model)
		if ok {
			d.Type.Kind = f
		} else {
			d = nil
		}
	}

	fn evalIndexing(mut &self, mut i: &ast::IndexingExpr): &Data {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		mut d := self.evalExprKind(i.Expr.Kind)
		if d == nil {
			ret nil
		}

		// Catch types.
		if d.Decl {
			self.evalIdentDeclFromIndexing(d, i)
			ret d
		}

		if d.Type.Fn() != nil {
			self.evalFnGenericFromIndexing(d, i)
			ret d
		}

		mut oldData := *d

		mut index := self.evalExpr(i.Index)
		if index == nil {
			ret nil
		}

		// caught comptime indexing expressions
		makeComptimeRange(d)

		// Set decl to true. It's a kind of flag.
		// If decl is true after indexing eval, do not touch Model:.
		// Setted by indexing eval.
		d.Decl = false

		self.toIndexing(d, index, i)
		if d == nil {
			ret nil
		}
		if d.IsConst() {
			d.Decl = false
			d.Model = d.Constant
		} else if d.Decl {
			d.Decl = false
		} else {
			d.Model = &IndexingExpr{
				Token: i.Token,
				Expr: new(Data, oldData),
				Index: index,
			}
		}

		ret d
	}

	// Returns left and right index values.
	// Returns zero integer expression if slicing have not left index.
	// So, left index always represents an expression.
	// Left data is nil if expression eval failed.
	fn evalSlicingExprs(mut &self, mut &s: &ast::SlicingExpr): (&Data, &Data) {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		let mut l: &Data = nil
		let mut r: &Data = nil

		if s.Start != nil {
			l = self.evalExpr(s.Start)
			if l != nil {
				self.checkIntegerIndexingByData(l, s.Token)
			} else {
				ret nil, nil
			}
		} else {
			l = &Data{
				Constant: constant::Const.NewI64(0),
				Type: primInt,
			}
			l.Constant.Kind = types::Kind.Int
			l.Model = l.Constant
		}

		if s.To != nil {
			r = self.evalExpr(s.To)
			if r != nil {
				self.checkIntegerIndexingByData(r, s.Token)
			} else {
				ret nil, nil
			}
		}

		ret l, r
	}

	fn slicingArr(self, mut &d: &Data) {
		mut elemType := d.Type.Arr().Elem
		d.Type = &Type{
			Kind: &Slc{
				Elem: elemType,
			},
		}

		d.Lvalue = false

		// Keep mutability id already mutable.
		// Be mutable, if element is not mutable-type.
		d.Mutable = d.Mutable || !elemType.Mutable()
	}

	fn slicingStr(self, mut &d: &Data, &l: &Data, &r: &Data) {
		d.Lvalue = false
		d.Mutable = true
		if !d.IsConst() {
			ret
		}

		if l == nil || r == nil {
			d.Constant = nil
			d.untyped = false
			ret
		}

		if l.IsConst() && r.IsConst() {
			left := l.Constant.AsI64()
			if left < 0 {
				ret
			}

			s := d.Constant.ReadStr()
			mut right := i64(0)
			if r == nil {
				right = i64(len(s))
			} else {
				right = r.Constant.AsI64()
			}

			if left > right {
				ret
			}
			d.Constant.SetStr(s[left:right])
			d.Decl = true // Set Model: flag.
		} else {
			d.Constant = nil
			d.untyped = false
		}
	}

	fn checkSlicing(mut self, mut &d: &Data, &l: &Data, &r: &Data, &s: &ast::SlicingExpr) {
		match {
		| d.Type.Arr() != nil:
			self.slicingArr(d)
			ret
		| d.Type.Slc() != nil:
			ret
		| d.Type.Prim() != nil:
			prim := d.Type.Prim()
			match {
			| prim.IsStr():
				self.slicingStr(d, l, r)
				ret
			}
		}

		self.pushErr(s.Token, build::LogMsg.NotSupportsSlicing, d.Type.Str())
	}

	fn evalSlicing(mut &self, mut s: &ast::SlicingExpr): &Data {
		mut d := self.evalExpr(s.Expr)
		if d == nil {
			ret nil
		}

		mut l, mut r := self.evalSlicingExprs(s)
		if l == nil {
			ret d
		}

		// Set decl to true. It's a kind of flag.
		// If decl is true after indexing eval, do not touch Model:.
		// Setted by indexing eval.
		d.Decl = false

		self.checkSlicing(d, l, r, s)

		if d.IsConst() {
			d.Decl = false
			d.Model = d.Constant
		} else if d.Decl {
			d.Decl = false
		} else {
			mut model := &SlicingExpr{
				Token: s.Token,
				Expr: d.Model,
				Left: l.Model,
			}
			if r != nil {
				model.Right = r.Model
			}
			d.Model = model
		}
		ret d
	}

	fn castPtr(mut self, mut t: &Type, mut d: &Data, errorToken: &token::Token) {
		d.Constant = nil
		d.untyped = false
		sptr := d.Type.Sptr()
		if sptr != nil {
			if !t.Ptr().Elem.Equal(sptr.Elem) {
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
			}
			ret
		}

		if !self.isUnsafe() {
			self.pushErr(errorToken, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
			ret
		}

		prim := d.Type.Prim()
		if d.Type.Ptr() == nil && (prim == nil || !types::IsInt(prim.Str())) {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
		}
	}

	fn castStruct(mut self, mut t: &Type, mut d: &Data, errorToken: &token::Token) {
		d.Constant = nil
		d.untyped = false
		mut tr := d.Type.Trait()
		if tr == nil {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
			ret
		}

		mut s := t.Struct()
		self.pushReference[&StructIns](s)

		if !s.Decl.IsImplements(tr) {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
		}
	}

	fn castRef(mut self, mut t: &Type, mut d: &Data, errorToken: &token::Token) {
		d.Constant = nil
		d.untyped = false
		mut sptr := t.Sptr()

		mut ptr := d.Type.Ptr()
		if ptr != nil && sptr.Elem.Equal(ptr.Elem) {
			if !self.isUnsafe() {
				self.pushErr(errorToken, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
			}
			// Ok.
			ret
		}

		// For traits.
		if sptr.Elem.Struct() != nil {
			self.castStruct(sptr.Elem, d, errorToken)
			ret
		}

		self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
	}

	fn castSlc(mut self, mut t: &Type, mut d: &Data, errorToken: &token::Token) {
		c := d.Constant
		d.Constant = nil
		d.untyped = false

		if d.Type.Enum() != nil {
			if d.Type.Enum().TypeSym.Type.Prim() == nil || !d.Type.Enum().TypeSym.Type.Prim().IsStr() {
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
				ret
			}
		} else if d.Type.Prim() == nil || !d.Type.Prim().IsStr() {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
			ret
		}

		t = t.Slc().Elem
		prim := t.Prim()
		if prim == nil || (!prim.IsU8() && !prim.IsI32()) {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
			ret
		}

		// Cast constant expressions.
		if c != nil {
			match {
			| prim.IsU8():
				s := c.ReadStr()
				mut model := &SliceExpr{
					ElemType: t,
					Elems: make([]Expr, 0, len(s)),
				}
				for _, b in s {
					mut bc := constant::Const.NewU64(u64(b))
					bc.Kind = prim.Kind
					model.Elems = append(model.Elems, bc)
				}
				d.Model = model
				d.Decl = true // Prevent model changing.
			| prim.IsI32():
				runes := []rune(c.ReadStr())
				mut model := &SliceExpr{
					ElemType: t,
					Elems: make([]Expr, 0, len(runes)),
				}
				for _, r in runes {
					mut rc := constant::Const.NewI64(i64(r))
					rc.Kind = prim.Kind
					model.Elems = append(model.Elems, rc)
				}
				d.Model = model
				d.Decl = true // Prevent model changing.
			}
		}
	}

	fn castBool(mut self, mut d: &Data, errorToken: &token::Token) {
		if !d.Type.Equal(primBool) {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, str(types::Kind.Bool), d.Type.Str())
		}
	}

	fn castStr(mut self, mut d: &Data, errorToken: &token::Token) {
		if d.Type.Enum() != nil {
			mut e := d.Type.Enum()
			if e.TypeSym.Type.Prim() != nil && e.TypeSym.Type.Prim().IsStr() {
				ret
			}
		}

		c := d.Constant
		d.Constant = nil
		d.untyped = false
		mut prim := d.Type.Prim()
		if prim != nil {
			if prim.IsStr() {
				ret
			}
			if !prim.IsU8() && !prim.IsI32() {
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, str(types::Kind.Str), d.Type.Str())
				ret
			}
			// Cast constant expressions.
			if c != nil {
				match {
				| prim.IsU8():
					d.Constant = constant::Const.NewStr(str(byte(c.AsU64())))
					d.Model = d.Constant
					d.Decl = true // Prevent model changing.
				| prim.IsI32():
					d.Constant = constant::Const.NewStr(str(rune(c.AsI64())))
					d.Model = d.Constant
					d.Decl = true // Prevent model changing.
				}
			}
			ret
		}

		mut s := d.Type.Slc()
		if s == nil {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, str(types::Kind.Str), d.Type.Str())
			ret
		}

		mut t := s.Elem
		prim = t.Prim()
		if prim == nil || (!prim.IsU8() && !prim.IsI32()) {
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, str(types::Kind.Str), d.Type.Str())
			ret
		}
	}

	fn castInt(mut self, mut t: &Type, mut d: &Data, errorToken: &token::Token) {
		if d.IsConst() {
			prim := t.Prim()
			match {
			| types::IsSigInt(prim.Kind):
				d.Constant.SetI64(d.Constant.AsI64())
			| types::IsUnsigInt(prim.Kind):
				d.Constant.SetU64(d.Constant.AsU64())
			}
		} else {
			d.Constant = nil
			d.untyped = false
		}

		if d.Type.Enum() != nil {
			mut e := d.Type.Enum()
			if types::IsNum(e.TypeSym.Type.Prim().Str()) {
				ret
			}
		}

		if d.Type.Sptr() != nil {
			prim := t.Prim()
			if !prim.IsUintptr() {
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
			}
			ret
		}
		if d.Type.Ptr() != nil {
			prim := t.Prim()
			if prim.IsUintptr() {
				// Ignore case.
			} else if !self.isUnsafe() {
				self.pushErr(errorToken, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
			}
			ret
		}

		prim := d.Type.Prim()
		if prim != nil && types::IsNum(prim.Str()) {
			ret
		}

		self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
	}

	fn castNum(mut self, mut t: &Type, mut d: &Data, errorToken: &token::Token) {
		if d.IsConst() {
			prim := t.Prim()
			match {
			| types::IsFloat(prim.Kind):
				d.Constant.SetF64(d.Constant.AsF64())
			| types::IsSigInt(prim.Kind):
				d.Constant.SetI64(d.Constant.AsI64())
			| types::IsUnsigInt(prim.Kind):
				d.Constant.SetU64(d.Constant.AsU64())
			}
		} else {
			d.Constant = nil
			d.untyped = false
		}

		if d.Type.Enum() != nil {
			mut e := d.Type.Enum()
			if types::IsNum(e.TypeSym.Type.Prim().Str()) {
				ret
			}
		}

		prim := d.Type.Prim()
		if prim != nil && types::IsNum(prim.Str()) {
			ret
		}

		self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
	}

	fn castPrim(mut self, mut t: &Type, mut d: &Data, errorToken: &token::Token) {
		prim := t.Prim()
		match {
		| prim.IsAny():
			panic("sema: castPrim: any case should be unreachable in this routine")
		| prim.IsStr():
			self.castStr(d, errorToken)
		| prim.IsBool():
			self.castBool(d, errorToken)
		| types::IsInt(prim.Str()):
			self.castInt(t, d, errorToken)
		| types::IsNum(prim.Str()):
			self.castNum(t, d, errorToken)
		|:
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCasting, t.Str())
		}
	}

	fn castConstant(mut self, mut &t: &Type, mut &d: &Data) {
		if d == nil || !d.IsConst() {
			ret
		}
		prim := t.Prim()
		castConstByType(prim.Kind, d)
		d.Model = d.Constant
	}

	fn castTypeEnum(mut self, mut &t: &Type, mut &d: &Data, mut &errorToken: &token::Token) {
		n := len(self.s.errors)
		if !self.s.checkTypeCompatibility(d.Type, t, errorToken) {
			self.s.errors = self.s.errors[:n]
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
		}
		d.Constant = nil
		d.untyped = false
	}

	fn castTypeEnumT(mut self, mut &t: &Type, mut &d: &Data, mut &errorToken: &token::Token) {
		n := len(self.s.errors)
		if !self.s.checkTypeCompatibility(t, d.Type, errorToken) {
			self.s.errors = self.s.errors[:n]
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, d.Type.Str(), t.Str())
		}
		d.Constant = nil
		d.untyped = false
	}

	fn evalCastByTypeNData(mut self, mut t: &Type, mut d: &Data, mut errorToken: &token::Token): &Data {
		if d != nil && d.Decl {
			self.pushErr(errorToken, build::LogMsg.InvalidExpr)
			ret nil
		}

		match {
		| d.IsNil():
			if !t.NilCompatible() {
				self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCastingTo, "<nil>", t.Str())
			}
			d.Constant = nil // Remove nil constant.
			d.untyped = false
		| d.Type.Prim() != nil && d.Type.Prim().IsAny():
			if t.TypeEnum() != nil {
				self.pushErr(errorToken, build::LogMsg.TypeEnumCastedFromAny)
			}
			d.Constant = nil
			d.untyped = false
		| t.Prim() != nil && t.Prim().IsAny():
			// The any type supports casting to any data type.
			d.Constant = nil
			d.untyped = false
		| d.Type.TypeEnum() != nil:
			self.castTypeEnum(t, d, errorToken)
		| t.TypeEnum() != nil:
			self.castTypeEnumT(t, d, errorToken)
		| t.Ptr() != nil:
			self.castPtr(t, d, errorToken)
		| t.Sptr() != nil:
			self.castRef(t, d, errorToken)
		| t.Slc() != nil:
			self.castSlc(t, d, errorToken)
		| t.Struct() != nil:
			self.castStruct(t, d, errorToken)
		| t.Prim() != nil:
			self.castPrim(t, d, errorToken)
			self.castConstant(t, d)
		|:
			self.pushErr(errorToken, build::LogMsg.TypeNotSupportsCasting, t.Str())
			d = nil
		}

		if d == nil {
			ret nil
		}
		// casting applied successfully

		if t.Binded() || d.Type.Binded() {
			// if destination or expression type is binded, it requires Unsafe Jule for this.
			// Push error if Unsafe Jule is not available. But do not return nil data,
			// casting is valid, just Unsafe Jule is missing. Push only information error for that.
			if !self.isUnsafe() {
				self.pushErr(errorToken, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
				self.pushSuggestion(build::LogMsg.CastingBindedTypesRequiresUnsafeJule)
			}
		}

		// Keep mutability if data is already mutable.
		// Even if the data is not mutable, set as mutable if the type is not mutable-type.
		d.Mutable = d.Mutable || !d.Type.Mutable()

		if !d.Decl && (d.Type.Enum() == nil || !d.Type.Enum().TypeSym.Type.Equal(t)) {
			applyCastKind(self.s, d, t, errorToken, self.getOwnerRefers())
			(&CastingExpr)(d.Model).Token = errorToken
		} else {
			d.Type = t
		}

		// Remove flag.
		// The variable d cannot be d.Decl true because of checked already.
		// Therefore this field used as flag to say "do not touch to expression model".
		// So, if d.Decl is true, model will not be changed.
		d.Decl = false

		d.Lvalue = false
		d.untyped = false

		if d.IsConst() {
			d.Constant.Kind = t.Prim().Kind
		}

		ret d
	}

	fn evalCastT(mut &self, mut &t: &Type, mut &e: &ast::Expr, mut &et: &token::Token): &Data {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }
		if t.Slc() != nil {
			match type e.Kind {
			| &ast::SliceExpr:
				self.prefix = t
			}
		}
		mut d := self.evalExpr(e)
		if d == nil || self.prefix != nil {
			ret d
		}
		ret self.evalCastByTypeNData(t, d, et)
	}

	fn evalCast(mut &self, mut c: &ast::CastExpr): &Data {
		mut t := buildType(c.Kind)
		ok := self.s.checkTypeSym(t, self.lookup)
		if !ok {
			ret nil
		}
		ret self.evalCastT(t.Type, c.Expr, c.Kind.Token)
	}

	fn evalNamespace(mut self, mut s: &ast::NamespaceExpr): &Data {
		mut imp := findNamespace(self.lookup, s.Namespace.Kind)
		if imp == nil {
			self.pushErr(s.Namespace, build::LogMsg.NamespaceNotExist, s.Namespace.Kind)
			ret nil
		}

		mut lookup := self.lookup
		self.lookup = imp

		const Binded = false
		self.disallowBuiltin()
		mut def := self.getDef(s.Ident.Kind, Binded)
		self.allowBuiltin()
		self.lookup = lookup
		mut d := self.evalDef(def, s.Ident)
		ret d
	}

	fn evalStructLitExplicit(mut &self, mut s: &StructIns,
		mut exprs: []&ast::Expr, mut errorToken: &token::Token): &Data {
		ok := self.s.checkGenericQuantity(len(s.Decl.Generics), len(s.Generics), errorToken)
		if !ok {
			ret nil
		}
		// NOTICE: Instance already checked (just fields) if generic quantity passes.

		if self.field != nil && self.field.Decl.Owner == s.Decl {
			self.pushErr(errorToken, build::LogMsg.IllegalCycleRefersItself, s.Decl.Ident)
		}

		self.pushReference[&StructIns](s)
		self.checkDeprecated(s.Decl.Directives, errorToken)

		mut slc := structLitChecker{
			e: self,
			errorToken: errorToken,
			s: s,
		}
		slc.check(exprs)

		mut d := &Data{
			Mutable: self.target.mutable,
			Type: &Type{
				Kind: s,
			},
			Model: &StructLitExpr{
				Strct: s,
				Args: slc.args,
			},
		}
		if s.Decl.Binded {
			d.Type.BindIdent = s.Decl.Ident
		}
		ret d
	}

	fn evalStructLit(mut &self, mut lit: &ast::StructLit): &Data {
		mut t := buildType(lit.Kind)
		ok := self.s.checkTypeSym(t, self.lookup)
		if !ok {
			ret nil
		}

		mut s := t.Type.Struct()
		if s == nil {
			if t.Type.Sptr() != nil {
				s = t.Type.Sptr().Elem.Struct()
				if s != nil {
					goto eval
				}
			}
			self.pushErr(lit.Kind.Token, build::LogMsg.InvalidSyntax)
			ret nil
		}

	eval:
		mut d := self.evalStructLitExplicit(s, lit.Exprs, lit.Kind.Token)
		match type t.Type.Kind {
		| &Sptr:
			mut model := (&StructLitExpr)(d.Model)
			makeStructLitAlloc(d, model)
		}

		if d != nil {
			mut strct := t.Type.softStruct()
			if strct != nil && strct.Source != nil {
				(&StructLitExpr)(d.Model).Strct = strct
				d.Type = &Type{Kind: strct}
			}
		}

		ret d
	}

	fn typeChecker(mut self): typeChecker {
		ret self.s.typeChecker(self.lookup, nil, nil)
	}

	fn evalType(mut self, mut t: &ast::TypeDecl): &Data {
		mut tk := buildType(t)
		ok := self.s.checkTypeSym(tk, self.lookup)
		if !ok {
			ret nil
		}
		ret &Data{
			Decl: true,
			Type: tk.Type,
			Model: tk.Type,
		}
	}

	fn callTypeFn(mut &self, mut &fc: &ast::FnCallExpr, mut &d: &Data) {
		if len(fc.Args) < 1 {
			self.pushErr(fc.Token, build::LogMsg.MissingExprFor, "v")
		} else if len(fc.Args) > 1 {
			self.pushErr(fc.Args[1].Token, build::LogMsg.ArgumentOverflow, d.Type.Str())
		} else if fc.IsCo {
			self.pushErr(fc.Token, build::LogMsg.CoForCastingCall)
			d = nil
			ret
		} else if fc.Exception != nil {
			self.pushErr(fc.Token, build::LogMsg.TypeCallWithExceptional)
			d = nil
			ret
		}

		if len(fc.Args) > 0 {
			mut arg := fc.Args[0]
			d = self.evalCastT(d.Type, arg, arg.Token)
			ret
		}

		if d != nil {
			d.Decl = false
		}
	}

	fn callBuiltinFn(mut &self, mut &fc: &ast::FnCallExpr, mut &d: &Data) {
		if !fc.Unhandled() { // Exceptional handled?
			// Built-in functions are not exceptional.
			self.pushErr(fc.Token, build::LogMsg.HandledUnexceptional)
		}
		d = d.Type.Fn().caller(self, fc, d)
		if d == nil {
			ret
		}
		d.Mutable = true
	}

	fn checkFnOfConcurrentCall(mut self, &f: &FnIns, errorToken: &token::Token) {
		if self.isUnsafe() {
			ret
		}
		for _, p in f.Params {
			if p.Decl.IsSelf() {
				if !p.Decl.IsRef() {
					self.pushErr(errorToken, build::LogMsg.ConcurrentCallWithSelfParam)
					self.pushSuggestion(build::LogMsg.UseUnsafeJuleToCallCoSelf)
				}
			}
			if p.Decl.Reference {
				self.pushErr(errorToken, build::LogMsg.ConcurrentCallWithRefParam)
				self.pushSuggestion(build::LogMsg.UseUnsafeJuleToCallCo)
				ret
			}
		}
	}

	fn processExceptionalHandler(mut self, mut &f: &FnIns, mut &fc: &ast::FnCallExpr, mut &d: &Data) {
		resultNeeded := !self.target.ignored && !f.Decl.IsVoid()
		let mut csc: &scopeChecker = nil
		let mut ch: &Scope = nil

		mut model := (&FnCallExpr)(d.Model)

		// self.lookup is always scopeChecker because exceptionals are
		// not allowed in global scope.
		mut sc := (&scopeChecker)(self.lookup)
		csc = sc.newChildChecker()
		if resultNeeded {
			csc.result = &result{func: f, mutable: self.target.mutable}
		}
		ch = sc.getChild()
		fc.Exception.Parent = sc.tree
		csc.table.Vars = append(csc.table.Vars, buildErrorVar(ch, fc))
		sc.checkChildSsc(fc.Exception, ch, csc)

		model.Assigned = resultNeeded
		model.Except = ch

		if resultNeeded && csc.result != nil {
			self.pushErr(fc.Token, build::LogMsg.MissingAssignRet)
		}
	}

	fn callFn(mut &self, mut &fc: &ast::FnCallExpr, mut &d: &Data) {
		mut f := d.Type.Fn()
		if f.IsBuiltin() {
			self.callBuiltinFn(fc, d)
			ret
		}

		if !f.Decl.IsMethod() && hasDirective(f.Decl.Directives, build::Directive.Test) {
			self.pushErr(fc.Token, build::LogMsg.TestCalled)
			d = nil
			ret
		}

		if !d.Mutable && f.Decl.IsMethod() && !f.Decl.Statically && f.Decl.Params[0].Mutable {
			if self.target.mutable {
				self.pushErr(fc.Token, build::LogMsg.MutOperationOnImmut)
			} else {
				// Caught mutability risk of immutable literals.
				// Literal will not be assigned to immutable memory,
				// used to call method with mutable receiver.
				// Assume literal as mutable and check accordingly.
				lit := isLitBased(d.Model)
				if lit == nil {
					// Expression is not literal based, so data is strictly immutable.
					self.pushErr(fc.Token, build::LogMsg.MutOperationOnImmut)
				} else {
					checkMutRiskOfStructLit(self.s, lit)
				}
			}
		} else if !self.isUnsafe() && f.Decl.Unsafety {
			self.pushErr(fc.Token, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
		}

		mut dynamicAnnotation := len(f.Decl.Generics) > 0 && len(f.Generics) == 0 && len(f.Params) > 0
		if dynamicAnnotation {
			f.Generics = make([]&InsGeneric, len(f.Decl.Generics))
		} else if len(f.Generics) != len(f.Decl.Generics) {
			_ = self.s.checkGenericQuantity(len(f.Decl.Generics), len(f.Generics), fc.Token)
			d = nil
			ret
		}

		mut old := self.s
		if f.Decl.Owner != nil {
			self.s = f.Decl.Owner.sema
		}

		defer {
			if old != self.s {
				old.errors = append(old.errors, self.s.errors...)
				self.s.errors = nil
			}
			self.s = old
		}

		mut fcac := fnCallArgChecker{
			e: self,
			args: fc.Args,
			dynamicAnnotation: dynamicAnnotation,
			errorToken: fc.Token,
		}

		if !dynamicAnnotation {
			if !f.reloaded {
				ok := self.s.reloadFnInsTypes(f)
				f.reloaded = true
				if !ok {
					d = nil
					ret
				}
			}
			mut existInstance := f.Decl.appendInstance(f)
			if existInstance != nil {
				f = existInstance
			}
		} else if !self.s.buildFnNonGenericTypes(f, fcac.ignored) {
			d = nil
			ret
		}

		fcac.f = f

		mut ok := false
		if f.Decl.Owner != nil {
			old, self.s = self.s, old // Save current Sema.
			ok = fcac.check()
			old, self.s = self.s, old // Save owner Sema.
		} else {
			ok = fcac.check()
		}

		if dynamicAnnotation {
			if !ok {
				d = nil
				ret
			}
			ok, _ = self.checkGenericFn(f, fc.Token, d.Model)
			if !ok {
				d = nil
				ret
			}
		}

		mut callModel := d.Model

		if f.Decl.IsVoid() {
			d = buildVoidData()
		} else {
			d.Type = f.Result
			d.Lvalue = false
		}

		mut model := &FnCallExpr{
			Token: fc.Token,
			Func: f,
			Expr: callModel,
			Args: fcac.argModels,
			IsCo: fc.IsCo,
		}
		d.Model = model
		d.Mutable = true

		if f.Decl.Exceptional {
			if fc.IsCo {
				self.s.pushErr(fc.Token, build::LogMsg.CoForExceptional)
				self.s.pushSuggestion(build::LogMsg.HandleInFn)
			}
			match {
			| fc.Unhandled():
				self.pushErr(fc.Token, build::LogMsg.UnhandledExceptional)
				self.pushSuggestion(build::LogMsg.HandleExceptional)
			| fc.Ignored():
				// Ok.
				break
			|:
				// Handled with scope.
				self.processExceptionalHandler(f, fc, d)
			}
		} else if !fc.Unhandled() {
			self.pushErr(fc.Token, build::LogMsg.HandledUnexceptional)
		}

		if fc.IsCo {
			model.Func.AsAnon = true
			model.Func.CalledCo = true
			self.checkFnOfConcurrentCall(model.Func, fc.Token)
		}
	}

	fn evalFnCall(mut &self, mut fc: &ast::FnCallExpr): &Data {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }

		match type fc.Expr.Kind {
		| &ast::IdentExpr:
			// Use fc.expr.Token.Kind instead of casting.
			// Same thing, but more efficient and performant.
			if fc.Expr.Token.Kind == token::Kind.Error {
				ret builtinCallerError(self, fc)
			}
		}

		mut d := self.evalExprKind(fc.Expr.Kind)
		if d == nil {
			ret nil
		}

		if d.Decl {
			self.callTypeFn(fc, d)
			ret d
		}

		if d.Type.Fn() == nil {
			self.pushErr(fc.Token, build::LogMsg.CallingNonFn)
			ret nil
		}

		self.callFn(fc, d)
		ret d
	}

	fn evalEnumStatic(mut self, mut enm: &Enum, mut ident: &token::Token): &Data {
		mut item := enm.FindItem(ident.Kind)
		if item == nil {
			self.pushErr(ident, build::LogMsg.ObjHaveNotIdent, enm.Ident, ident.Kind)
		}
		ret evalEnumStatic(self.s, enm, item, ident, self.getOwnerRefers())
	}

	fn evalTypeEnumStatic(mut self, mut enm: &TypeEnum, ident: &token::Token): &Data {
		mut item := enm.FindItem(ident.Kind)
		if item == nil {
			self.pushErr(ident, build::LogMsg.ObjHaveNotIdent, enm.Ident, ident.Kind)
			ret nil
		}
		match {
		| item.TypeSym.Type.Enum() != nil:
			ret self._evalEnum(item.TypeSym.Type.Enum())
		| item.TypeSym.Type.TypeEnum() != nil:
			ret self._evalTypeEnum(item.TypeSym.Type.TypeEnum())
		| item.TypeSym.Type.Struct() != nil:
			ret self._evalStruct(item.TypeSym.Type.Struct())
		|:
			mut d := &Data{
				Decl: true,
				Type: item.TypeSym.Type,
			}
			d.Model = d.Type
			ret d
		}
	}

	fn evalStructStatic(mut self, mut s: &StructIns, ident: &token::Token): &Data {
		mut d := new(Data)

		// Method.
		const Static = true
		mut method := s.FindMethod(ident.Kind, Static)
		if method != nil {
			if !self.s.isAccessibleDefine(method.Public, method.Token) {
				self.pushErr(ident, build::LogMsg.IdentIsNotAccessible, ident.Kind)
				self.pushSuggestion(build::LogMsg.MakePubToAccess)
			}

			mut ins := method.instance()
			ins.Owner = s
			self.pushReference[&FnIns](ins)
			d.Model = &StructStaticIdentExpr{
				Structure: s,
				Expr: d.Model,
				Method: ins,
			}
			d.Type = &Type{
				Kind: ins,
			}
			ret d
		}

		mut sttc := s.FindStatic(ident.Kind)
		if sttc != nil {
			ret self.evalVar(sttc, ident)
		}

		self.pushErr(ident, build::LogMsg.ObjHaveNotIdent, s.Decl.Ident, ident.Kind)
		ret nil
	}

	fn evalTraitSubIdent(mut self, mut d: &Data, mut trt: &Trait, mut ident: &token::Token): &Data {
		mut f := trt.FindMethod(ident.Kind)
		if f == nil {
			self.pushErr(ident, build::LogMsg.ObjHaveNotIdent, trt.Ident, ident.Kind)
			ret nil
		}
		ret &Data{
			Mutable: d.Mutable,
			Type: &Type{
				Kind: f.instance(),
			},
			Model: &TraitSubIdentExpr{
				Token: ident,
				Expr: d.Model,
				Method: f,
				Trt: trt,
			},
		}
	}

	// This method evaluates expressions, will not check public availability.
	// The tok parameter should be identifier to accessed.
	fn evalStructSubIdentField(mut self, mut &d: &Data, mut &s: &StructIns, mut &tok: &token::Token, mut &f: &FieldIns): &Data {
		mut model := &StructSubIdentExpr{
			Token: tok,
			Expr: new(Data, *d),
			Field: f,
			Owner: s,
		}
		d.Model = model
		d.Type = f.Type
		d.Lvalue = true
		if f.Decl.Mutable && !d.Mutable {
			// Interior mutability.
			match type self.lookup {
			| &scopeChecker:
				// Use hard root scope to handle interior mutability.
				// To handle anonymous functions and closures too.
				scope := (&scopeChecker)(self.lookup).getHardRoot()
				d.Mutable = scope.owner != nil && scope.owner.Owner == s
			}
		}
		ret d
	}

	// Like evalStructSubIdent, but checks only for fields.
	fn evalStructSubIdentFieldOnly(mut self, mut d: &Data, mut s: &StructIns, mut si: &ast::SubIdentExpr): (&Data, found: bool) {
		mut f := s.FindField(si.Ident.Kind)
		if f != nil {
			if !self.s.isAccessibleDefine(f.Decl.Public, f.Decl.Token) {
				self.pushErr(si.Ident, build::LogMsg.IdentIsNotAccessible, f.Decl.Ident)
				self.pushSuggestion(build::LogMsg.MakePubToAccess)
			}
			ret self.evalStructSubIdentField(d, s, si.Ident, f), true
		}
		ret nil, false
	}

	// This method evaluates expressions, will not check public availability.
	// The tok parameter should be identifier to accessed.
	fn evalStructSubIdentMethod(mut self, mut &d: &Data, mut &s: &StructIns, mut &tok: &token::Token, mut &m: &Fn, ref: bool): &Data {
		if m.Params[0].IsRef() && !ref {
			self.pushErr(tok, build::LogMsg.RefMethodUsedWithNotRefInstance)
		}

		self.checkDeprecated(m.Directives, tok)

		mut ins := m.instance()
		ins.Owner = s
		self.pushReference[&FnIns](ins)
		mut model := new(Data, *d)
		d.Model = &StructSubIdentExpr{
			Token: tok,
			Expr: model,
			Method: ins,
			Owner: s,
		}
		d.Type = &Type{Kind: ins}
		ret d
	}

	fn evalStructSubIdent(mut self, mut d: &Data, mut s: &StructIns, mut si: &ast::SubIdentExpr, ref: bool): &Data {
		{
			mut tempS := s
			if s.Source != nil {
				tempS = s.Source.Struct()
			}
			if tempS != nil {
				mut r, found := self.evalStructSubIdentFieldOnly(d, tempS, si)
				if found {
					ret r
				}
			}
		}

		const Static = false
		mut m := s.FindMethod(si.Ident.Kind, Static)
		if m == nil {
			self.pushErr(si.Ident, build::LogMsg.ObjHaveNotIdent, s.Decl.Ident, si.Ident.Kind)
			ret nil
		}
		if !self.s.isAccessibleDefine(m.Public, m.Token) {
			self.pushErr(si.Ident, build::LogMsg.IdentIsNotAccessible, m.Ident)
			self.pushSuggestion(build::LogMsg.MakePubToAccess)
		}

		ret self.evalStructSubIdentMethod(d, s, si.Ident, m, ref)
	}

	fn evalIntTypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.Int
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewI64(types::MaxI(kind))
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primInt,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(i64(types::Min(kind)))
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primInt,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalUintTypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.Uint
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewU64(types::MaxU(kind))
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primUint,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalI8TypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.I8
		const min = types::MinI8
		const max = types::MaxI8
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primI8,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primI8,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalI16TypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.I16
		const min = types::MinI16
		const max = types::MaxI16
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primI16,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primI16,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalI32TypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.I32
		const min = types::MinI32
		const max = types::MaxI32
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primI32,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primI32,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalI64TypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.I64
		const min = types::MinI64
		const max = types::MaxI64
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewI64(max)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primI64,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewI64(min)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primI64,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalU8TypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.U8
		const max = types::MaxU8
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primU8,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalU16TypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.U16
		const max = types::MaxU16
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primU16,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalU32TypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.U32
		const max = types::MaxU32
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primU32,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalU64TypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.U64
		const max = types::MaxU64
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewU64(max)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primU64,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalF32TypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.F32
		const max = types::MaxF32
		const min = types::MinF32
		const smallestNonZero = types::SmallestNonZeroF32
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewF64(max)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primF32,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewF64(min)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primF32,
				untyped: true,
			}
		| "SmallestNonZero":
			mut c := constant::Const.NewF64(smallestNonZero)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primF32,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalF64TypeStatic(mut self, ident: &token::Token): &Data {
		const kind: str = types::Kind.F64
		const max = types::MaxF64
		const min = types::MinF64
		const smallestNonZero = types::SmallestNonZeroF64
		match ident.Kind {
		| "Max":
			mut c := constant::Const.NewF64(max)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primF64,
				untyped: true,
			}
		| "Min":
			mut c := constant::Const.NewF64(min)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primF64,
				untyped: true,
			}
		| "SmallestNonZero":
			mut c := constant::Const.NewF64(smallestNonZero)
			c.Kind = kind
			ret &Data{
				Constant: c,
				Model: c,
				Type: primF64,
				untyped: true,
			}
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalPrimStatic(mut self, kind: str, ident: &token::Token): &Data {
		match kind {
		| types::Kind.Int:
			ret self.evalIntTypeStatic(ident)
		| types::Kind.Uint:
			ret self.evalUintTypeStatic(ident)
		| types::Kind.I8:
			ret self.evalI8TypeStatic(ident)
		| types::Kind.I16:
			ret self.evalI16TypeStatic(ident)
		| types::Kind.I32:
			ret self.evalI32TypeStatic(ident)
		| types::Kind.I64:
			ret self.evalI64TypeStatic(ident)
		| types::Kind.U8:
			ret self.evalU8TypeStatic(ident)
		| types::Kind.U16:
			ret self.evalU16TypeStatic(ident)
		| types::Kind.U32:
			ret self.evalU32TypeStatic(ident)
		| types::Kind.U64:
			ret self.evalU64TypeStatic(ident)
		| types::Kind.F32:
			ret self.evalF32TypeStatic(ident)
		| types::Kind.F64:
			ret self.evalF64TypeStatic(ident)
		|:
			self.pushErr(ident, build::LogMsg.TypeHaveNotIdent, kind, ident.Kind)
			ret nil
		}
	}

	fn evalTypeStatic(mut self, mut d: &Data, mut si: &ast::SubIdentExpr): &Data {
		match {
		| d.Type.Prim() != nil:
			ret self.evalPrimStatic(d.Type.Prim().Str(), si.Ident)
		| d.Type.Enum() != nil:
			ret self.evalEnumStatic(d.Type.Enum(), si.Ident)
		| d.Type.TypeEnum() != nil:
			ret self.evalTypeEnumStatic(d.Type.TypeEnum(), si.Ident)
		| d.Type.softStruct() != nil:
			ret self.evalStructStatic(d.Type.softStruct(), si.Ident)
		|:
			self.pushErr(si.Ident, build::LogMsg.TypeNotSupportSubFields, d.Type.Str())
			ret nil
		}
	}

	fn comptimeObjSubIdent[ComptimeType](mut self, mut &ct: &ComptimeType, &d: &Data, &si: &ast::SubIdentExpr): &Data {
		mut cd := ct.subIdent(si.Ident.Kind)
		if cd == nil {
			self.pushErr(si.Ident, build::LogMsg.ObjHaveNotIdent, d.Type.Str(), si.Ident.Kind)
		}
		ret cd
	}

	fn tryComptimeObjSubIdent(mut self, mut &d: &Data, mut si: &ast::SubIdentExpr): (&Data, bool) {
		match {
		| d.Type.comptimeTypeInfo() != nil:
			mut ct := d.Type.comptimeTypeInfo()
			ret self.comptimeObjSubIdent(ct, d, si), true
		| d.Type.comptimeStructField() != nil:
			mut ct := d.Type.comptimeStructField()
			ret self.comptimeObjSubIdent(ct, d, si), true
		| d.Type.comptimeEnumField() != nil:
			mut ct := d.Type.comptimeEnumField()
			ret self.comptimeObjSubIdent(ct, d, si), true
		| d.Type.comptimeParam() != nil:
			mut ct := d.Type.comptimeParam()
			ret self.comptimeObjSubIdent(ct, d, si), true
		| d.Type.comptimeStatic() != nil:
			mut ct := d.Type.comptimeStatic()
			ret self.comptimeObjSubIdent(ct, d, si), true
		| d.Type.comptimeValue() != nil:
			mut ct := d.Type.comptimeValue()
			ret self.comptimeObjSubIdent(ct, d, si), true
		| d.Type.comptimeFile() != nil:
			mut ct := d.Type.comptimeFile()
			ret self.comptimeObjSubIdent(ct, d, si), true
		| d.Type.comptimeDecl() != nil:
			mut ct := d.Type.comptimeDecl()
			ret self.comptimeObjSubIdent(ct, d, si), true
		|:
			ret nil, false
		}
	}

	fn evalObjSubIdent(mut self, mut d: &Data, mut si: &ast::SubIdentExpr): &Data {
		if token::IsIgnoreIdent(si.Ident.Kind) {
			self.pushErr(si.Ident, build::LogMsg.InvalidSyntax)
			ret nil
		}
		{
			mut compData, ok := self.tryComptimeObjSubIdent(d, si)
			if ok {
				ret compData
			}
		}
		mut kind := d.Type
		match type d.Type.Kind {
		| &Ptr:
			mut ptr := (&Ptr)(d.Type.Kind)
			if ptr.IsUnsafe() {
				break
			}
			if !self.isUnsafe() {
				self.pushErr(si.Ident, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
			}
			kind = ptr.Elem
			makeImplicitDeref(d, si.Ident)
		| &Sptr:
			mut sptr := (&Sptr)(d.Type.Kind)
			kind = sptr.Elem
			makeImplicitDeref(d, si.Ident)
		}

		match type kind.Kind {
		| &StructIns:
			mut s := (&StructIns)(kind.Kind)
			if s.Source != nil || isInstancedStruct(s) {
				mut usedReferenceElem := false
				match type d.Type.Kind {
				| &Sptr:
					usedReferenceElem = true
				}
				ret self.evalStructSubIdent(d, s, si, usedReferenceElem)
			}
		}
		if d.Type.Trait() != nil {
			ret self.evalTraitSubIdent(d, d.Type.Trait(), si.Ident)
		}
		self.pushErr(si.Ident, build::LogMsg.ObjNotSupportSubFields, d.Type.Str())
		ret nil
	}

	fn evalSubIdent(mut &self, mut si: &ast::SubIdentExpr): &Data {
		mut prefix := self.prefix
		self.prefix = nil
		defer { self.prefix = prefix }
		mut d := self.evalExprKind(si.Expr.Kind)
		if d == nil {
			ret nil
		}
		if d.Decl {
			ret self.evalTypeStatic(d, si)
		}
		ret self.evalObjSubIdent(d, si)
	}

	fn evalTupleFunc(mut &self, mut tup: &ast::TupleExpr, part: fn(mut &expr: &ast::Expr): &Data): &Data {
		mut tupT := new(Tuple)
		tupT.Types = make([]&Type, 0, len(tup.Expr))

		mut model := &TupleExpr{
			Datas: make([]&Data, 0, len(tup.Expr)),
		}

		mut ok := true
		for (_, mut expr) in tup.Expr {
			mut d := part(expr)
			if d == nil {
				ok = false
				continue
			}
			tupT.Types = append(tupT.Types, d.Type)
			model.Datas = append(model.Datas, d)
		}

		if !ok {
			ret nil
		}

		ret &Data{
			Type: &Type{Kind: tupT},
			Model: model,
		}
	}

	fn evalTuple(mut &self, mut tup: &ast::TupleExpr): &Data {
		ret self.evalTupleFunc(tup, fn(mut &expr: &ast::Expr): &Data {
			ret self.evalExpr(expr)
		})
	}

	fn evalMap(mut &self, mut m: &Map, mut lit: &ast::BraceLit): &Data {
		mut model := &MapExpr{
			Kind: m,
		}

		for (_, mut expr) in lit.Exprs {
			match type expr.Kind {
			| &ast::KeyValPair:
				// Ok.
				break
			|:
				self.pushErr(lit.Token, build::LogMsg.InvalidSyntax)
				ret nil
			}

			mut pair := (&ast::KeyValPair)(expr.Kind)

			mut key := self.evalExpr(pair.Key)
			if key == nil {
				ret nil
			}

			mut val := self.evalExpr(pair.Val)
			if val == nil {
				ret nil
			}

			const destIsRef = false
			if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, m.Key, key, pair.Key.Token) {
				_ = self.s.checkAssignType(destIsRef, m.Key, key, pair.Key.Token, self.getOwnerRefers())
			}
			if self.s.checkValidityForInitExpr(self.target.mutable, destIsRef, m.Val, val, pair.Val.Token) {
				_ = self.s.checkAssignType(destIsRef, m.Val, val, pair.Val.Token, self.getOwnerRefers())
			}

			model.Entries = append(model.Entries, &KeyValPairExpr{
				Key: key.Model,
				Val: val.Model,
			})
		}

		ret &Data{
			Mutable: true,
			Type: &Type{Kind: m},
			Model: model,
		}
	}

	fn evalBraceLit(mut &self, mut lit: &ast::BraceLit): (d: &Data) {
		match {
		| self.prefix == nil:
			self.pushErr(lit.Token, build::LogMsg.InvalidSyntax)
			ret nil
		| self.prefix.Map() != nil:
			d = self.evalMap(self.prefix.Map(), lit)
		| self.prefix.Struct() != nil:
			d = self.evalStructLitExplicit(self.prefix.Struct(), lit.Exprs, lit.Token)
		|:
			self.pushErr(lit.Token, build::LogMsg.InvalidSyntax)
			ret nil
		}
		if d != nil {
			mut strct := self.prefix.softStruct()
			if strct != nil && strct.Source != nil {
				d.Type = &Type{Kind: strct}
				match type d.Model {
				| &StructLitExpr:
					(&StructLitExpr)(d.Model).Strct = strct
				}
			}
		}
		ret
	}

	fn evalAnonFunc(mut &self, mut decl: &ast::FnDecl): &Data {
		mut tc := typeChecker{
			s: self.s,
			rootLookup: self.lookup,
			lookup: self.lookup,
		}
		mut ins := tc.buildFunc(decl)
		if ins == nil {
			ret nil
		}
		ins.AsAnon = true
		mut captured := make([]&Var, 0)
		match type self.lookup {
		| &scopeChecker:
			mut sc := (&scopeChecker)(self.lookup)
			mut scc := sc.newChildChecker()
			scc.labels = new([]&scopeLabel, nil)
			scc.gotos = new([]&GotoSt, nil)
			scc.owner = ins
			scc.childIndex = 0
			scc.it = 0
			scc.cse = 0
			scc.captured = unsafe { (&[]&Var)(&captured) }
			self.s.checkFnInsSc(ins, scc)
		|:
			self.s.checkFnIns(ins)
		}

		ret &Data{
			Type: &Type{Kind: ins},
			Model: &AnonFnExpr{
				Captured: captured,
				Func: ins,
				Global: self.isGlobal(),
			},
		}
	}

	fn evalBinary(mut &self, mut op: &ast::BinaryExpr): &Data {
		mut bs := binaryEval.newPlain(self)
		// Apply prefix for just numericals.
		if self.prefix != nil {
			prim := self.prefix.Prim()
			if prim == nil || !types::IsNum(prim.Str()) {
				mut prefix := self.prefix
				self.prefix = nil
				defer { self.prefix = prefix }
				ret bs.eval(op)
			}
		}
		ret bs.eval(op)
	}

	fn evalExprKind(mut &self, mut kind: ast::ExprData): &Data {
		match type kind {
		| &ast::RangeExpr:
			mut e := (&ast::RangeExpr)(kind)
			ret self.evalExprKind(e.Expr.Kind)
		| &ast::LitExpr:
			ret self.evalLit((&ast::LitExpr)(kind))
		| &ast::IdentExpr:
			ret self.evalIdent((&ast::IdentExpr)(kind))
		| &ast::UnaryExpr:
			ret self.evalUnary((&ast::UnaryExpr)(kind))
		| &ast::VariadicExpr:
			ret self.evalVariadic((&ast::VariadicExpr)(kind))
		| &ast::UnsafeExpr:
			ret self.evalUnsafe((&ast::UnsafeExpr)(kind))
		| &ast::SliceExpr:
			ret self.evalSliceExpr((&ast::SliceExpr)(kind))
		| &ast::IndexingExpr:
			ret self.evalIndexing((&ast::IndexingExpr)(kind))
		| &ast::SlicingExpr:
			ret self.evalSlicing((&ast::SlicingExpr)(kind))
		| &ast::CastExpr:
			ret self.evalCast((&ast::CastExpr)(kind))
		| &ast::NamespaceExpr:
			ret self.evalNamespace((&ast::NamespaceExpr)(kind))
		| &ast::StructLit:
			ret self.evalStructLit((&ast::StructLit)(kind))
		| &ast::TypeDecl:
			ret self.evalType((&ast::TypeDecl)(kind))
		| &ast::FnCallExpr:
			ret self.evalFnCall((&ast::FnCallExpr)(kind))
		| &ast::SubIdentExpr:
			ret self.evalSubIdent((&ast::SubIdentExpr)(kind))
		| &ast::TupleExpr:
			ret self.evalTuple((&ast::TupleExpr)(kind))
		| &ast::BraceLit:
			ret self.evalBraceLit((&ast::BraceLit)(kind))
		| &ast::FnDecl:
			ret self.evalAnonFunc((&ast::FnDecl)(kind))
		| &ast::BinaryExpr:
			ret self.evalBinary((&ast::BinaryExpr)(kind))
		|:
			ret nil
		}
	}

	// Returns value data of evaluated expression.
	// Returns nil if error occurs.
	fn eval1(mut &self, mut expr: &ast::Expr): &Data {
		mut d := self.evalExprKind(expr.Kind)
		if d == nil || d.Type == nil {
			ret nil
		}

		match {
		| d.Type.Fn() != nil:
			// Check special cases for functions.
			mut f := d.Type.Fn()
			if f.IsBuiltin() {
				self.s.pushErr(expr.Token, build::LogMsg.BuiltinNotInvoked)
				break
			}
			required := len(f.Decl.Generics)
			given := len(f.Generics)
			if !self.s.checkGenericQuantity(required, given, expr.Token) {
				ret nil
			}
			if !f.Decl.Statically && f.Decl.IsMethod() {
				self.s.pushErr(expr.Token, build::LogMsg.MethodNotInvoked)
			} else if findDirective(f.Decl.Directives, build::Directive.Export) != nil {
				self.s.pushErr(expr.Token, build::LogMsg.ExportedUsedAsAnonymous, f.Decl.Ident)
			} else {
				f.AsAnon = true
			}
		| d.Decl:
			// Check evaluated type declarations.
			mut s := d.Type.Struct()
			if s == nil {
				break
			}
			required := len(s.Decl.Generics)
			given := len(s.Generics)
			if !self.s.checkGenericQuantity(required, given, expr.Token) {
				ret nil
			}
		}

		ret d
	}

	// Returns value data of evaluated expression.
	// Returns nil if error occurs.
	// Accepts comptime expressions as invalid.
	fn eval(mut &self, mut expr: &ast::Expr): &Data {
		mut d := self.eval1(expr)
		if d == nil {
			ret nil
		}
		if (self.owner == nil || !self.owner.Constant) && d.Type.comptime() {
			self.s.pushErr(expr.Token, build::LogMsg.ComptimeAsExpr)
			ret nil
		}
		ret d
	}

	// Returns value data of evaluated expression.
	// Returns nil if error occurs.
	// Accepts decls as invalid expression.
	fn evalExpr1(mut &self, mut expr: &ast::Expr): &Data {
		mut d := self.eval1(expr)
		match {
		| d == nil:
			ret nil
		| d.Decl:
			self.pushErr(expr.Token, build::LogMsg.InvalidExpr)
			ret nil
		|:
			ret d
		}
	}

	// Returns value data of evaluated expression.
	// Returns nil if error occurs.
	// Accepts decls as invalid expression.
	fn evalExpr(mut &self, mut expr: &ast::Expr): &Data {
		mut d := self.eval(expr)
		match {
		| d == nil:
			ret nil
		| d.Decl:
			self.pushErr(expr.Token, build::LogMsg.InvalidExpr)
			ret nil
		|:
			ret d
		}
	}
}

struct unaryEval {
	e: &eval
	d: &Data
	u: &ast::UnaryExpr
}

impl unaryEval {
	static fn new(mut e: &eval): unaryEval {
		ret unaryEval{
			e: e,
		}
	}

	fn minus(mut self) {
		match {
		| self.d.Type == nil:
			self.d = nil
			ret
		| self.d.Type.Prim() != nil:
			if !types::IsNum(self.d.Type.Prim().Str()) {
				self.d = nil
				ret
			}
		|:
			self.d = nil
			ret
		}

		self.d.Lvalue = false
		self.d.Mutable = true

		if self.d.IsConst() {
			match {
			| self.d.Constant.IsF64():
				self.d.Constant.SetF64(-self.d.Constant.ReadF64())
			| self.d.Constant.IsI64():
				self.d.Constant.SetI64(-self.d.Constant.ReadI64())
			| self.d.Constant.IsU64():
				self.d.Constant.SetI64(-self.d.Constant.AsI64())
			|:
				panic("sema: unimplemented constant type for unaryEval.minus, this panic call should be unreachable")
			}
			// Do not self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.d.Model = &UnaryExpr{
			Expr: new(Data, *self.d),
			Op: self.u.Op,
		}
	}

	fn plus(mut self) {
		match {
		| self.d.Type == nil:
			self.d = nil
			ret
		| self.d.Type.Prim() != nil:
			if !types::IsNum(self.d.Type.Prim().Str()) {
				self.d = nil
				ret
			}
		|:
			self.d = nil
			ret
		}

		self.d.Lvalue = false
		self.d.Mutable = true

		if self.d.IsConst() {
			match {
			| self.d.Constant.IsF64():
				self.d.Constant.SetF64(+self.d.Constant.ReadF64())
			| self.d.Constant.IsI64():
				self.d.Constant.SetI64(+self.d.Constant.ReadI64())
			| self.d.Constant.IsU64():
				self.d.Constant.SetI64(+self.d.Constant.AsI64())
			|:
				panic("sema: unimplemented constant type for unaryEval.plus, this panic call should be unreachable")
			}
			// Do not self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.d.Model = &UnaryExpr{
			Expr: new(Data, *self.d),
			Op: self.u.Op,
		}
	}

	fn caret(mut self) {
		match {
		| self.d.Type == nil:
			self.d = nil
			ret
		| self.d.Type.Prim() != nil:
			if !types::IsInt(self.d.Type.Prim().Str()) {
				self.d = nil
				ret
			}
		|:
			self.d = nil
			ret
		}

		self.d.Lvalue = false
		self.d.Mutable = true

		// If type is "int" or "uint", it should be evaluated by target architecture.
		// Evaluate by bitsize of the target architecture and set as i64 again.
		// Also other types should be evaluated by their own bitsize.
		// So implement this operator by bitsize in general.
		if self.d.IsConst() {
			sz := types::BitSizeOf(self.d.Type.Prim().Kind)
			match {
			| self.d.Constant.IsI64():
				match sz {
				| 8:
					self.d.Constant.SetI64(i64(^i8(self.d.Constant.ReadI64())))
				| 16:
					self.d.Constant.SetI64(i64(^i16(self.d.Constant.ReadI64())))
				| 32:
					self.d.Constant.SetI64(i64(^i32(self.d.Constant.ReadI64())))
				| 64:
					self.d.Constant.SetI64(^self.d.Constant.ReadI64())
				|:
					panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
				}
			| self.d.Constant.IsU64():
				match sz {
				| 8:
					self.d.Constant.SetU64(u64(^u8(self.d.Constant.ReadU64())))
				| 16:
					self.d.Constant.SetU64(u64(^u16(self.d.Constant.ReadU64())))
				| 32:
					self.d.Constant.SetU64(u64(^u32(self.d.Constant.ReadU64())))
				| 64:
					self.d.Constant.SetU64(^self.d.Constant.ReadU64())
				|:
					panic("sema: unimplemented bitsize for unaryEval.caret, this panic call should be unreachable")
				}
			|:
				panic("sema: unimplemented constant type for unaryEval.caret, this panic call should be unreachable")
			}
			// Do not self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.d.Model = &UnaryExpr{
			Expr: new(Data, *self.d),
			Op: self.u.Op,
		}
	}

	fn excl(mut self) {
		t := self.d.Type.Prim()
		if t == nil || !t.IsBool() {
			self.d = nil
			ret
		}

		self.d.Lvalue = false
		self.d.Mutable = true

		if self.d.IsConst() {
			match {
			| self.d.Constant.IsBool():
				self.d.Constant.SetBool(!self.d.Constant.ReadBool())
			|:
				panic("sema: unimplemented constant type for unaryEval.excl, this panic call should be unreachable")
			}
			// Do not self model for constant expressions. It's a overhead,
			// because model will be changed to constant by following algorithm.
			ret
		}

		self.d.Model = &UnaryExpr{
			Expr: new(Data, *self.d),
			Op: self.u.Op,
		}
	}

	fn star(mut self) {
		self.d.Model = &UnaryExpr{
			Expr: new(Data, *self.d),
			Op: self.u.Op,
		}

		match {
		| self.d.Type.Ptr() != nil:
			if !self.e.isUnsafe() {
				self.e.pushErr(self.u.Op, build::LogMsg.UnsafeBehaviorAtOutOfUnsafeScope)
			}

			mut t := self.d.Type.Ptr()
			if t.IsUnsafe() {
				self.d = nil
				ret
			}
			self.d.Type = t.Elem
			self.d.Mutable = true
		| self.d.Type.Sptr() != nil:
			self.d.Type = self.d.Type.Sptr().Elem
		|:
			self.d = nil
			ret
		}

		self.d.Constant = nil
		self.d.untyped = false
		self.d.Lvalue = true
	}

	fn amper(mut self) {
		match type self.d.Model {
		| &StructLitExpr:
			mut lit := (&StructLitExpr)(self.d.Model)
			makeStructLitAlloc(self.d, lit)
		|:
			match {
			| canGetPtr(self.d):
				self.d.Type = &Type{
					Kind: &Ptr{Elem: self.d.Type},
				}
				self.d.Model = &UnaryExpr{
					Expr: new(Data, *self.d),
					Op: self.u.Op,
				}
			|:
				self.d = nil
				ret
			}
		}

		self.d.Constant = nil
		self.d.untyped = false
		self.d.Lvalue = false
		self.d.Mutable = true
	}

	fn typeDecl(mut self) {
		mut tc := typeChecker{
			s: self.e.s,
			rootLookup: self.e.lookup,
			lookup: self.e.lookup,
			errorToken: self.u.Op,
		}
		match self.u.Op.Id {
		| token::Id.Star:
			self.d.Type = &Type{Kind: tc.buildPtrFromType(self.d.Type)}
			self.d.Model = self.d.Type
		| token::Id.Amper:
			self.d.Type = &Type{Kind: tc.buildSptrFromType(self.d.Type)}
			self.d.Model = self.d.Type
		|:
			self.e.pushErr(self.u.Op, build::LogMsg.InvalidExprForUnary, self.u.Op.Kind, self.d.Type.Str())
			self.d = nil
			ret
		}
		self.d.Decl = true
	}

	fn evalData(mut self) {
		match self.u.Op.Id {
		| token::Id.Star
		| token::Id.Amper:
			mut prefix := self.e.prefix
			self.e.prefix = nil
			self.d = self.e.eval(self.u.Expr)
			self.e.prefix = prefix
		|:
			self.d = self.e.eval(self.u.Expr)
		}
	}

	fn eval(mut self, mut u: &ast::UnaryExpr): &Data {
		self.u = u
		self.evalData()
		if self.d == nil {
			ret nil
		}
		if self.d.Decl {
			self.typeDecl()
			ret self.d
		}

		kind := self.d.Type
		match self.u.Op.Id {
		| token::Id.Minus:
			self.minus()
		| token::Id.Plus:
			self.plus()
		| token::Id.Caret:
			self.caret()
		| token::Id.Excl:
			self.excl()
		| token::Id.Star:
			self.star()
		| token::Id.Amper:
			self.amper()
		|:
			self.d = nil
		}

		match {
		| self.d == nil:
			self.e.pushErr(self.u.Op, build::LogMsg.InvalidExprForUnary, self.u.Op.Kind, kind.Str())
			ret nil
		| self.d.IsConst():
			self.d.Model = self.d.Constant
		}
		ret self.d
	}
}

struct binaryEval {
	e:  &eval
	l:  &Data
	r:  &Data
	op: &token::Token
}

impl binaryEval {
	static fn newPlain(mut e: &eval): binaryEval {
		ret binaryEval{
			e: e,
		}
	}

	static fn new(mut e: &eval, mut op: &token::Token): binaryEval {
		ret binaryEval{
			e: e,
			op: op,
		}
	}

	// Reports whether types are compatible.
	// Also logs error message about incompatibility if types are incompatible.
	fn checkTypeCompatibility(mut self): bool {
		ret self.e.s.checkTypeCompatibility1(self.l.Type, self.r, self.op)
	}

	fn evalComptimeTypeInfo(mut self): &Data {
		mut r := self.r.Type.comptimeTypeInfo()
		if r == nil {
			self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, "comptimeTypeInfo", self.r.Type.Str())
			ret nil
		}
		mut l := self.l.Type.comptimeTypeInfo()
		match self.op.Id {
		| token::Id.Eqs:
			mut constant := constant::Const.NewBool(l.base.Equal(r.base))
			ret &Data{
				Type: primBool,
				Constant: constant,
				Model: constant,
			}
		| token::Id.NotEq:
			mut constant := constant::Const.NewBool(!l.base.Equal(r.base))
			ret &Data{
				Type: primBool,
				Constant: constant,
				Model: constant,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalNil(mut self): &Data {
		if !self.r.Type.NilCompatible() {
			self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, "nil", self.r.Type.Str())
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			ret &Data{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, "nil")
			ret nil
		}
	}

	fn evalEnum(mut self): &Data {
		mut enm := self.l.Type.Enum()
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			mut rkind := self.r.Type
			if self.r.Type.Enum() != nil {
				rkind = self.r.Type.Enum().TypeSym.Type
			}
			if !self.e.s.checkTypeCompatibility(enm.TypeSym.Type, rkind, self.op) {
				ret nil
			}
			ret &Data{
				Type: primBool,
			}
		}

		if self.r.Type.Enum() == nil || enm != self.r.Type.Enum() {
			self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, enm.Ident, self.r.Type.Str())
			ret nil
		}

		match self.op.Id {
		| token::Id.Gt
		| token::Id.Lt
		| token::Id.GtEq
		| token::Id.LtEq:
			if !types::IsNum(enm.TypeSym.Type.Prim().Str()) {
				self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Ident)
				ret nil
			}
			ret &Data{
				Type: primBool,
			}
		| token::Id.Amper:
			first := enm.Items[0]
			match {
			| first.Value.Data.Constant.IsI64():
				if first.Value.Data.Constant.ReadI64() == 0 {
					goto next
				}
				goto err
			| first.Value.Data.Constant.IsU64():
				if first.Value.Data.Constant.ReadU64() == 0 {
					goto next
				}
				goto err
			|:
				panic("sema: unimplemented enum type, this panic call should be unreachable")
			}
		err:
			self.e.pushErr(self.op, build::LogMsg.AmperOpForEnum, enm.Ident, self.op.Kind)
			self.e.pushSuggestion(build::LogMsg.DefineZeroDefaultToUseAmper)
		next:
			fall
		| token::Id.Vline
		| token::Id.Caret:
			if enm.TypeSym.Type.Prim() == nil || !types::IsInt(enm.TypeSym.Type.Prim().Str()) {
				self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Ident)
			}
			ret self.l
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Ident)
			ret nil
		}
	}

	fn evalTypeEnum(mut self): &Data {
		mut enm := self.l.Type.TypeEnum()
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			ret &Data{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, enm.Str())
			ret nil
		}
	}

	fn evalSptr(mut self): &Data {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			ret &Data{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalPtr(mut self): &Data {
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq
		| token::Id.Lt
		| token::Id.Gt
		| token::Id.LtEq
		| token::Id.GtEq:
			if !self.checkTypeCompatibility() {
				ret nil
			}
			ret &Data{
				Type: primBool,
			}
		| token::Id.Plus
		| token::Id.Minus:
			if self.l.Type.Ptr() == nil {
				self.l, self.r = self.r, self.l
			}
			if self.l.Type.Ptr().IsUnsafe() {
				self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			}
			if !isPtrArithmeticCompatible(self.l, self.r) {
				self.e.pushErr(self.op, build::LogMsg.IncompatibleTypeForPtrArithmetic, self.r.Type.Str())
				ret nil
			}
			ret self.l
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalArr(mut self): &Data {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			if self.e.s.meta.runtime != nil {
				// Add instance to relevant runtime function for array element type if not exist.
				mut f := runtimeFindFn(self.e.s.meta.runtime, runtimeFunc.arrayCmp).instanceForce()
				f.Generics = append(f.Generics, &InsGeneric{Type: self.l.Type.Arr().Elem})
				ok, _ := self.e.s.checkGenericFn(f, self.op)
				if !ok {
					panic("sema: arrayCmp evaluation failed, this is an implementation mistake")
				}
				self.e.pushReference[&FnIns](f)
			}
			ret &Data{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalStruct(mut self): &Data {
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			if !self.checkTypeCompatibility() {
				ret nil
			}
			ret &Data{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalTrait(mut self): &Data {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			ret &Data{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalAny(mut self): &Data {
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq:
			applyImplicitCast(self.e.s, self.l.Type, self.r, self.op, self.e.getOwnerRefers())
			ret &Data{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, str(types::Kind.Any))
			ret nil
		}
	}

	fn evalBool(mut self): &Data {
		if !self.checkTypeCompatibility() {
			ret nil
		}

		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq
		| token::Id.DblAmper
		| token::Id.DblVline:
			ret self.l
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalStr(mut self): &Data {
		mut rk := self.r.Type.Str()
		if rk != types::Kind.Str {
			self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, str(types::Kind.Str), rk)
			ret nil
		}

		match self.op.Id {
		| token::Id.Plus:
			ret self.l
		| token::Id.Eqs
		| token::Id.NotEq
		| token::Id.Lt
		| token::Id.Gt
		| token::Id.GtEq
		| token::Id.LtEq:
			ret &Data{
				Type: primBool,
			}
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, str(types::Kind.Str))
			ret nil
		}
	}

	fn setTypeToGreater(mut self) {
		lp := self.l.Type.Prim()
		rp := self.r.Type.Prim()
		if self.l.untyped && !self.r.untyped {
			self.l.Type = self.r.Type
			self.l.Constant.Kind = rp.Kind
			self.l.untyped = false
		} else if !self.l.untyped && self.r.untyped {
			self.r.Type = self.l.Type
			self.r.Constant.Kind = lp.Kind
			self.r.untyped = false
		} else if self.l.untyped && self.r.untyped {
			self.r.Type = self.l.Type
			self.r.Constant.Kind = lp.Kind
			self.r.untyped = false
		}
	}

	fn checkModData(mut self, mut &d: &Data) {
		if !d.IsConst() {
			if d.Type.Prim() == nil || !types::IsInt(d.Type.Prim().Kind) {
				self.e.pushErr(self.op, build::LogMsg.ModuloWithNotInt)
			}
			ret
		}
		match {
		| sigAssignable(types::Kind.I64, d):
			d.Constant.SetI64(d.Constant.AsI64())
		| unsigAssignable(types::Kind.U64, d):
			d.Constant.SetU64(d.Constant.AsU64())
		|:
			self.e.pushErr(self.op, build::LogMsg.ModuloWithNotInt)
		}
	}

	fn mod(mut self) {
		self.checkModData(self.l)
		self.checkModData(self.r)
	}

	fn numbersAreCompatibile(self, &lk: str, &rk: str): bool {
		if !types::IsNum(rk) {
			ret false
		}
		if self.l.IsConst() && self.l.untyped {
			ret true
		}
		if lk == types::Kind.F32 {
			if self.r.IsConst() && self.r.untyped {
				ret floatAssignable(lk, self.r)
			}
			ret rk == types::Kind.F32
		}
		if lk == types::Kind.F64 {
			if self.r.IsConst() && self.r.untyped {
				ret floatAssignable(lk, self.r)
			}
			ret rk == types::Kind.F64
		}
		if self.r.IsConst() && self.r.untyped {
			ret intAssignable(lk, self.r)
		}
		ret lk == rk
	}

	// Operator guaranteed to be << or >>.
	// Operands should be guaranteed in original order.
	fn shift(mut self): &Data {
		lk := self.l.Type.Prim()
		if lk == nil {
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
		rk := self.r.Type.Prim()
		if rk == nil {
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.r.Type.Str())
			ret nil
		}
		// primitive guaranteed

		if !types::IsNum(lk.Kind) || !types::IsNum(rk.Kind) {
			self.e.s.pushCompatiblityError(self.l.Type, self.r, self.op)
			ret nil
		}
		// number guaranteed

		if !types::IsInt(lk.Kind) {
			// should be floating-point
			if !self.l.IsConst() || !self.l.untyped {
				self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, lk.Kind, rk.Kind)
				ret nil
			} else if intAssignable(types::Kind.I64, self.l) {
				self.l.Constant.SetI64(self.l.Constant.AsI64())
				self.l.Type = primI64
			} else if intAssignable(types::Kind.U64, self.l) {
				self.l.Constant.SetU64(self.l.Constant.AsU64())
				self.l.Type = primU64
			}
		}
		if !types::IsInt(rk.Kind) {
			// should be floating-point
			if !self.r.IsConst() || !self.l.untyped {
				self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, lk.Kind, rk.Kind)
				ret nil
			} else if intAssignable(types::Kind.I64, self.r) {
				self.r.Constant.SetI64(self.r.Constant.AsI64())
				self.r.Type = primI64
			} else if intAssignable(types::Kind.U64, self.r) {
				self.r.Constant.SetU64(self.r.Constant.AsU64())
				self.r.Type = primU64
			}
		}
		// integer guaranteed

		if !isOkForShifting(self.r) {
			self.e.pushErr(self.op, build::LogMsg.BitShiftMustUnsigned)
			ret nil
		}
		// unsigned guaranteed
		ret self.l
	}

	fn evalFloat(mut self): &Data {
		lk := self.l.Type.Prim().Kind // Float guaranteed.
		rk := self.r.Type.Prim().Kind // Primitive guaranteed.
		if !self.numbersAreCompatibile(lk, rk) {
			self.e.s.pushCompatiblityError(self.l.Type, self.r, self.op)
			ret nil
		}

		// Logicals.
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq
		| token::Id.Lt
		| token::Id.Gt
		| token::Id.GtEq
		| token::Id.LtEq:
			self.setTypeToGreater()
			ret &Data{
				Type: primBool,
			}
		}

		// Arithmetics.
		match self.op.Id {
		| token::Id.Shl
		| token::Id.Shr:
			panic("sema: binary shifting operator handling failed")
		| token::Id.Plus
		| token::Id.Minus
		| token::Id.Star:
			self.setTypeToGreater()
			ret self.l
		| token::Id.Solidus:
			self.setTypeToGreater()
			ret self.l
		| token::Id.Percent:
			if !types::IsInt(rk) {
				self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, lk, rk)
				ret nil
			}
			self.mod()
			self.setTypeToGreater()
			ret self.r
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForFloat, self.op.Kind)
			ret nil
		}
	}

	fn evalInt(mut self): &Data {
		lk := self.l.Type.Prim().Kind // Integer guaranteed.
		rk := self.r.Type.Prim().Kind // Primitive guaranteed.

		if !self.numbersAreCompatibile(lk, rk) {
			self.e.s.pushCompatiblityError(self.l.Type, self.r, self.op)
			ret nil
		}

		// Logicals.
		match self.op.Id {
		| token::Id.Eqs
		| token::Id.NotEq
		| token::Id.Lt
		| token::Id.Gt
		| token::Id.GtEq
		| token::Id.LtEq:
			ret &Data{
				Type: primBool,
			}
		}

		// Arithmetics.
		match self.op.Id {
		| token::Id.Shl
		| token::Id.Shr:
			panic("sema: binary shifting operator handling failed")
		| token::Id.Plus
		| token::Id.Minus
		| token::Id.Star
		| token::Id.Amper
		| token::Id.Vline
		| token::Id.Caret:
			self.setTypeToGreater()
			ret self.l
		| token::Id.Solidus:
			self.setTypeToGreater()
			ret self.l
		| token::Id.Percent:
			self.mod()
			self.setTypeToGreater()
			ret self.l
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForInt, self.op.Kind)
			ret nil
		}
	}

	fn evalPrim(mut self): &Data {
		prim := self.l.Type.Prim()
		match {
		| prim.IsBool():
			ret self.evalBool()
		| prim.IsStr():
			ret self.evalStr()
		}

		if self.r.Type.Prim() == nil {
			self.e.pushErr(self.op, build::LogMsg.IncompatibleTypes, prim.Str(), self.r.Type.Str())
			ret nil
		}

		match {
		| types::IsFloat(prim.Kind):
			ret self.evalFloat()
		| types::IsInt(prim.Kind):
			ret self.evalInt()
		|:
			ret nil
		}
	}

	fn checkSpecialCases(mut self): (ok: bool) {
		ok = true
		comparing := self.op.Id == token::Id.Eqs || self.op.Id == token::Id.NotEq
		if !comparing {
			ret
		}
		if !self.l.Type.Comparable() && !self.r.Type.IsNil() {
			self.e.pushErr(self.op, build::LogMsg.TypeIsNotComparable, self.l.Type.Str())
			ok = false
		} else if !self.r.Type.Comparable() && !self.l.Type.IsNil() {
			self.e.pushErr(self.op, build::LogMsg.TypeIsNotComparable, self.r.Type.Str())
			ok = false
		}
		ret ok
	}

	fn evalOp(mut self): &Data {
		ok := self.checkSpecialCases()
		if !ok {
			ret nil
		}

		// Shift operators.
		if self.op.Id == token::Id.Shl || self.op.Id == token::Id.Shr {
			ret self.shift()
		}

		match {
		| self.l.Type.Void():
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, "void")
			ret nil
		| self.r.Type.comptimeTypeInfo() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.comptimeTypeInfo() != nil:
			ret self.evalComptimeTypeInfo()
		| self.r.Type.Prim() != nil && self.r.Type.Prim().IsAny():
			self.l, self.r = self.r, self.l
			fall
		| self.r.Type.IsNil():
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.IsNil():
			ret self.evalNil()
		| self.l.Type.Prim() != nil && self.l.Type.Prim().IsAny():
			ret self.evalAny()
		| self.r.Type.TypeEnum() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.TypeEnum() != nil:
			ret self.evalTypeEnum()
		| self.r.Type.Enum() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Enum() != nil:
			ret self.evalEnum()
		| self.r.Type.Sptr() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Sptr() != nil:
			ret self.evalSptr()
		| self.r.Type.Ptr() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Ptr() != nil:
			ret self.evalPtr()
		| self.l.Type.Arr() != nil:
			ret self.evalArr()
		| self.r.Type.Trait() != nil:
			self.l, self.r = self.r, self.l
			fall
		| self.l.Type.Trait() != nil:
			ret self.evalTrait()
		| self.l.Type.Prim() != nil:
			ret self.evalPrim()
		| self.l.Type.Struct() != nil:
			ret self.evalStruct()
		|:
			self.e.pushErr(self.op, build::LogMsg.OperatorNotForJuleType, self.op.Kind, self.l.Type.Str())
			ret nil
		}
	}

	fn evalConst(mut self, mut &d: &Data) {
		match {
		| d == nil
		| self.l.Model == nil
		| self.r.Model == nil:
			ret
		| !self.l.IsConst()
		| !self.r.IsConst():
			d.Constant = nil
			d.untyped = false
			ret
		}

		match self.op.Id {
		| token::Id.Eqs:
			d.Constant = constant::Const.NewBool(self.l.Constant.Eq(*self.r.Constant))
		| token::Id.NotEq:
			d.Constant = constant::Const.NewBool(!self.l.Constant.Eq(*self.r.Constant))
		| token::Id.DblVline:
			d.Constant = constant::Const.NewBool(self.l.Constant.Or(*self.r.Constant))
		| token::Id.DblAmper:
			d.Constant = constant::Const.NewBool(self.l.Constant.And(*self.r.Constant))
		| token::Id.Gt:
			d.Constant = constant::Const.NewBool(self.l.Constant.Gt(*self.r.Constant))
		| token::Id.Lt:
			d.Constant = constant::Const.NewBool(self.l.Constant.Lt(*self.r.Constant))
		| token::Id.GtEq:
			d.Constant = constant::Const.NewBool(self.l.Constant.GtEq(*self.r.Constant))
		| token::Id.LtEq:
			d.Constant = constant::Const.NewBool(self.l.Constant.LtEq(*self.r.Constant))
		| token::Id.Plus:
			_ = self.l.Constant.Add(*self.r.Constant)
			d.Constant = self.l.Constant
		| token::Id.Minus:
			_ = self.l.Constant.Sub(*self.r.Constant)
			d.Constant = self.l.Constant
		| token::Id.Star:
			_ = self.l.Constant.Mul(*self.r.Constant)
			d.Constant = self.l.Constant
		| token::Id.Solidus:
			ok := self.l.Constant.Div(*self.r.Constant)
			if !ok && self.r.Constant.AsF64() == 0 {
				self.e.pushErr(self.op, build::LogMsg.DivByZero)
			}
			d.Constant = self.l.Constant
			mut prim := d.Type.Prim()
			match {
			| types::IsSigInt(prim.Kind):
				d.Constant.SetI64(d.Constant.AsI64())
			| types::IsUnsigInt(prim.Kind):
				d.Constant.SetU64(d.Constant.AsU64())
			}
		| token::Id.Percent:
			ok := self.l.Constant.Mod(*self.r.Constant)
			if !ok && self.r.Constant.AsF64() == 0 {
				self.e.pushErr(self.op, build::LogMsg.DivByZero)
			}
			d.Constant = self.l.Constant
		| token::Id.Vline:
			_ = self.l.Constant.BitwiseOr(*self.r.Constant)
			d.Constant = self.l.Constant
		| token::Id.Amper:
			_ = self.l.Constant.BitwiseAnd(*self.r.Constant)
			d.Constant = self.l.Constant
		| token::Id.Caret:
			_ = self.l.Constant.Xor(*self.r.Constant)
			d.Constant = self.l.Constant
		| token::Id.Shl:
			_ = self.l.Constant.Lshift(*self.r.Constant)
			d.Constant = self.l.Constant
		| token::Id.Shr:
			_ = self.l.Constant.Rshift(*self.r.Constant)
			d.Constant = self.l.Constant
		}
		d.Model = d.Constant
		applyCastModelByEnum(self.e.s, d, d.Type.Enum(), self.op, self.e.getOwnerRefers())
	}

	fn checkData(mut self, mut &d: &Data) {
		f := d.Type.Fn()
		if f != nil && f.Decl != nil && f.Decl.IsMethod() {
			self.e.pushErr(self.op, build::LogMsg.InvalidExprForBinary)
		}
	}

	fn checkDatas(mut self) {
		self.checkData(self.l)
		self.checkData(self.r)
	}

	fn setModel(mut self, mut &d: &Data) {
		if d.IsConst() {
			if self.l.IsConst() && self.r.IsConst() ||
				self.l.Model == nil && self.r.Model == nil {
				// Left and right are pure constant or comptime expression.
				// Do not break this with changing Model.
				ret
			}
		}

		// See developer reference (9).
		mut l, mut r := self.l, self.r
		if !l.GoodOperand(r) {
			l, r = r, l
		}

		d.Model = &BinaryExpr{
			Left: &OperandExpr{
				Type: l.Type,
				Model: l.Model,
			},
			Right: &OperandExpr{
				Type: r.Type,
				Model: r.Model,
			},
			Op: self.op,
		}
	}

	fn postEval(mut self, mut &d: &Data) {
		d.Lvalue = false
		self.setModel(d)
	}

	fn solveExplicit(mut self, mut &l: &Data, mut &r: &Data): &Data {
		self.l, self.r = l, r

		self.checkDatas()

		mut d := self.evalOp()

		// Save normal order
		self.l, self.r = l, r

		self.evalConst(d)

		if d != nil {
			d.Mutable = true
			self.postEval(d)
		}

		ret d
	}

	fn eval(mut self, mut &op: &ast::BinaryExpr): &Data {
		if op.Op.Id == token::Id.Eq {
			self.e.pushErr(op.Op, build::LogMsg.AssignInExpr)
			self.e.pushSuggestion(build::LogMsg.UseImperative)
			ret nil
		}

		mut l := self.e.evalExpr1(op.Left)
		if l == nil || l.Type == nil {
			ret nil
		}

		mut prefix := self.e.prefix
		self.e.prefix = l.Type
		defer { self.e.prefix = prefix }
		mut r := self.e.evalExpr1(op.Right)
		if r == nil || r.Type == nil {
			ret nil
		}

		self.op = op.Op

		mut d := self.solveExplicit(l, r)

		// Save rune type.
		if d != nil && l.IsRune && r.IsRune {
			d.IsRune = true
		}

		ret d
	}
}

// Returns directive if exist.
fn findDirective(mut &directives: []&ast::Directive, d: build::Directive): &ast::Directive {
	for (_, mut dr) in directives {
		if dr.Tag.Kind == d {
			ret dr
		}
	}
	ret nil
}

fn findBuiltinsImport(&ident: str, imp: &ImportInfo): any {
	ret findPackageBuiltinDef(imp.LinkPath, ident)
}

// If current type is not enough to store constant data, update to minimum type
// that can store constant data. This function designed for numerical types only.
// Data should be numerical constant of course. Also fits types for integers.
// If data is signed but kind is unsigned, type will be fit to signed and same
// thing for unsigned data and signed kinds.
fn fitBitsize(mut &d: &Data) {
	mut prim := d.Type.Prim()
	z := types::BitSizeOf(prim.Str())
	match {
	| d.Constant.IsI64():
		k := types::BitSizeOfInt(d.Constant.ReadI64())
		if k > z || types::IsUnsigInt(prim.Kind) {
			d.Constant.Kind = types::IntFromBits(k)
			d.Type = findBuiltinTypeAlias(d.Constant.Kind).TypeSym.Type
		}
	| d.Constant.IsU64():
		k := types::BitSizeOfUint(d.Constant.ReadU64())
		if k > z || types::IsSigInt(prim.Kind) {
			d.Constant.Kind = types::UintFromBits(k)
			d.Type = findBuiltinTypeAlias(d.Constant.Kind).TypeSym.Type
		}
	| d.Constant.IsF64():
		if z == 1<<6 {
			// z is already equals to biggest bitsize.
			ret
		}
		k := types::BitSizeOfFloat(d.Constant.ReadF64())
		if k > z {
			d.Constant.Kind = types::FloatFromBits(k)
			d.Type = findBuiltinTypeAlias(d.Constant.Kind).TypeSym.Type
		}
	}
}

fn makeStructLitAlloc(mut &d: &Data, mut &lit: &StructLitExpr) {
	d.Type = &Type{
		Kind: &Sptr{
			Elem: &Type{Kind: lit.Strct},
		},
	}
	d.Model = &AllocStructLitExpr{
		Lit: lit,
	}
}

fn buildErrorVar(mut &s: &Scope, mut &fc: &ast::FnCallExpr): &Var {
	ret &Var{
		Used: true,
		Reference: false,
		Mutable: true,
		Ident: "error",
		Token: fc.Token,
		TypeSym: findBuiltinTypeAlias(types::Kind.Any).TypeSym,
		Scope: s,
		Value: &Value{
			Data: new(Data),
		},
	}
}

fn findBuiltinsSema(&ident: str, mut s: &sema): any {
	// If package is std, check for internal builtin defines.
	mut ppath := s.file.File.Dir()
	if strings::HasPrefix(ppath, build::PathStdlib) {
		// Remove STDLIB directory path.
		ppath = ppath[len(build::PathStdlib):]
		// Add "std" to beginning without separator
		// because path has separator at beginning.
		ppath = "std" + strings::ReplaceAll(ppath, str(filepath::Separator), jule::ImportPathSep)
		ret findPackageBuiltinDef(ppath, ident)
	}

	ret nil
}

fn isOkForShifting(mut &d: &Data): bool {
	if d.IsConst() {
		match {
		| d.Constant.IsI64():
			ret d.Constant.ReadI64() >= 0
		| d.Constant.IsU64():
			ret true
		| d.Constant.IsF64():
			ret d.Constant.ReadF64() >= 0
		|:
			ret false
		}
	}
	prim := d.Type.Prim()
	ret prim != nil && types::IsInt(prim.Str())
}

fn isInstancedStruct(s: &StructIns): bool {
	ret len(s.Decl.Generics) == len(s.Generics)
}

fn isPtrArithmeticCompatible(mut &l: &Data, mut &r: &Data): bool {
	ptr := r.Type.Ptr()
	if ptr != nil {
		ret l.Type.Ptr().Elem.Equal(ptr.Elem)
	}
	if r.IsConst() && r.untyped {
		ret intAssignable(types::Kind.Int, r) ||
			intAssignable(types::Kind.Uint, r)
	}

	mut tcc := typeCompatibilityChecker{
		dest: primInt,
		src: r.Type,
	}
	if tcc.check() {
		ret true
	}
	tcc.dest = primUint
	ret tcc.check()
}

fn applyRuntimeToStr(mut &s: &sema, mut &from: &Type, mut &to: &Type,
	mut &token: &token::Token, mut refers: &ReferenceStack) {
	prim := to.Prim()
	if prim != nil {
		if prim.IsAny() {
			pushRuntimeToStr(s, from, token, refers)
		}
		ret
	}
	if to.TypeEnum() != nil {
		pushRuntimeToStr(s, from, token, refers)
		ret
	}
}

fn applyCastKindModel(mut &s: &sema, mut &d: &Data, mut &t: &Type,
	mut &token: &token::Token, mut refers: &ReferenceStack) {
	applyRuntimeToStr(s, d.Type, t, token, refers)
	d.Model = &CastingExpr{
		Token: token,
		Expr: new(Data, *d),
		Type: t,
		ExprType: d.Type,
	}
}

fn applyCastKind(mut &s: &sema, mut &d: &Data, mut &t: &Type,
	mut &token: &token::Token, mut refers: &ReferenceStack) {
	applyCastKindModel(s, d, t, token, refers)
	d.Type = t
}

fn buildVoidData(): &Data {
	ret &Data{
		Type: primVoid,
	}
}

fn checkDataForIntegerIndexing(mut &s: &sema, mut &d: &Data,
	mut &token: &token::Token, mut refers: &ReferenceStack): (errFmt: build::LogMsg) {
	if d == nil {
		ret build::LogMsg.Empty
	}

	match {
	| d.Type.Prim() == nil:
		ret build::LogMsg.InvalidTypeForIndexing
	| !types::IsInt(d.Type.Prim().Str()):
		ret build::LogMsg.InvalidTypeForIndexing
	| d.IsConst():
		if d.Constant.AsF64() < 0 {
			ret build::LogMsg.OverflowLimits
		}
	| d.Type.Prim() == nil
	| d.IsConst()
	| types::RealKindOf(d.Type.Prim().Str()) != types::RealKindOf(types::Kind.Int):
		applyCastKind(s, d, primInt, token, refers)
	}
	ret build::LogMsg.Empty
}

// Applies casting Model: to data by enum.
// This is necessary to keep exact same type of enum's field type.
// The parameter d should be constant data.
fn applyCastModelByEnum(mut &s: &sema, mut &d: &Data, mut e: &Enum,
	mut &token: &token::Token, mut refers: &ReferenceStack) {
	if e == nil {
		ret
	}
	applyCastKindModel(s, d, e.TypeSym.Type, token, refers)
}

fn castConstByType(&t: str, mut &d: &Data) {
	match {
	| types::IsSigInt(t):
		match types::BitSizeOf(types::RealKindOf(t)) {
		| 1 << 6:
			d.Constant.SetI64(d.Constant.AsI64())
		| 1 << 5:
			d.Constant.SetI64(i64(i32(d.Constant.AsI64())))
		| 1 << 4:
			d.Constant.SetI64(i64(i16(d.Constant.AsI64())))
		| 1 << 3:
			d.Constant.SetI64(i64(i8(d.Constant.AsI64())))
		}
	| types::IsUnsigInt(t):
		match types::BitSizeOf(types::RealKindOf(t)) {
		| 1 << 6:
			d.Constant.SetU64(d.Constant.AsU64())
		| 1 << 5:
			d.Constant.SetU64(u64(u32(d.Constant.AsU64())))
		| 1 << 4:
			d.Constant.SetU64(u64(u16(d.Constant.AsU64())))
		| 1 << 3:
			d.Constant.SetU64(u64(u8(d.Constant.AsU64())))
		}
	| types::IsFloat(t):
		match types::BitSizeOf(types::RealKindOf(t)) {
		| 1 << 6:
			d.Constant.SetF64(d.Constant.AsF64())
		| 1 << 5:
			d.Constant.SetF64(f64(f32(d.Constant.AsF64())))
		}
	}
}

fn updateModelToGenericIns(mut &m: Expr, mut &f: &FnIns) {
	match type m {
	| &FnIns:
		m = f
	| &StructSubIdentExpr:
		(&StructSubIdentExpr)(m).Method = f
	| &StructStaticIdentExpr:
		(&StructStaticIdentExpr)(m).Method = f
	}
}

fn pushSubIdentFromExpr(mut expr: ast::ExprData, mut &t: &ast::SubIdentTypeDecl): bool {
	match type expr {
	| &ast::IdentExpr:
		mut e := (&ast::IdentExpr)(expr)
		t.Idents = append(t.Idents, &ast::IdentTypeDecl{
			Token: e.Token,
			Ident: e.Ident,
		})
	| &ast::SubIdentExpr:
		mut e := (&ast::SubIdentExpr)(expr)
		if !pushSubIdentFromExpr(e.Expr.Kind, t) {
			ret false
		}
		t.Idents = append(t.Idents, &ast::IdentTypeDecl{
			Token: e.Ident,
			Ident: e.Ident.Kind,
		})
	|:
		ret false
	}
	ret true
}

fn constoa(&c: &constant::Const): str {
	match {
	| c.IsI64():
		ret conv::FmtInt(c.ReadI64(), 10)
	| c.IsU64():
		ret conv::FmtUint(c.ReadU64(), 10)
	|:
		ret ""
	}
}

fn evalEnumStatic(mut &s: &sema, mut &enm: &Enum, mut &item: &EnumItem,
	mut &token: &token::Token, mut refers: &ReferenceStack): &Data {
	mut d := &Data{
		Type: &Type{
			Kind: enm,
		},
	}
	if item != nil {
		d.Constant = new(constant::Const, *item.Value.Data.Constant)
		d.Model = d.Constant
		applyCastModelByEnum(s, d, enm, token, refers)
	}
	ret d
}

// Reports whether expression model is literal-based.
// Works for literals, sub-idents and castings.
// Returns nil if not, otherwise returns the literal model.
fn isLitBased(mut &m: Expr): &StructLitExpr {
	match type m {
	| &StructLitExpr:
		ret (&StructLitExpr)(m)
	| &AllocStructLitExpr:
		ret (&AllocStructLitExpr)(m).Lit
	| &StructSubIdentExpr:
		mut ssi := (&StructSubIdentExpr)(m)
		ret isLitBased(ssi.Expr.Model)
	| &CastingExpr:
		mut c := (&CastingExpr)(m)
		ret isLitBased(c.Expr.Model)
	|:
		ret nil
	}
}

fn makeImplicitDeref(mut &d: &Data, mut baseToken: &token::Token) {
	mut unary := &UnaryExpr{
		Expr: new(Data, *d),
		Op: new(token::Token, *baseToken),
	}
	unary.Op.Id = token::Id.Star
	unary.Op.Kind = token::Kind.Star
	d.Model = unary
}

// Updates ref's old references to new.
fn updateRefer[T](mut ref: &ReferenceStack, &old: T, mut &new: T) {
	for i, sym in ref.buffer {
		if sym == old {
			ref.buffer[i] = new
		}
	}
}

fn makeVariadic(mut &d: &Data, mut elem: &Type) {
	d.Type = &Type{
		Variadic: true,
		Generic: elem.Generic,
		BindIdent: elem.BindIdent,
		Kind: elem.Kind,
	}
}

// Reports whether variable is captured from parent scope.
// Parameters:
//  - r: root scope of anonymous function
//  - s: current scope which is v accessed from
//  - v: variable to check
fn isVarCaptured(r: &scopeChecker, mut s: &scopeChecker, v: &Var): bool {
	if v.Scope == nil { // Global scope variable.
		ret false
	}
	for {
		if s.scope == v.Scope {
			ret false
		}
		// Break iteration if parent is not exist or scope already reached to root.
		if s.parent == nil || s == r {
			break
		}
		s = s.parent
	}
	ret true
}

fn findNamespace(mut lookup: Lookup, namespace: str): &ImportInfo {
	ret lookup.SelectPackage(fn(imp: &ImportInfo): bool {
		ret imp.Alias == namespace && !isImplicitImport(imp)
	})
}