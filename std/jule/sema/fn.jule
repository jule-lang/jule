// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::jule::ast::{Directive, GenericDecl, ScopeTree}
use std::jule::build::{EntryPoint, InitFn}
use std::jule::lex::{Token, IsAnonIdent}

// Return type.
pub struct RetType {
    pub Kind:   &TypeSymbol
    pub Idents: []&Token
}

// Parameter.
pub struct Param {
    pub Token:     &Token
    pub Mutable:   bool
    pub Variadic:  bool
    pub Reference: bool
    pub Kind:      &TypeSymbol
    pub Ident:     str
}

impl Param {
    fn instance(mut &self): &ParamIns {
        ret &ParamIns{
            Decl: self,
        }
    }

    // Reports whether parameter is self (receiver) parameter.
    pub fn IsSelf(self): bool {
        ret self.Ident == "&self" || self.Ident == "self"
    }

    // Reports whether self (receiver) parameter is reference.
    pub fn IsRef(self): bool {
        ret self.Ident != "" && self.Ident[0] == '&'
    }
}

// Function.
pub struct Fn {
    sema: &Sema

    pub Token:       &Token
    pub Global:      bool
    pub Unsafety:    bool
    pub Public:      bool
    pub CppLinked:   bool
    pub Statically:  bool
    pub Exceptional: bool
    pub Ident:       str
    pub Directives:  []&Directive
    pub Scope:       &ScopeTree
    pub Generics:    []&GenericDecl
    pub Result:      &RetType
    pub Params:      []&Param
    pub Owner:       &Struct

    // Function instances for each unique type combination of function call.
    // Nil if function is never used.
    pub Instances: []&FnIns
}

impl Fn {
    // Reports whether return type is void.
    pub fn IsVoid(self): bool {
        ret self.Result == nil
    }

    // Reports whether function is method.
    pub fn IsMethod(self): bool {
        ret self.Owner != nil
    }

    // Reports whether function is entry point.
    pub fn IsEntryPoint(self): bool {
        ret self.Ident == EntryPoint
    }

    // Reports whether function is initializer function.
    pub fn IsInit(self): bool {
        ret self.Ident == InitFn
    }

    // Reports whether function is anonymous function.
    pub fn IsAnon(self): bool {
        ret IsAnonIdent(self.Ident)
    }

    // Reports whether function has return variable(s).
    pub fn AnyVar(self): bool {
        ret self.Result != nil && self.Result.Idents.len > 0
    }

    // Force to new instance.
    fn instanceForce(mut &self): &FnIns {
        let mut ins = &FnIns{
            Decl: self,
            Scope: new(Scope),
            Refers: ReferenceStack.new(),
        }

        ins.Params = make([]&ParamIns, 0, self.Params.len)
        for (_, mut p) in self.Params {
            ins.Params = append(ins.Params, p.instance())
        }

        if ins.Decl.Result != nil {
            ins.Result = ins.Decl.Result.Kind.Kind
        }

        ret ins
    }

    fn instance(mut &self): &FnIns {
        // Returns already created instance for just one unique combination.
        if self.Generics.len == 0 && self.Instances.len == 1 {
            ret self.Instances[0]
        }
        ret self.instanceForce()
    }

    // Appends function instance.
    // Returns instance if already instance is already exist, nil if not.
    fn appendInstance(mut self, mut &ins: &FnIns): &FnIns {
        if self.Generics.len == 0 {
            // Skip already created instance for just one unique combination.
            if self.Instances.len == 1 {
                ret self.Instances[0]
            }

            self.Instances = append(self.Instances, ins)
            ret nil
        }

        if self.Instances.len == 0 {
            self.Instances = append(self.Instances, ins)
            ret nil
        }

        for (_, mut ains) in self.Instances {
            if ains.Same(ins) {
                // Instances are same.
                ret ains
            }
        }

        self.Instances = append(self.Instances, ins)
        ret nil
    }
}

// Parameter instance.
pub struct ParamIns {
    pub Decl: &Param
    pub Kind: &TypeKind
}

impl ParamIns {
    // Implement: Kind
    // Returns ParamIns's type kind as string.
    fn Str(self): str {
        let mut s = ""
        if self.Decl.Mutable {
            s += "mut "
        }

        if self.Decl.Reference {
            s += "&_:"
        }

        if self.Decl.IsSelf() {
            if self.Decl.IsRef() {
                s += "&"
            }
            s += "self"
            ret s
        }

        if self.Decl.Variadic {
            s += "..."
        }
        if self.Kind != nil {
            s += self.Kind.Str()
        }
        ret s
    }
}

// Function instance.
pub struct FnIns {
    pub Owner:    &StructIns
    pub Decl:     &Fn
    pub Generics: []&InsGeneric
    pub Params:   []&ParamIns
    pub Result:   &TypeKind
    pub Scope:    &Scope
    pub Refers:   &ReferenceStack
    pub Anon:     bool

    caller:   builtinCaller
    reloaded: bool
}

impl Kind for FnIns {
    // Implement: Kind
    // Returns Fn's type kind as string.
    pub fn Str(self): str {
        const Ident = false
        ret self.GetKindStr(Ident)
    }

    // Reports whether types are same.
    pub fn Equals(&self, other: &TypeKind): bool {
        let f = unsafe { (*(&other)).Fn() }
        if f == nil {
            ret false
        }
        ret self.EqualsFn(f)
    }
}

impl FnIns {
    // Reports whether functions are equals.
    pub fn EqualsFn(&self, &f: &FnIns): bool {
        if self.Decl.Exceptional != f.Decl.Exceptional {
            ret false
        }
        if self.Decl.Unsafety != f.Decl.Unsafety {
            ret false
        }
        if self.Decl.IsVoid() != f.Decl.IsVoid() {
            ret false
        }
        let checkParams = fn(p1: &ParamIns, p2: &ParamIns): bool {
            if p1.Decl.Mutable != p2.Decl.Mutable {
                ret false
            }

            if p1.Decl.IsSelf() {
                if !p2.Decl.IsSelf() {
                    ret false
                }

                if p1.Decl.IsRef() != p2.Decl.IsRef() {
                    ret false
                }

                ret true
            }

            if p1.Decl.Reference != p2.Decl.Reference {
                ret false
            }

            if p1.Decl.Variadic != p2.Decl.Variadic {
                ret false
            }

            ret p1.Kind.Equals(p2.Kind)
        }

        if f.Params.len != self.Params.len {
            ret false
        }

        let mut i = 0
        for i < self.Params.len; i++ {
            if !checkParams(self.Params[i], f.Params[i]) {
                ret false
            }
        }

        if !self.Decl.IsVoid() {
            if !self.Result.Equals(f.Result) {
                ret false
            }
        }

        ret true
    }

    // Reports whether functions are equals by trait implementation rules.
    fn equalsTrait(&self, &other: &FnIns): bool {
        if !self.EqualsFn(other) {
            ret false
        }
        if self.Decl.Generics.len != other.Decl.Generics.len {
            ret false
        }
        ret true
    }

    // Returns all types of result.
    // Returns nil if result is nil.
    // Returns mutable slice if returns internal slice.
    pub fn Types(mut self): []&TypeKind {
        match {
        | self.Result == nil:
            ret nil
        | self.Result.Tup() == nil:
            ret [self.Result]
        |:
            ret self.Result.Tup().Types
        }
    }

    // Reports whether instance is built-in.
    pub fn IsBuiltin(self): bool {
        ret self.caller != nil
    }

    // Reports whether instance is anonymous function.
    pub fn IsAnon(self): bool {
        ret self.Anon ||
            self.Decl != nil && self.Decl.IsAnon()
    }

    // Reports whether instances are same.
    // Returns true if declarations and generics are same.
    pub fn Same(self, f: &FnIns): bool {
        if self.Decl != f.Decl || f.Generics.len != self.Generics.len {
            ret false
        }

        for i, g in self.Generics {
            if !g.Kind.Equals(f.Generics[i].Kind) {
                ret false
            }
        }
        ret true
    }

    // Returns kind string of function instance.
    // Appends identifier to kind of this instance.
    // Does not appends identifier of this instance to kind if self.Decl is nil reference.
    pub fn GetKindStr(self, ident: bool): str {
        let mut s = ""

        if self.Decl.Unsafety {
            s += "unsafe "
        }

        s += "fn"

        if ident && self.Decl != nil {
            s += " " + self.Decl.Ident
        }

        s += "("
        let n = self.Params.len
        if n > 0 {
            for _, p in self.Params {
                s += p.Str()
                s += ","
            }
            s = s[:s.len-1] // Remove comma.
        }
        s += ")"
        if self.Decl.Exceptional {
            s += "!"
        }
        if !self.Decl.IsVoid() {
            s += ":"
            s += self.Result.Str()
        }
        ret s
    }
}

fn parameterUsesGenerics(&p: &Param, &generics: []&GenericDecl): bool {
    if p.IsSelf() {
        ret false
    }
    ret kindUsesGenerics(p.Kind.Decl.Kind, generics)
}