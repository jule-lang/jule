// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use ast for std::jule::ast
use std::jule::build::{LogMsg}
use std::jule::constant::{Const}
use types for std::jule::types

// All comptime-structure methods starts with underscore (_).

trait comptimeRangeKind {
    fn ready(mut self, mut &keyA: &Var, mut &keyB: &Var)
    fn step(mut self, i: int, mut &keyA: &Var, mut &keyB: &Var)
    fn len(self): int
}

// Compile-time ranges.
struct comptimeRange {
    kind: comptimeRangeKind
}

impl Kind for comptimeRange {
    fn Str(self): str { ret "comptimeRange" }
    fn Equal(&self, other: &TypeKind): bool { ret false }
}

// Compile-time field for structure.
struct comptimeStructField {
    field: &FieldIns
}

impl Kind for comptimeStructField {
    fn Str(self): str { ret "comptimeField" }
    fn Equal(&self, other: &TypeKind): bool { ret false }
}

impl comptimeStructField {
    fn _Name(&self): &Data {
        let mut constant = Const.NewStr(self.field.Decl.Ident)
        ret &Data{
            Kind: &TypeKind{
                Kind: buildPrimType(PrimKind.Str),
            },
            Constant: constant,
            Model: constant,
        }
    }

    fn _Type(mut &self, mut &e: &Eval): &Data {
        ret buildComptimeTypeInfoData(e.s, self.field.Kind)
    }

    fn _Public(mut &self): &Data {
        let mut constant = Const.NewBool(self.field.Decl.Public)
        ret &Data{
            Kind: &TypeKind{
                Kind: buildPrimType(PrimKind.Bool),
            },
            Constant: constant,
            Model: constant,
        }
    }

    fn subIdent(mut &self, ident: str): &Data {
        match ident {
        | "Name":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Name()
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Public":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Public()
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Type":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Type(e)
                },
            }
            ret buildAsComptimeMethodData(method)
        |:
            ret nil
        }
    }
}

// Compile-time fields range for structure.
struct comptimeStructFields {
    fields: []&FieldIns
}

impl Kind for comptimeStructFields {
    fn Str(self): str { ret "comptimeStructFields" }
    fn Equal(&self, other: &TypeKind): bool { ret false }
}

impl comptimeRangeKind for comptimeStructFields {
    fn ready(mut self, mut &keyA: &Var, mut &keyB: &Var) {
        if keyA != nil {
            keyA.Constant = true
            keyA.Value = &Value{
                Data: new(Data),
            }
            keyA.Value.Data.Constant = nil
            keyA.Kind = &TypeSymbol{
                Kind: &TypeKind{
                    Kind: buildPrimType(PrimKind.Int),
                },
            }
        }
        if keyB != nil {
            keyB.Constant = true
            keyB.Value = &Value{
                Data: new(Data),
            }
            keyB.Kind = &TypeSymbol{
                Kind: &TypeKind{
                    Kind: new(comptimeStructField),
                },
            }
        }
    }

    fn step(mut self, i: int, mut &keyA: &Var, mut &keyB: &Var) {
        if keyA != nil {
            // Kind should be assigned by caller.
            keyA.Value.Data.Constant = Const.NewI64(i64(i))
            keyA.Value.Data.Model = keyA.Value.Data.Constant
        }
        if keyB != nil {
            // Kind should be assigned by caller.
            keyB.Kind.Kind.comptimeStructField().field = self.fields[i]
        }
    }

    fn len(self): int {
        ret len(self.fields)
    }
}

// Compile-time type information data.
struct comptimeType {
    base: &TypeKind
}

impl Kind for comptimeType {
    fn Str(self): str { ret "comptimeTypeInfo" }
    fn Equal(&self, other: &TypeKind): bool { ret false }
}

impl comptimeType {
    fn _Str(&self): &Data {
        let mut constant = Const.NewStr(self.base.Str())
        ret &Data{
            Kind: &TypeKind{
                Kind: buildPrimType(PrimKind.Str),
            },
            Constant: constant,
            Model: constant,
        }
    }

    fn _Kind(mut &self, mut &e: &Eval): &Data {
        let mut enm = findComptimePackage(e.s).FindEnum("Kind")
        let mut item: &EnumItem = nil
        match {
        | self.base.Void():
            item = enm.FindItem("Void")
        | self.base.Struct() != nil:
            item = enm.FindItem("Struct")
        | self.base.Trait() != nil:
            item = enm.FindItem("Trait")
        | self.base.Ptr() != nil:
            if self.base.Ptr().IsUnsafe() {
                item = enm.FindItem("UnsafePtr")
            } else {
                item = enm.FindItem("Ptr")
            }
        | self.base.Sptr() != nil:
            item = enm.FindItem("Ref")
        | self.base.Enum() != nil:
            item = enm.FindItem("Enum")
        | self.base.Map() != nil:
            item = enm.FindItem("Map")
        | self.base.Slc() != nil:
            item = enm.FindItem("Slice")
        | self.base.Arr() != nil:
            item = enm.FindItem("Array")
        | self.base.Fn() != nil:
            item = enm.FindItem("Func")
        | self.base.Prim() != nil:
            let prim = self.base.Prim()
            match {
            | prim.IsAny():
                item = enm.FindItem("Any")
            | prim.IsBool():
                item = enm.FindItem("Bool")
            | prim.IsStr():
                item = enm.FindItem("Str")
            | prim.IsF32():
                item = enm.FindItem("F32")
            | prim.IsF64():
                item = enm.FindItem("F64")
            | prim.IsI8():
                item = enm.FindItem("I8")
            | prim.IsI16():
                item = enm.FindItem("I16")
            | prim.IsI32():
                item = enm.FindItem("I32")
            | prim.IsI64():
                item = enm.FindItem("I64")
            | prim.IsU8():
                item = enm.FindItem("U8")
            | prim.IsU16():
                item = enm.FindItem("U16")
            | prim.IsU32():
                item = enm.FindItem("U32")
            | prim.IsU64():
                item = enm.FindItem("U64")
            | prim.IsInt():
                item = enm.FindItem("Int")
            | prim.IsUint():
                item = enm.FindItem("Uint")
            | prim.IsUintptr():
                item = enm.FindItem("Uintptr")
            |:
                panic("Kind(): unimplemented type for std::comptime: " + self.base.Str())
            }
        |:
            panic("Kind(): unimplemented type for std::comptime: " + self.base.Str())
        }
        ret evalEnumStatic(enm, item)
    }

    fn _Bits(mut &self, mut &e: &Eval, mut &fc: &ast::FnCallExpr): &Data {
        let prim = self.base.Prim()
        if prim == nil {
            e.pushErr(fc.Token, LogMsg.InvalidTypeForFn, self.base.Str(), "Bits")
            ret nil
        }
        let n = types::BitsizeOf(prim.Kind)
        if n == -1 {
            e.pushErr(fc.Token, LogMsg.InvalidTypeForFn, self.base.Str(), "Bits")
            ret nil
        }
        let mut constant = Const.NewI64(i64(n))
        ret &Data{
            Kind: &TypeKind{
                Kind: buildPrimType(PrimKind.Int),
            },
            Constant: constant,
            Model: constant,
        }
    }

    fn _Elem(mut &self, mut &e: &Eval, mut &fc: &ast::FnCallExpr): &Data {
        let mut ptr = self.base.Ptr()
        if ptr != nil {
            if ptr.IsUnsafe() {
                e.pushErr(fc.Token, LogMsg.InvalidTypeForFn, self.base.Str(), "Elem")
                ret nil
            }
            ret buildComptimeTypeInfoData(e.s, ptr.Elem)
        }
        let mut sptr = self.base.Sptr()
        if sptr != nil {
            ret buildComptimeTypeInfoData(e.s, sptr.Elem)
        }
        let mut slice = self.base.Slc()
        if slice != nil {
            ret buildComptimeTypeInfoData(e.s, slice.Elem)
        }
        let mut array = self.base.Arr()
        if array != nil {
            ret buildComptimeTypeInfoData(e.s, array.Elem)
        }
        e.pushErr(fc.Token, LogMsg.InvalidTypeForFn, self.base.Str(), "Elem")
        ret nil
    }

    fn _Size(mut &self, mut &e: &Eval, mut &fc: &ast::FnCallExpr): &Data {
        let mut arr = self.base.Arr()
        if arr == nil {
            e.pushErr(fc.Token, LogMsg.InvalidTypeForFn, self.base.Str(), "Size")
            ret nil
        }
        let mut constant = Const.NewI64(i64(arr.N))
        ret &Data{
            Kind: &TypeKind{
                Kind: buildPrimType(PrimKind.Int),
            },
            Constant: constant,
            Model: constant,
        }
    }

    fn _Key(mut &self, mut &e: &Eval, mut &fc: &ast::FnCallExpr): &Data {
        let mut m = self.base.Map()
        if m == nil {
            e.pushErr(fc.Token, LogMsg.InvalidTypeForFn, self.base.Str(), "Key")
            ret nil
        }
        ret buildComptimeTypeInfoData(e.s, m.Key)
    }

    fn _Value(mut &self, mut &e: &Eval, mut &fc: &ast::FnCallExpr): &Data {
        let mut m = self.base.Map()
        if m == nil {
            e.pushErr(fc.Token, LogMsg.InvalidTypeForFn, self.base.Str(), "Value")
            ret nil
        }
        ret buildComptimeTypeInfoData(e.s, m.Val)
    }

    fn _Fields(mut &self, mut &e: &Eval, mut &fc: &ast::FnCallExpr): &Data {
        let mut s = self.base.Struct()
        if s == nil {
            e.pushErr(fc.Token, LogMsg.InvalidTypeForFn, self.base.Str(), "Fields")
            ret nil
        }
        ret &Data{
            Kind: &TypeKind{
                Kind: &comptimeStructFields{
                    fields: s.Fields,
                }
            },
        }
    }

    fn _Public(mut &self, mut &e: &Eval, mut &fc: &ast::FnCallExpr): &Data {
        let mut public = false
        match {
        | self.base.Struct() != nil:
            public = self.base.Struct().Decl.Public
        | self.base.Trait() != nil:
            public = self.base.Trait().Public
        | self.base.Enum() != nil:
            public = self.base.Enum().Public
        | self.base.TypeEnum() != nil:
            public = self.base.TypeEnum().Public
        |:
            e.pushErr(fc.Token, LogMsg.InvalidTypeForFn, self.base.Str(), "Public")
            ret nil
        }
        let mut constant = Const.NewBool(public)
        ret &Data{
            Kind: &TypeKind{
                Kind: buildPrimType(PrimKind.Bool),
            },
            Constant: constant,
            Model: constant,
        }
    }

    fn _Binded(mut &self, mut &e: &Eval, mut &fc: &ast::FnCallExpr): &Data {
        let mut binded = false
        match {
        | self.base.Struct() != nil:
            binded = self.base.Struct().Decl.CppLinked
        |:
            e.pushErr(fc.Token, LogMsg.InvalidTypeForFn, self.base.Str(), "Public")
            ret nil
        }
        let mut constant = Const.NewBool(binded)
        ret &Data{
            Kind: &TypeKind{
                Kind: buildPrimType(PrimKind.Bool),
            },
            Constant: constant,
            Model: constant,
        }
    }

    fn _Ordered(&self): &Data {
        let mut constant = Const.NewBool(self.base.Ordered())
        ret &Data{
            Kind: &TypeKind{
                Kind: buildPrimType(PrimKind.Str),
            },
            Constant: constant,
            Model: constant,
        }
    }

    fn subIdent(mut &self, ident: str): &Data {
        match ident {
        | "Str":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Str()
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Bits":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Bits(e, fc)
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Elem":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Elem(e, fc)
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Size":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Size(e, fc)
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Key":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Key(e, fc)
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Value":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Value(e, fc)
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Fields":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Fields(e, fc)
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Public":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Public(e, fc)
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Binded":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Binded(e, fc)
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Ordered":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Ordered()
                },
            }
            ret buildAsComptimeMethodData(method)
        | "Kind":
            let mut method = &FnIns{
                caller: fn(mut &e: &Eval, mut &fc: &ast::FnCallExpr, mut &_: &Data): &Data {
                    ret self._Kind(e)
                },
            }
            ret buildAsComptimeMethodData(method)
        |:
            ret nil
        }
    }
}

fn buildAsComptimeMethodData(mut &f: &FnIns): &Data {
    ret &Data{
        Kind: &TypeKind{
            Kind: f,
        },
    }
}

fn findComptimePackage(mut &s: &Sema): &ImportInfo {
    ret s.SelectPackage(fn(pkg: &ImportInfo): bool {
        ret pkg.LinkPath == "std::comptime"
    })
}

fn buildComptimeTypeInfoData(mut &s: &Sema, mut &t: &TypeKind): &Data {
    ret &Data{
        Kind: &TypeKind{
            Kind: s.meta.pushComptimeType(t)
        },
    }
}