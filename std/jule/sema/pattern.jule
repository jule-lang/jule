// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Pattern checker for functions and methods.
pub struct FuncPattern {}

impl FuncPattern {
    // Reports whether function is the reserved dispose function.
    pub static fn Dispose(f: &Fn): bool {
        ret f != nil &&
            f.Owner != nil &&
            f.Ident == "dispose" &&
            !f.Statically &&
            !f.Unsafety &&
            f.Public &&
            f.IsVoid() &&
            f.Generics.len == 0 &&
            f.Params.len == 1 &&
            f.Params[0].Mutable &&
            !f.Params[0].IsRef()
    }

    // Reports whether function is the reserved to_str function.
    pub static fn Str(f: &Fn): bool {
        if f == nil ||
            f.Owner == nil ||
            f.Ident != "to_str" ||
            f.Statically ||
            f.Unsafety ||
            !f.Public ||
            f.IsVoid() ||
            f.Generics.len != 0 ||
            f.Params.len != 1 ||
            f.Params[0].Mutable ||
            f.Params[0].IsRef() {
            ret false
        }

        let mut ins = unsafe { *(&f.Instances[0]) }
        let prim = ins.Result.Prim()
        if prim == nil {
            ret false
        }
        ret prim.IsStr()
    }

    static fn logical(&f: &Fn, ident: str): bool {
        if f == nil ||
            f.Ident != ident ||
            f.Owner == nil ||
            f.Instances.len == 0 ||
            f.Statically ||
            f.Unsafety ||
            !f.Public ||
            f.IsVoid() ||
            f.Generics.len != 0 ||
            f.Params.len != 2 ||
            f.Params[0].Mutable ||
            f.Params[0].IsRef() ||
            f.Params[1].Mutable ||
            f.Params[1].Reference {
            ret false
        }

        let mut ins = unsafe { *(&f.Instances[0]) }
        let prim = ins.Result.Prim()
        if prim == nil || !prim.IsBool() {
            ret false
        }
        ret ins.Owner == ins.Params[1].Kind.Struct()
    }

    // Reports whether function is the reserved eq function.
    pub static fn Eq(f: &Fn): bool {
        ret FuncPattern.logical(f, "eq")
    }

    // Reports whether function is the reserved gt function.
    pub static fn Gt(f: &Fn): bool {
        ret FuncPattern.logical(f, "gt")
    }

    // Reports whether function is the reserved gt_eq function.
    pub static fn GtEq(f: &Fn): bool {
        ret FuncPattern.logical(f, "gt_eq")
    }

    // Reports whether function is the reserved lt function.
    pub static fn Lt(f: &Fn): bool {
        ret FuncPattern.logical(f, "lt")
    }

    // Reports whether function is the reserved lt_eq function.
    pub static fn LtEq(f: &Fn): bool {
        ret FuncPattern.logical(f, "lt_eq")
    }

    static fn result(&f: &Fn, ident: str): bool {
        if f == nil ||
            f.Ident != ident ||
            f.Owner == nil ||
            f.Instances.len == 0 ||
            f.Statically ||
            f.Unsafety ||
            !f.Public ||
            f.IsVoid() ||
            f.Generics.len != 0 ||
            f.Params.len != 2 ||
            f.Params[0].Mutable ||
            f.Params[0].IsRef() ||
            f.Params[1].Mutable ||
            f.Params[1].Reference {
            ret false
        }

        let mut ins = unsafe { *(&f.Instances[0]) }
        ret ins.Result.Struct() == ins.Owner
    }

    // Reports whether function is the reserved shl function.
    pub static fn Shl(f: &Fn): bool {
        ret FuncPattern.result(f, "shl")
    }

    // Reports whether function is the reserved shr function.
    pub static fn Shr(f: &Fn): bool {
        ret FuncPattern.result(f, "shr")
    }

    // Reports whether function is the reserved add function.
    pub static fn Add(f: &Fn): bool {
        ret FuncPattern.result(f, "add")
    }

    // Reports whether function is the reserved sub function.
    pub static fn Sub(f: &Fn): bool {
        ret FuncPattern.result(f, "sub")
    }

    // Reports whether function is the reserved div function.
    pub static fn Div(f: &Fn): bool {
        ret FuncPattern.result(f, "div")
    }

    // Reports whether function is the reserved mul function.
    pub static fn Mul(f: &Fn): bool {
        ret FuncPattern.result(f, "mul")
    }

    // Reports whether function is the reserved mod function.
    pub static fn Mod(f: &Fn): bool {
        ret FuncPattern.result(f, "mod")
    }

    // Reports whether function is the reserved bit_and function.
    pub static fn BitAnd(f: &Fn): bool {
        ret FuncPattern.result(f, "bit_and")
    }

    // Reports whether function is the reserved bit_or function.
    pub static fn BitOr(f: &Fn): bool {
        ret FuncPattern.result(f, "bit_or")
    }

    // Reports whether function is the reserved bit_xor function.
    pub static fn BitXor(f: &Fn): bool {
        ret FuncPattern.result(f, "bit_xor")
    }

    static fn unary(&f: &Fn, ident: str): bool {
        if f == nil ||
            f.Ident != ident ||
            f.Owner == nil ||
            f.Instances.len == 0 ||
            f.Statically ||
            f.Unsafety ||
            !f.Public ||
            f.IsVoid() ||
            f.Generics.len != 0 ||
            f.Params.len != 1 ||
            f.Params[0].Mutable ||
            f.Params[0].IsRef() {
            ret false
        }

        let mut ins = unsafe { *(&f.Instances[0]) }
        ret ins.Result.Struct() == ins.Owner
    }

    // Reports whether function is the reserved neg function.
    pub static fn Neg(f: &Fn): bool {
        ret FuncPattern.unary(f, "neg")
    }

    // Reports whether function is the reserved pos function.
    pub static fn Pos(f: &Fn): bool {
        ret FuncPattern.unary(f, "pos")
    }

    // Reports whether function is the reserved bit_not function.
    pub static fn BitNot(f: &Fn): bool {
        ret FuncPattern.unary(f, "bit_not")
    }

    static fn assign(&f: &Fn, ident: str): bool {
        if f == nil ||
            f.Ident != ident ||
            f.Owner == nil ||
            f.Instances.len == 0 ||
            f.Statically ||
            f.Unsafety ||
            !f.Public ||
            !f.IsVoid() ||
            f.Generics.len != 0 ||
            f.Params.len != 2 ||
            !f.Params[0].Mutable ||
            f.Params[0].IsRef() ||
            f.Params[1].Mutable ||
            f.Params[1].Reference {
            ret false
        }
        ret true
    }

    // Reports whether function is the reserved add_assign function.
    pub static fn AddAssign(f: &Fn): bool {
        ret FuncPattern.assign(f, "add_assign")
    }

    // Reports whether function is the reserved sub_assign function.
    pub static fn SubAssign(f: &Fn): bool {
        ret FuncPattern.assign(f, "sub_assign")
    }

    // Reports whether function is the reserved div_assign function.
    pub static fn DivAssign(f: &Fn): bool {
        ret FuncPattern.assign(f, "div_assign")
    }

    // Reports whether function is the reserved mul_assign function.
    pub static fn MulAssign(f: &Fn): bool {
        ret FuncPattern.assign(f, "mul_assign")
    }

    // Reports whether function is the reserved mod_assign function.
    pub static fn ModAssign(f: &Fn): bool {
        ret FuncPattern.assign(f, "mod_assign")
    }

    // Reports whether function is the reserved shl_assign function.
    pub static fn ShlAssign(f: &Fn): bool {
        ret FuncPattern.assign(f, "shl_assign")
    }

    // Reports whether function is the reserved shr_assign function.
    pub static fn ShrAssign(f: &Fn): bool {
        ret FuncPattern.assign(f, "shr_assign")
    }

    // Reports whether function is the reserved bit_or_assign function.
    pub static fn BitOrAssign(f: &Fn): bool {
        ret FuncPattern.assign(f, "bit_or_assign")
    }

    // Reports whether function is the reserved bit_and_assign function.
    pub static fn BitAndAssign(f: &Fn): bool {
        ret FuncPattern.assign(f, "bit_and_assign")
    }

    // Reports whether function is the reserved bit_xor_assign function.
    pub static fn BitXorAssign(f: &Fn): bool {
        ret FuncPattern.assign(f, "bit_xor_assign")
    }
}