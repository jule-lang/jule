// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::jule::ast::{GenericDecl, Directive, Expr}
use std::jule::build
use std::jule::lex::{Token}

// Field.
pub struct Field {
    pub Owner:   &Struct
    pub Token:   &Token
    pub Public:  bool
    pub Mutable: bool        // Interior mutability.
    pub Ident:   str
    pub Kind:    &TypeSymbol
    pub Default: &Expr       // Nil if not given.
}

impl Field {
    fn instance(mut &self): &FieldIns {
        ret &FieldIns{
            Decl: self,
        }
    }
}

// Overloaded operators for instance.
// Patterns are checked.
pub struct Operators {
    pub Eq:           &FnIns
    pub Gt:           &FnIns
    pub GtEq:         &FnIns
    pub Lt:           &FnIns
    pub LtEq:         &FnIns
    pub Shl:          &FnIns
    pub Shr:          &FnIns
    pub Add:          &FnIns
    pub Sub:          &FnIns
    pub Div:          &FnIns
    pub Mul:          &FnIns
    pub Mod:          &FnIns
    pub BitAnd:       &FnIns
    pub BitOr:        &FnIns
    pub BitXor:       &FnIns
    pub Neg:          &FnIns
    pub Pos:          &FnIns
    pub BitNot:       &FnIns
    pub AddAssign:    &FnIns
    pub SubAssign:    &FnIns
    pub DivAssign:    &FnIns
    pub MulAssign:    &FnIns
    pub ModAssign:    &FnIns
    pub ShlAssign:    &FnIns
    pub ShrAssign:    &FnIns
    pub BitOrAssign:  &FnIns
    pub BitAndAssign: &FnIns
    pub BitXorAssign: &FnIns
}

// Structure.
pub struct Struct {
    // Used for type parsing.
    // Used declaration'sema sema for instance type checking.
    sema: &Sema

    // This structure depended to these structures, except cpp-linked ones.
    // Only stores plain identifier references such as A, B, and MyStruct.
    // Not includes non-pain identifier references such as *A, &B, and []MyStruct.
    pub Depends: []&Struct

    // This structures uses these structures.
    // Stores all referred structures.
    pub Uses: []&Struct

    pub Token:      &Token
    pub Ident:      str
    pub Fields:     []&Field
    pub Methods:    []&Fn
    pub Statics:    []&Var
    pub Public:     bool
    pub CppLinked:  bool
    pub Directives: []&Directive
    pub Generics:   []&GenericDecl
    pub Implements: []&Trait

    // Structure instances for each unique type combination of structure.
    // Nil if structure is never used.
    pub Instances: []&StructIns
}

impl Struct {
    fn instance(mut &self): &StructIns {
        // Returns already created instance for just one unique combination.
        if self.Generics.len == 0 && self.Instances.len == 1 {
            ret self.Instances[0]
        }

        let mut ins = &StructIns{
            Decl: self,
            Fields: make([]&FieldIns, 0, self.Fields.len),
            Refers: ReferenceStack.new(),
        }

        for (_, mut f) in self.Fields {
            ins.Fields = append(ins.Fields, f.instance())
            if !f.Mutable && f.Kind.Kind != nil && f.Kind.Kind.Mutable() {
                ins.Mutable = true
            }
        }

        if self.Generics.len == 0 {
            ins.Methods = self.Methods
        } else {
            ins.Methods = make([]&Fn, 0, self.Methods.len)
            for (_, mut f) in self.Methods {
                let mut fins = new(Fn, *f)
                fins.Instances = nil
                ins.Methods = append(ins.Methods, fins)
            }
        }

        ret ins
    }

    // Appends instance if unique.
    // Returns already exist instance if given insance is not unique.
    fn appendInstance(mut self, mut &ins: &StructIns): &StructIns {
        // Skip already created instance for just one unique combination.
        if self.Generics.len == 0 && self.Instances.len == 1 {
            ret self.Instances[0]
        }

        for (_, mut ains) in self.Instances {
            if ains.Same(ins) {
                ret ains
            }
        }

        self.Instances = append(self.Instances, ins)
        ret nil
    }

    // Returns method by identifier.
    // Returns nil reference if not exist any method in this identifier.
    pub fn FindMethod(mut self, ident: str, statically: bool): &Fn {
        for (_, mut f) in self.Methods {
            if f.Statically == statically && f.Ident == ident {
                ret f
            }
        }
        ret nil
    }

    // Returns static field by identifier.
    // Returns nil reference if not exist any static field in this identifier.
    pub fn FindStatic(mut self, ident: str): &Var {
        for (_, mut v) in self.Statics {
            if v.Ident == ident {
                ret v
            }
        }
        ret nil
    }

    // Returns field by identifier.
    // Returns nil reference if not exist any field in this identifier.
    pub fn FindField(mut self, ident: str): &Field {
        for (_, mut f) in self.Fields {
            if f.Ident == ident {
                ret f
            }
        }
        ret nil
    }

    // Reports whether structure implements given trait.
    pub fn IsImplements(self, t: &Trait): bool {
        for _, it in self.Implements {
            if t == it {
                ret true
            }
        }
        ret false
    }

    // Reports whether structure is derives given derive.
    pub fn IsDerives(self, ident: str): bool {
        for _, d in self.Directives {
            if d.Tag.Kind == std::jule::build::Directive.Derive {
                if d.Args.len == 1 && d.Args[0].Kind == ident {
                    ret true
                }
            }
        }
        ret false
    }

    // Reports whether structure is uses given structure.
    pub fn IsUses(self, s: &Struct): bool {
        for _, u in self.Uses {
            for s == u {
                ret true
            }
        }
        ret false
    }

    // Reports whether structure has only reference-type-accessible defines.
    pub fn HasRefAccessible(self): bool {
        for _, m in self.Methods {
            if m.Params.len > 0 && m.Params[0].IsRef() {
                ret true
            }
        }
        ret false
    }
}

// Field instance.
pub struct FieldIns {
    pub Decl:    &Field
    pub Kind:    &TypeKind
    pub Default: &Data     // Nil if not given.
}

// Structure instance.
pub struct StructIns {
    pub Checked:   bool
    pub Decl:      &Struct
    pub Generics:  []&InsGeneric
    pub Fields:    []&FieldIns
    pub Methods:   []&Fn
    pub Mutable:   bool            // This structure has mutable defines.
    pub Refers:    &ReferenceStack
    pub Operators: Operators
}

impl Kind for StructIns {
    // Implement: Kind
    // Returns Struct's type kind as string.
    pub fn Str(self): str {
        let mut kind = ""
        kind += self.Decl.Ident
        if self.Generics.len > 0 {
            kind += "["
            for _, g in self.Generics {
                kind += g.Kind.Str()
                kind += ","
            }
            kind = kind[:kind.len-1] // Remove comma.
            kind += "]"
        }
        ret kind
    }

    // Reports whether types are same.
    pub fn Equals(&self, other: &TypeKind): bool {
        let s = unsafe { (*(&other)).Struct() }
        if s == nil {
            ret false
        }

        if self.Decl != s.Decl {
            ret false
        }

        if self.Generics.len != s.Generics.len {
            ret false
        }

        let mut i = 0
        for i < self.Generics.len; i++ {
            if !self.Generics[i].Kind.Equals(s.Generics[i].Kind) {
                ret false
            }
        }

        ret true
    }
}

impl StructIns {
    // Reports whether instances are same.
    // Returns true if declarations and generics are same.
    pub fn Same(self, s: &StructIns): bool {
        if self.Decl != s.Decl || s.Generics.len != self.Generics.len {
            ret false
        }
        for i, g in self.Generics {
            if !g.Kind.Equals(s.Generics[i].Kind) {
                ret false
            }
        }
        ret true
    }

    // Returns method by identifier.
    // Returns nil reference if not exist any method in this identifier.
    pub fn FindMethod(mut self, ident: str, statically: bool): &Fn {
        for (_, mut f) in self.Methods {
            if f.Statically == statically && f.Ident == ident {
                ret f
            }
        }
        ret nil
    }

    // Returns field by identifier.
    // Returns nil reference if not exist any field in this identifier.
    pub fn FindField(mut self, ident: str): &FieldIns {
        for (_, mut f) in self.Fields {
            if f.Decl.Ident == ident {
                ret f
            }
        }
        ret nil
    }
}