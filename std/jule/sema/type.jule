// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// This file reserved for types, type kinds and type build algorithms.
// This file haven't type compatibility checking algorithm or something else.

use std::conv::{itoa}
use ast for std::jule::ast::{
    Ast,
    TypeDecl,
    GenericDecl,
    FnDecl,
    MapTypeDecl,
    PtrTypeDecl,
    SlcTypeDecl,
    ArrTypeDecl,
    ScopeTree,
    NamespaceTypeDecl,
    TypeDeclKind,
    TupleTypeDecl,
    SptrTypeDecl,
    IdentTypeDecl,
    SubIdentTypeDecl,
}
use std::jule::build::{Derive, LogMsg, logf}
use std::jule::lex::{Token, TokenKind}
use types for std::jule::types
use strings for std::strings

type PrimKind: types::TypeKind

// Generic type for instance types.
pub struct InsGeneric {
    pub kind:       &TypeKind
    pub constraint: []&TypeKind
}

// Type alias.
pub struct TypeAlias {
    pub scope:      &ScopeTree
    pub public:     bool
    pub cpp_linked: bool
    pub used:       bool
    pub generic:    bool
    pub token:      &Token
    pub ident:      str
    pub kind:       &TypeSymbol
    pub refers:     []any        // Referred identifiers, except cpp-linked ones.
    pub generics:   []&TypeAlias // See developer reference (1).
}

// Kind of type declaration.
pub trait Kind {
    pub fn to_str(self): str
    pub fn equals(&self, other: &TypeKind): bool
}

// Evaluated type declaration.
pub struct TypeKind {
    pub cpp_ident: str
    pub generic:   bool
    pub variadic:  bool
    pub kind:      Kind
}

impl Kind for TypeKind {
    // Returns kind as string.
    pub fn to_str(self): str {
        if self.is_nil() {
            ret "nil"
        }

        let mut kind = ""

        if self.variadic {
            kind += "..."
        }

        if self.cpp_linked() {
            kind += "cpp."
            kind += self.cpp_ident
        } else {
            kind += self.kind.to_str()
        }
        ret kind
    }

    // Reports whether types are same.
    pub fn equals(&self, other: &TypeKind): bool {
        if self.is_nil() {
            ret other.is_nil()
        }

        if self.cpp_linked() {
            ret other.cpp_linked() &&
                self.cpp_ident == other.cpp_ident
        }

        ret self.kind.equals(other)
    }
}

impl TypeKind {
    // Reports whether type is cpp-linked kind.
    pub fn cpp_linked(self): bool { ret self.cpp_ident.len != 0 }

    // Reports whether kind is "nil".
    pub fn is_nil(self): bool { ret self.kind == nil }

    // Reports whether kind is "void".
    pub fn void(self): bool {
        let prim = unsafe { (*(&self)).prim() }
        ret prim != nil && prim.kind == "void"
    }

    // Reports whether kind is mutable.
    pub fn mutable(self): bool {
        unsafe {
            let mut _self = &self

            if _self.strct() != nil {
                ret _self.strct().mutable
            }
            if _self.trt() != nil {
                ret _self.trt().mutable
            }
            if _self.prim() != nil {
                let p = _self.prim()
                ret p.is_any()
            }
            if _self.arr() != nil {
                ret _self.arr().elem.mutable()
            }
            ret _self.slc() != nil ||
                _self.ptr() != nil ||
                _self.sptr() != nil
        }
    }

    // Reports whether kind is nil compatible.
    pub fn nil_compatible(self): bool {
        unsafe {
            let mut _self = &self

            let prim = _self.prim()
            if prim != nil && prim.is_any() {
                ret true
            }

            ret _self.is_nil() ||
                _self.fnc() != nil ||
                _self.sptr() != nil ||
                _self.ptr() != nil ||
                _self.trt() != nil ||
                _self.slc() != nil ||
                _self.map() != nil ||
                _self.tenm() != nil
        }
    }

    // Reports whether kind performs reference-counting.
    pub fn performs_rc(self): bool {
        unsafe {
            let mut _self = &self
            ret _self.sptr() != nil || _self.slc() != nil || _self.trt() != nil
        }
    }

    // Reports whether kind supports clonning via jule::Clone derive.
    pub fn supports_cloning(self): bool {
        unsafe {
            let mut _self = &self
            match {
            | _self.prim() != nil:
                ret !_self.prim().is_any()
            | _self.enm() != nil:
                ret true
            | _self.fnc() != nil:
                ret true
            | _self.ptr() != nil:
                ret true
            | _self.slc() != nil:
                ret _self.slc().elem.supports_cloning()
            | _self.map() != nil:
                let m = _self.map()
                ret m.key.supports_cloning() && m.val.supports_cloning()
            | _self.arr() != nil:
                ret _self.arr().elem.supports_cloning()
            | _self.sptr() != nil:
                ret _self.sptr().elem.supports_cloning()
            | _self.strct() != nil:
                let mut s = _self.strct()
                ret s.decl != nil &&
                    !s.decl.cpp_linked &&
                    s.decl.is_derives(Derive.Clone)
            |:
                ret false
            }
        }
    }

    // Reports whether kind is variadicable.
    pub fn variadicable(self): bool {
        unsafe {
            let mut _self = &self
            ret _self.slc() != nil
        }
    }

    // Returns primitive type if kind is primitive type, nil reference if not.
    pub fn prim(mut self): &Prim {
        match type self.kind {
        | &Prim:
            ret (&Prim)(self.kind)
        |:
            ret nil
        }
    }

    // Returns reference type if kind is smart pointer, nil reference if not.
    pub fn sptr(mut self): &Sptr {
        match type self.kind {
        | &Sptr:
            ret (&Sptr)(self.kind)
        |:
            ret nil
        }
    }

    // Returns pointer type if kind is pointer, nil reference if not.
    pub fn ptr(mut self): &Ptr {
        match type self.kind {
        | &Ptr:
            ret (&Ptr)(self.kind)
        |:
            ret nil
        }
    }

    // Returns enum type if kind is enum, nil reference if not.
    pub fn enm(mut self): &Enum {
        match type self.kind {
        | &Enum:
            ret (&Enum)(self.kind)
        |:
            ret nil
        }
    }

    // Returns type enum if kind is type enum, nil reference if not.
    pub fn tenm(mut self): &TypeEnum {
        match type self.kind {
        | &TypeEnum:
            ret (&TypeEnum)(self.kind)
        |:
            ret nil
        }
    }

    // Returns array type if kind is array, nil reference if not.
    pub fn arr(mut self): &Arr {
        match type self.kind {
        | &Arr:
            ret (&Arr)(self.kind)
        |:
            ret nil
        }
    }

    // Returns slice type if kind is slice, nil reference if not.
    pub fn slc(mut self): &Slc {
        match type self.kind {
        | &Slc:
            ret (&Slc)(self.kind)
        |:
            ret nil
        }
    }

    // Returns fn type if kind is function, nil reference if not.
    pub fn fnc(mut self): &FnIns {
        match type self.kind {
        | &FnIns:
            ret (&FnIns)(self.kind)
        |:
            ret nil
        }
    }

    // Returns struct type if kind is structure, nil reference if not.
    pub fn strct(mut self): &StructIns {
        match type self.kind {
        | &StructIns:
            ret (&StructIns)(self.kind)
        |:
            ret nil
        }
    }

    // Returns trait type if kind is trait, nil reference if not.
    pub fn trt(mut self): &Trait {
        match type self.kind {
        | &Trait:
            ret (&Trait)(self.kind)
        |:
            ret nil
        }
    }

    // Returns map type if kind is map, nil reference if not.
    pub fn map(mut self): &Map {
        match type self.kind {
        | &Map:
            ret (&Map)(self.kind)
        |:
            ret nil
        }
    }

    // Returns tuple type if kind is tuple, nil reference if not.
    pub fn tup(mut self): &Tuple {
        match type self.kind {
        | &Tuple:
            ret (&Tuple)(self.kind)
        |:
            ret nil
        }
    }
}

// Type.
pub struct TypeSymbol {
    pub decl: &TypeDecl // Never changed by semantic analyzer.
    pub kind: &TypeKind
}

impl TypeSymbol {
    // Reports whether type is checked already.
    fn checked(self): bool { ret self.kind != nil }

    // Removes kind and ready to check.
    // checked() reports false after this function.
    fn remove_kind(mut self) { self.kind = nil }
}

// Primitive type.
pub struct Prim {
    pub kind: str
}

impl Kind for Prim {
    // Returns kind.
    pub fn to_str(self): str {
        ret self.kind
    }

    // Reports whether types are same.
    pub fn equals(&self, other: &TypeKind): bool {
        let prim = unsafe { (*(&other)).prim() }
        if prim == nil {
            ret false
        }
        ret self.kind == prim.kind
    }
}

impl Prim {
    // Reports whether type is built-in constraint.
    pub fn is_constraint(self): bool {
        ret !self.is_str() &&
            !self.is_any() &&
            !self.is_bool() &&
            !types::is_num(self.kind)
    }

    // Reports whether type is primitive i8.
    pub fn is_i8(self): bool { ret self.kind == PrimKind.I8 }

    // Reports whether type is primitive i16.
    pub fn is_i16(self): bool { ret self.kind == PrimKind.I16 }

    // Reports whether type is primitive i32.
    pub fn is_i32(self): bool { ret self.kind == PrimKind.I32 }

    // Reports whether type is primitive i64.
    pub fn is_i64(self): bool { ret self.kind == PrimKind.I64 }

    // Reports whether type is primitive u8.
    pub fn is_u8(self): bool { ret self.kind == PrimKind.U8 }

    // Reports whether type is primitive u16.
    pub fn is_u16(self): bool { ret self.kind == PrimKind.U16 }

    // Reports whether type is primitive u32.
    pub fn is_u32(self): bool { ret self.kind == PrimKind.U32 }

    // Reports whether type is primitive u64.
    pub fn is_u64(self): bool { ret self.kind == PrimKind.U64 }

    // Reports whether type is primitive f32.
    pub fn is_f32(self): bool { ret self.kind == PrimKind.F32 }

    // Reports whether type is primitive f64.
    pub fn is_f64(self): bool { ret self.kind == PrimKind.F64 }

    // Reports whether type is primitive int.
    pub fn is_int(self): bool { ret self.kind == PrimKind.Int }

    // Reports whether type is primitive uint.
    pub fn is_uint(self): bool { ret self.kind == PrimKind.Uint }

    // Reports whether type is primitive uintptr.
    pub fn is_uintptr(self): bool { ret self.kind == PrimKind.Uintptr }

    // Reports whether type is primitive bool.
    pub fn is_bool(self): bool { ret self.kind == PrimKind.Bool }

    // Reports whether type is primitive str.
    pub fn is_str(self): bool { ret self.kind == PrimKind.Str }

    // Reports whether type is primitive any.
    pub fn is_any(self): bool { ret self.kind == PrimKind.Any }
}

// Smart pointer.
pub struct Sptr {
    pub elem: &TypeKind
}

impl Kind for Sptr {
    // Returns smart pointer kind as string.
    pub fn to_str(self): str { ret "&" + self.elem.to_str() }

    // Reports whether types are same.
    pub fn equals(&self, other: &TypeKind): bool {
        let sptr = unsafe { (*(&other)).sptr() }
        if sptr == nil {
            ret false
        }
        ret self.elem.equals(sptr.elem)
    }
}

// Slice type.
pub struct Slc {
    pub elem: &TypeKind
}

impl Kind for Slc {
    // Returns slice kind as string.
    pub fn to_str(self): str { ret "[]" + self.elem.to_str() }

    // Reports whether types are same.
    pub fn equals(&self, other: &TypeKind): bool {
        let slc = unsafe { (*(&other)).slc() }
        if slc == nil {
            ret false
        }
        ret self.elem.equals(slc.elem)
    }
}

// Tuple type.
pub struct Tuple {
    pub types: []&TypeKind
}

impl Kind for Tuple {
    // Returns tuple kind as string.
    pub fn to_str(self): str {
        let mut s = "("
        s += self.types[0].to_str()
        for _, t in self.types[1:] {
            s += ","
            s += t.to_str()
        }
        s += ")"
        ret s
    }

    // Reports whether types are same.
    pub fn equals(&self, other: &TypeKind): bool {
        let tup = unsafe { (*(&other)).tup() }
        if tup == nil {
            ret false
        }

        if self.types.len != tup.types.len {
            ret false
        }

        let mut i = 0
        for i < self.types.len; i++ {
            if !self.types[i].equals(tup.types[i]) {
                ret false
            }
        }

        ret true
    }
}

// Map type.
pub struct Map {
    pub key: &TypeKind
    pub val: &TypeKind
}

impl Kind for Map {
    // Returns map kind as string.
    pub fn to_str(self): str {
        let mut s = "["
        s += self.key.to_str()
        s += ":"
        s += self.val.to_str()
        s += "]"
        ret s
    }

    // Reports whether types are same.
    pub fn equals(&self, other: &TypeKind): bool {
        let map = unsafe { (*(&other)).map() }
        if map == nil {
            ret false
        }
        ret self.key.equals(map.key) && self.val.equals(map.val)
    }
}

// Array type.
pub struct Arr {
    pub auto: bool      // Auto-sized array.
    pub n:    int
    pub elem: &TypeKind
}

impl Kind for Arr {
    // Returns array kind as string.
    pub fn to_str(self): str {
        let mut s = "["
        s += itoa(self.n)
        s += "]"
        s += self.elem.to_str()
        ret s
    }

    // Reports whether types are same.
    pub fn equals(&self, other: &TypeKind): bool {
        let arr = unsafe { (*(&other)).arr() }
        if arr == nil {
            ret false
        }
        ret self.n == arr.n && self.elem.equals(arr.elem)
    }
}

// Pointer type.
pub struct Ptr {
    pub elem: &TypeKind
}

impl Kind for Ptr {
    // Returns pointer kind as string.
    pub fn to_str(self): str {
        if self.is_unsafe() {
            ret "*unsafe"
        }
        ret "*" + self.elem.to_str()
    }

    // Reports whether types are same.
    pub fn equals(&self, other: &TypeKind): bool {
        let ptr = unsafe { (*(&other)).ptr() }
        if ptr == nil {
            ret false
        }
        ret self.elem.equals(ptr.elem)
    }
}

impl Ptr {
    // Reports whether pointer is unsafe pointer (*unsafe).
    pub fn is_unsafe(self): bool { ret self.elem == nil }
}

struct Referencer {
    ident: str
    owner: any
    refs:  *[]any
}

// Checks type and builds result as kind.
// Removes kind if error occurs,
// so type is not reports true for checked state.
struct TypeChecker {
    // Uses Sema for:
    //  - Push errors.
    s: &Sema

    // Uses Lookup for:
    //  - Lookup symbol tables.
    lookup: Lookup

    // If this is not nil, appends referred ident types.
    // Also used as checker owner.
    referencer: &Referencer

    // If this not nil, type dependencies will push into stack.
    refers: &ReferenceStack

    error_token: &Token

    // This identifiers ignored and
    // appends as primitive type.
    //
    // Each dimension 2 array accepted as identifier group.
    ignore_generics: []&GenericDecl

    // This generics used as type alias for real kind.
    use_generics: []&TypeAlias

    // Current checked type is not plain type.
    // Type is pointer, reference, slice or similar.
    not_plain: bool

    // Disallow/suppress Jule's built-in defines.
    dis_builtin: bool

    // Name selection is enabled.
    // No cpp-linked definitions, no generic type representation.
    // Only typename selection.
    //
    // If selection is a struct, returns invalid instance that only has decl field.
    selection: bool

    // See developer reference (4).
    owner_alias: &TypeAlias

    // This generics are banned because of causes instantiation cycles.
    // Usually stores structure generics and method generics.
    // See developer reference (5).
    banned_generics: []&TypeAlias

    // Enable/Disable status of instantiation catching.
    // See developer reference (6).
    inscatch: bool
}

impl TypeChecker {
    fn push_err(mut self, token: &Token, fmt: LogMsg, args: ...any) {
        self.s.push_err(token, fmt, args...)
    }

    fn allow_builtin(mut self) {
        self.dis_builtin = false
    }

    fn disallow_builtin(mut self) {
        self.dis_builtin = true
    }

    fn build_prim(mut self, &decl: &IdentTypeDecl): &Prim {
        if !is_prim(decl.ident) {
            self.push_err(self.error_token, LogMsg.InvalidType)
            ret nil
        }

        if decl.generics.len > 0 {
            self.push_err(decl.token, LogMsg.TypeNotSupportsGenerics, decl.ident)
            ret nil
        }

        ret build_prim_type(decl.ident)
    }

    fn push_reference[T](mut self, mut &t: T) {
        if self.refers == nil {
            ret
        }
        if self.refers.exist[T](t) {
            ret
        }
        self.refers.push(t)
    }

    fn push_reference_by_kind(mut self, mut &k: &TypeKind) {
        match {
        | k.strct() != nil:
            let mut t = k.strct()
            self.push_reference[&StructIns](t)
        | k.trt() != nil:
            let mut t = k.trt()
            self.push_reference[&Trait](t)
        }
    }

    fn push_cycle_error(self, def1: any, def2: any, mut &message: str) {
        const PADDING = 4

        let get_ident = fn(&def: any): str {
            match type def {
            | &TypeAlias:
                ret (&TypeAlias)(def).ident
            | &Struct:
                ret (&Struct)(def).ident
            |:
                ret ""
            }
        }

        let def1_ident = get_ident(def1)
        let def2_ident = get_ident(def2)
        let refers_to = logf(LogMsg.RefersTo, def1_ident, def2_ident)
        message = strings::repeat(" ", PADDING) + refers_to + "\n" + message
    }

    fn check_cross_cycle(self, decl: any, mut &message: str): bool {
        match type decl {
        | &TypeAlias:
            let ta = (&TypeAlias)(decl)
            for _, d in ta.refers {
                match {
                | self.referencer.owner == d:
                    self.push_cycle_error(ta, d, message)
                    ret false
                | !self.check_cross_cycle(d, message):
                    self.push_cycle_error(ta, d, message)
                    ret false
                }
            }
        | &Struct:
            let s = (&Struct)(decl)
            for _, d in s.depends {
                match {
                | self.referencer.owner == d:
                    self.push_cycle_error(s, d, message)
                    ret false
                | !self.check_cross_cycle(d, message):
                    self.push_cycle_error(s, d, message)
                    ret false
                }
            }
        }
        ret true
    }

    // Checks type alias illegal cycles.
    // Appends reference to reference if there is no illegal cycle.
    // Returns true if self.referencer is nil reference.
    // Returns true if refers is nil.
    fn check_illegal_cycles(mut self, &ident: &IdentTypeDecl, mut decl: any): (ok: bool) {
        if self.referencer == nil {
            ret true
        }

        match type decl {
        | &Struct:
            if self.not_plain || (&Struct)(decl).cpp_linked {
                ret true
            }
        | &TypeAlias:
            if (&TypeAlias)(decl).cpp_linked {
                ret true
            }
        }

        // Check illegal cycle for itself.
        // Because refers's owner is decl.
        if self.referencer.owner == decl {
            self.push_err(ident.token, LogMsg.IllegalCycleRefersItself, self.referencer.ident)
            ret false
        }

        let mut message = ""

        if !self.check_cross_cycle(decl, message) {
            let mut err_msg = message
            message = ""
            self.push_cycle_error(self.referencer.owner, decl, message)
            err_msg = err_msg + message
            self.push_err(ident.token, LogMsg.IllegalCrossCycle, err_msg)
            ret false
        }

        match type self.referencer.owner {
        | &TypeAlias:
            unsafe {
                *self.referencer.refs = append(*self.referencer.refs, decl)
            }
        | &Struct:
            match type decl {
            | &Struct:
                let mut s = (&Struct)(self.referencer.owner)
                s.depends = append(s.depends, (&Struct)(decl))
            }
        }

        ret true
    }

    fn from_type_alias(mut self, &decl: &IdentTypeDecl, mut &ta: &TypeAlias): Kind {
        if !self.s.is_accessible_define(ta.public, ta.token) {
            self.push_err(decl.token, LogMsg.IdentNotExist, decl.ident)
            ret nil
        }

        ta.used = true

        if decl.generics.len > 0 {
            self.push_err(decl.token, LogMsg.TypeNotSupportsGenerics, decl.ident)
            ret nil
        }

        // Enable instantiation cycle catching if type alias is
        // one of the banned generics.
        if !self.inscatch && self.banned_generics != nil {
            self.inscatch = true
            for _, bg in self.banned_generics {
                if bg == ta || ta.kind.kind != nil && ta.kind.kind.equals(bg.kind.kind) {
                    self.inscatch = false
                    break
                }
            }
        }

        // Catch instantiation cycles.
        // See developer reference (5).
        if self.inscatch {
            for _, bg in self.banned_generics {
                if bg == ta {
                    self.push_err(decl.token, LogMsg.InitiationCycle, decl.ident)
                    ret nil
                }
                for _, dg in ta.generics {
                    if bg == dg {
                        self.push_err(decl.token, LogMsg.InitiationCycle, decl.ident)
                        ret nil
                    }
                }
            }
        }

        let mut ok = self.check_illegal_cycles(decl, ta)
        if !ok {
            ret nil
        }

        // Build kind if not builded already.
        ok = self.s.check_type_alias_decl_kind(ta, self.lookup)
        if !ok {
            ret nil
        }

        // Push generic reference to owner type alias.
        // See developer reference (3) and (4) for more information.
        if ta.generic && self.owner_alias != nil {
            self.owner_alias.generics = append(self.owner_alias.generics, ta)
        }

        let mut tk = &TypeKind{
            generic: ta.generic,
            kind: ta.kind.kind.kind,
        }
        self.push_reference_by_kind(tk)
        if ta.cpp_linked {
            tk.cpp_ident = ta.ident
        } else {
            tk.cpp_ident = ta.kind.kind.cpp_ident
        }
        ret tk
    }

    fn from_enum(mut self, &decl: &IdentTypeDecl, mut &e: &Enum): &Enum {
        if !self.s.is_accessible_define(e.public, e.token) {
            self.push_err(decl.token, LogMsg.IdentNotExist, decl.ident)
            ret nil
        }
        if decl.generics.len > 0 {
            self.push_err(decl.token, LogMsg.TypeNotSupportsGenerics, decl.ident)
            ret nil
        }
        ret e
    }

    fn from_type_enum(mut self, &decl: &IdentTypeDecl, mut &e: &TypeEnum): &TypeEnum {
        if !self.s.is_accessible_define(e.public, e.token) {
            self.push_err(decl.token, LogMsg.IdentNotExist, decl.ident)
            ret nil
        }
        if decl.generics.len > 0 {
            self.push_err(decl.token, LogMsg.TypeNotSupportsGenerics, decl.ident)
            ret nil
        }
        ret e
    }

    fn from_trait(mut self, &decl: &IdentTypeDecl, mut &t: &Trait): &Trait {
        if !self.s.is_accessible_define(t.public, t.token) {
            self.push_err(decl.token, LogMsg.IdentNotExist, decl.ident)
            ret nil
        }
        if decl.generics.len > 0 {
            self.push_err(decl.token, LogMsg.TypeNotSupportsGenerics, decl.ident)
            ret nil
        }
        self.push_reference[&Trait](t)
        ret t
    }

    fn check_struct_ins(mut self, mut &ins: &StructIns, mut &error_token: &Token): (ok: bool) {
        if ins.checked {
            ret true
        }
        ins.checked = true

        // Break algorithm cycle.
        if self.referencer != nil && self.referencer.owner == ins.decl {
            ret true
        }

        if !self.s.precheck_struct_ins(ins, error_token) {
            ret false
        }
        if ins.generics.len > 0 {
            self.s.check_struct_ins_operators(ins)
            self.s.check_struct_ins(ins)
        }
        ret true
    }

    fn append_used_struct_reference(mut self, mut &s: &Struct) {
        if self.referencer == nil {
            ret
        }

        match type self.referencer.owner {
        | &Struct:
            let mut ref_s = (&Struct)(self.referencer.owner)
            if !ref_s.is_uses(s) {
                ref_s.uses = append(ref_s.uses, s)
            }
        }
    }

    fn build_struct_instance(mut self, mut &decl: &IdentTypeDecl, mut &s: &Struct): &StructIns {
        // Save configuration.
        let mut referencer = self.referencer
        self.referencer = nil
        let mut banned_generics = self.banned_generics

        // Set banned generics to catch initiation cycles.
        // This just necessary for root, therefore avoid set each time.
        if self.banned_generics == nil {
            match type self.lookup {
            | &ScopeChecker:
                let mut sc = (&ScopeChecker)(self.lookup)
                let mut hard = sc.get_hard_root()
                if hard.owner.owner == nil || hard.owner.owner.decl != s {
                    break
                }
                let n = hard.owner.generics.len + hard.owner.owner.generics.len
                // Add scope generics to to catch instantiation cycles.
                // See developer reference (5).
                self.banned_generics = hard.table.type_aliases[:n]
            }
        } else {
            self.inscatch = true
        }

        // Build generics.
        let mut ins = s.instance()
        ins.generics = make([]&InsGeneric, 0, decl.generics.len)
        for (_, mut g) in decl.generics {
            let mut kind = self.build(g.kind)
            if kind == nil {
                ret nil
            }
            ins.generics = append(ins.generics, &InsGeneric{kind: kind})
        }

        // Restore configuration.
        self.banned_generics = banned_generics
        self.referencer = referencer

        ret ins
    }

    fn from_struct(mut self, mut &decl: &IdentTypeDecl, mut &s: &Struct): &StructIns {
        if !self.s.is_accessible_define(s.public, s.token) {
            self.push_err(decl.token, LogMsg.IdentNotExist, decl.ident)
            ret nil
        }

        // Name selection.
        // Return instance instantly.
        if self.selection {
            if decl.generics.len > 0 {
                self.push_err(decl.token, LogMsg.GenericsNotAllowed)
                ret nil
            }
            ret &StructIns{
                decl: s,
            }
        }

        let mut ok = self.not_plain || self.check_illegal_cycles(decl, s)
        if !ok {
            ret nil
        }
        self.append_used_struct_reference(s)

        let mut ins = self.build_struct_instance(decl, s)
        if ins == nil {
            ret nil
        }

        ok = self.s.check_generic_quantity(ins.decl.generics.len, ins.generics.len, decl.token)
        if !ok {
            ret nil
        }

        let mut exist_instance = s.append_instance(ins)
        if exist_instance != nil {
            if !self.s.check_constraints_struct(ins, decl.token, exist_instance) {
                ret nil
            }
            // Already checked instance, did not appended.
            // So, this instance is not unique.
            self.push_reference[&StructIns](exist_instance)
            ret exist_instance
        }
        if !self.check_struct_ins(ins, decl.token) {
            ret nil
        }
        self.push_reference[&StructIns](ins)
        ret ins
    }

    // Returns identifier if found. Also checks founded identifier.
    // Uses internal lookup for all process except finding step of identifier.
    // Will find identifier in [l], not internal lookup.
    // Also finds in built-in lookup if allowed.
    // If another lookup nedeed, uses internal lookup, so any generic type build
    // process will use internal lookup. This might be useful for building
    // genericed type from another package.
    fn get_def(mut self, mut &decl: &IdentTypeDecl): Kind {
        for _, g in self.ignore_generics {
            if g.ident == decl.ident {
                ret build_prim_type(g.ident)
            }
        }

        for (_, mut g) in self.use_generics {
            if g.ident == decl.ident {
                if decl.generics.len > 0 {
                    self.push_err(decl.token, LogMsg.TypeNotSupportsGenerics, decl.ident)
                    ret nil
                }
                let mut st = g.kind.kind.strct()
                if st != nil {
                    let ok = self.check_illegal_cycles(decl, st.decl)
                    if !ok {
                        ret nil
                    }
                }
                ret g.kind.kind.kind
            }
        }

        if !decl.cpp_linked {
            let mut e = self.lookup.find_enum(decl.ident)
            if e != nil {
                ret self.from_enum(decl, e)
            }

            let mut te = self.lookup.find_type_enum(decl.ident)
            if te != nil {
                ret self.from_type_enum(decl, te)
            }

            let mut t = self.lookup.find_trait(decl.ident)
            if t == nil && !self.dis_builtin {
                t = find_builtin_trait(decl.ident)
            }
            if t != nil {
                ret self.from_trait(decl, t)
            }
        } else if self.selection {
            self.push_err(decl.token, LogMsg.CppLinkedTypeNotAllowed)
            ret nil
        }

        let mut s = self.lookup.find_struct(decl.ident, decl.cpp_linked)
        if s != nil {
            ret self.from_struct(decl, s)
        }

        let mut ta = self.lookup.find_type_alias(decl.ident, decl.cpp_linked)
        if ta == nil && !self.dis_builtin {
            ta = find_builtin_type_alias(decl.ident)
        }
        if ta != nil {
            ret self.from_type_alias(decl, ta)
        }

        self.push_err(decl.token, LogMsg.IdentNotExist, decl.ident)
        ret nil
    }

    fn build_ident(mut self, mut decl: &IdentTypeDecl): Kind {
        match {
        | is_prim(decl.ident):
            ret self.build_prim(decl)
        |:
            ret self.get_def(decl)
        }
    }

    fn build_sub_ident(mut self, mut decl: &SubIdentTypeDecl): Kind {
        let mut ident = self.build_ident(decl.idents[0])
        if ident == nil {
            ret nil
        }
        match type ident {
        | &TypeEnum:
            break
        |:
            self.push_err(self.error_token, LogMsg.InvalidSyntax)
            ret nil

        }
        let mut t = (&TypeEnum)(ident)
        let mut idents = decl.idents[1:]
        for i, id in idents {
            let mut item = t.find_item(id.ident)
            if item == nil {
                self.push_err(id.token, LogMsg.ObjHaveNotIdent, t.ident, id.ident)
                ret nil
            }
            if idents.len - i == 1 {
                self.push_reference_by_kind(item.kind.kind)
                ret item.kind.kind
            }
            t = item.kind.kind.tenm()
            if t == nil {
                self.push_err(self.error_token, LogMsg.InvalidSyntax)
                ret nil
            }
        }
        // Should be unreachable.
        ret nil
    }

    fn build_sptr_from_type(mut self, mut &elem: &TypeKind): &Sptr {
        // Check special cases.
        match {
        | elem == nil:
            ret nil
        | elem.strct() != nil:
            let s = elem.strct()
            if s.decl != nil && s.decl.cpp_linked {
                self.push_err(self.error_token, LogMsg.CppLinkedStructForRef)
                ret nil
            }
        | elem.arr() != nil && elem.arr().auto:
            self.push_err(self.error_token, LogMsg.ArrayAutoSized)
            ret nil
        }
        ret &Sptr{
            elem: elem,
        }
    }

    fn build_sptr(mut self, mut decl: &SptrTypeDecl): &Sptr {
        let not_plain = self.not_plain
        self.not_plain = true
        defer { self.not_plain = not_plain }

        let mut elem = self.check_decl(decl.elem)
        ret self.build_sptr_from_type(elem)
    }

    fn build_ptr_from_type(mut self, mut &elem: &TypeKind): &Ptr {
        // Check special cases.
        match {
        | elem == nil:
            ret nil
        | elem.arr() != nil && elem.arr().auto:
            self.push_err(self.error_token, LogMsg.ArrayAutoSized)
            ret new(Ptr)
        }

        ret &Ptr{
            elem: elem,
        }
    }

    fn build_ptr(mut self, mut decl: &PtrTypeDecl): &Ptr {
        let not_plain = self.not_plain
        self.not_plain = true
        defer { self.not_plain = not_plain }

        let mut elem: &TypeKind = nil

        if !decl.is_unsafe() {
            elem = self.check_decl(decl.elem)
            ret self.build_ptr_from_type(elem)
        }

        ret &Ptr{
            elem: elem,
        }
    }

    fn build_slc(mut self, mut decl: &SlcTypeDecl): &Slc {
        let not_plain = self.not_plain
        self.not_plain = true
        defer { self.not_plain = not_plain }

        let mut elem = self.check_decl(decl.elem)

        // Check special cases.
        match {
        | elem == nil:
            ret nil
        | elem.arr() != nil && elem.arr().auto:
            self.push_err(decl.elem.token, LogMsg.ArrayAutoSized)
            ret nil
        }

        ret &Slc{
            elem: elem,
        }
    }

    fn build_arr(mut self, mut decl: &ArrTypeDecl): &Arr {
        let not_plain = self.not_plain
        self.not_plain = true
        defer { self.not_plain = not_plain }

        let mut n = 0

        if !decl.auto_sized() {
            let mut size = self.s.eval(self.lookup).eval_expr(decl.size)
            if size == nil {
                ret nil
            }

            if !size.is_const() {
                self.push_err(decl.size.token, LogMsg.ExprNotConst)
                ret nil
            } else if size.kind.prim() == nil || !types::is_int(size.kind.prim().kind) {
                self.push_err(decl.size.token, LogMsg.ArraySizeIsNotInt)
                ret nil
            }

            n = int(size.constant.as_i64())
            if n < 0 {
                self.push_err(decl.elem.token, LogMsg.ArraySizeIsNeg)
                ret nil
            } else if types::BIT_SIZE != 64 && f64(n) > types::max(PrimKind.Int) {
                self.push_err(decl.size.token, LogMsg.OverflowLimits)
                ret nil
            }
        }

        let mut elem = self.check_decl(decl.elem)

        // Check special cases.
        match {
        | elem == nil:
            ret nil
        | elem.arr() != nil && elem.arr().auto:
            self.push_err(decl.elem.token, LogMsg.ArrayAutoSized)
            ret nil
        }

        ret &Arr{
            auto: decl.auto_sized(),
            n: n,
            elem: elem,
        }
    }

    fn build_map(mut self, mut decl: &MapTypeDecl): &Map {
        let not_plain = self.not_plain
        self.not_plain = true
        defer { self.not_plain = not_plain }

        let mut key = self.check_decl(decl.key)
        if key == nil {
            ret nil
        }

        let mut val = self.check_decl(decl.val)
        if val == nil {
            ret nil
        }
        if val.enm() != nil {
            self.push_err(decl.val.token, LogMsg.EnumAsMapVal)
        }

        ret &Map{
            key: key,
            val: val,
        }
    }

    fn build_tuple(mut self, mut decl: &TupleTypeDecl): &Tuple {
        let mut types = make([]&TypeKind, 0, decl.types.len)
        for (_, mut t) in decl.types {
            let mut kind = self.check_decl(t)
            if kind == nil {
                ret nil
            }
            types = append(types, kind)
        }

        ret &Tuple{types: types}
    }

    fn check_fn_types(mut self, mut &f: &FnIns): (ok: bool) {
        for (_, mut p) in f.params {
            p.kind = self.build(p.decl.kind.decl.kind)
            ok = p.kind != nil
            if !ok {
                ret false
            }
        }

        if !f.decl.is_void() {
            f.result = self.build(f.decl.result.kind.decl.kind)
            ret f.result != nil
        }

        ret true
    }

    fn build_fn(mut self, mut decl: &FnDecl): &FnIns {
        if decl.generics.len > 0 {
            self.push_err(decl.token, LogMsg.GenericedFnAsAnonFn)
            ret nil
        }

        let mut f = build_fn(decl)
        let mut ins = f.instance_force()
        ins.anon = true

        let ok = self.check_fn_types(ins)
        if !ok {
            ret nil
        }

        ret ins
    }

    fn build_by_namespace(mut self, mut decl: &NamespaceTypeDecl): Kind {
        let path = build_link_path_by_tokens(decl.idents)
        let mut imp = self.lookup.select_package(fn(imp: &ImportInfo): bool {
            if decl.idents.len == 1 && imp.alias == path {
                ret true
            }
            ret imp.link_path == path && imp.is_accessible_via_selection()
        })

        if imp == nil || !imp.is_lookupable(TokenKind.Self) {
            self.push_err(decl.idents[0], LogMsg.NamespaceNotExist, path)
            ret nil
        }

        self.disallow_builtin()
        let mut lookup = self.lookup
        self.lookup = imp
        let mut kind = self.check_decl(decl.kind)
        self.lookup = lookup
        self.allow_builtin()

        ret kind
    }

    fn build(mut self, mut &decl_kind: TypeDeclKind): &TypeKind {
        let mut kind: Kind = nil
        match type decl_kind {
        | &IdentTypeDecl:
            let mut t = self.build_ident((&IdentTypeDecl)(decl_kind))
            if t != nil {
                kind = t
            }
        | &SubIdentTypeDecl:
            let mut t = self.build_sub_ident((&SubIdentTypeDecl)(decl_kind))
            if t != nil {
                kind = t
            }
        | &SptrTypeDecl:
            self.inscatch = true
            let mut t = self.build_sptr((&SptrTypeDecl)(decl_kind))
            if t != nil {
                kind = t
            }
        | &PtrTypeDecl:
            self.inscatch = true
            let mut t = self.build_ptr((&PtrTypeDecl)(decl_kind))
            if t != nil {
                kind = t
            }
        | &SlcTypeDecl:
            self.inscatch = true
            let mut t = self.build_slc((&SlcTypeDecl)(decl_kind))
            if t != nil {
                kind = t
            }
        | &ArrTypeDecl:
            self.inscatch = true
            let mut t = self.build_arr((&ArrTypeDecl)(decl_kind))
            if t != nil {
                kind = t
            }
        | &MapTypeDecl:
            self.inscatch = true
            let mut t = self.build_map((&MapTypeDecl)(decl_kind))
            if t != nil {
                kind = t
            }
        | &TupleTypeDecl:
            self.inscatch = true
            let mut t = self.build_tuple((&TupleTypeDecl)(decl_kind))
            if t != nil {
                kind = t
            }
        | &FnDecl:
            self.inscatch = true
            let mut t = self.build_fn((&FnDecl)(decl_kind))
            if t != nil {
                kind = t
            }
        | &NamespaceTypeDecl:
            self.inscatch = true
            let mut t = self.build_by_namespace((&NamespaceTypeDecl)(decl_kind))
            if t != nil {
                kind = t
            }
        |:
            let mut udecl_kind = unsafe { *(*any)(&decl_kind) }
            match type udecl_kind {
            | &Sptr:
                kind = (&Sptr)(udecl_kind)
            | &Ptr:
                kind = (&Ptr)(udecl_kind)
            |:
                self.push_err(self.error_token, LogMsg.InvalidType)
                ret nil
            }
        }
        if kind == nil {
            ret nil
        }
        match type kind {
        | &TypeKind:
            ret (&TypeKind)(kind)
        |:
            ret &TypeKind{
                kind: kind,
            }
        }
    }

    fn check_decl(mut self, mut &decl: &TypeDecl): &TypeKind {
        // Save current token.
        let mut error_token = self.error_token

        self.error_token = decl.token
        let mut kind = self.build(decl.kind)
        self.error_token = error_token

        ret kind
    }

    fn check(mut self, mut &t: &TypeSymbol) {
        if t.decl == nil {
            ret
        }
        let mut kind = self.check_decl(t.decl)
        if kind == nil {
            t.remove_kind()
            ret
        }
        t.kind = kind
    }
}

struct IdentTypeLookup {}

impl IdentTypeLookup {
    static fn __ident_type_decl(&ident: str, t: &IdentTypeDecl): bool {
        if t.ident == ident {
            ret true
        }
        for _, g in t.generics {
            if IdentTypeLookup.exist(ident, g.kind) {
                ret true
            }
        }
        ret false
    }

    static fn exist(&ident: str, &k: TypeDeclKind): bool {
        match type k {
        | &IdentTypeDecl:
            ret IdentTypeLookup.__ident_type_decl(ident, (&IdentTypeDecl)(k))
        | &SubIdentTypeDecl:
            let sit = (&SubIdentTypeDecl)(k)
            for _, id in sit.idents {
                if IdentTypeLookup.__ident_type_decl(ident, id) {
                    ret true
                }
            }
            ret false
        | &SptrTypeDecl:
            let sptr = (&SptrTypeDecl)(k)
            ret IdentTypeLookup.exist(ident, sptr.elem.kind)
        | &PtrTypeDecl:
            let ptr = (&PtrTypeDecl)(k)
            ret IdentTypeLookup.exist(ident, ptr.elem.kind)
        | &SlcTypeDecl:
            let slc = (&SlcTypeDecl)(k)
            ret IdentTypeLookup.exist(ident, slc.elem.kind)
        | &ArrTypeDecl:
            let arr = (&ArrTypeDecl)(k)
            ret IdentTypeLookup.exist(ident, arr.elem.kind)
        | &MapTypeDecl:
            let map = (&MapTypeDecl)(k)
            ret IdentTypeLookup.exist(ident, map.key.kind) ||
                IdentTypeLookup.exist(ident, map.val.kind)
        | &FnDecl:
            let f = (&FnDecl)(k)
            for _, p in f.params {
                if p.is_self() {
                    continue
                }
                if IdentTypeLookup.exist(ident, p.kind.kind) {
                    ret true
                }
            }
            if f.result != nil {
                ret IdentTypeLookup.exist(ident, f.result.kind.kind)
            }
            ret false
        | &TupleTypeDecl:
            let tup = (&TupleTypeDecl)(k)
            for _, t in tup.types {
                if IdentTypeLookup.exist(ident, t.kind) {
                    ret true
                }
            }
            ret false
        | &NamespaceTypeDecl:
            let ns = (&NamespaceTypeDecl)(k)
            ret IdentTypeLookup.exist(ident, ns.kind.kind)
        |:
            ret false
        }
    }
}

fn kind_uses_generics(&k: TypeDeclKind, &generics: []&GenericDecl): bool {
    for _, g in generics {
        if IdentTypeLookup.exist(g.ident, k) {
            ret true
        }
    }
    ret false
}

// Reports whether directive is exist.
fn has_directive(mut &directives: []&ast::Directive, tag: str): bool {
    for (_, mut dr) in directives {
        if dr.tag.kind == tag {
            ret true
        }
    }
    ret false
}

fn can_get_ptr(mut &d: &Data): bool {
    if !d.lvalue || d.is_const() {
        ret false
    }

    match {
    | d.kind.fnc() != nil || d.kind.enm() != nil:
        ret false
    |:
        ret true
    }
}

// Reports kind is valid for smart pointer type such as &T.
fn is_valid_for_sptr_type(mut &t: &TypeKind): bool {
    let mut s = t.strct()
    if s != nil && s.decl != nil && s.decl.cpp_linked {
        ret false
    }
    ret true
}

// Reports kind is valid for reference such as reference variables.
fn is_valid_for_ref(mut &t: &TypeKind): bool { ret t.fnc() == nil }

// Reports whether type has built-in string conversion support.
fn is_builtin_str_convertable(mut &t: &TypeKind): bool {
    ret !t.void() && t.fnc() == nil && t.tup() == nil
}

fn build_link_path_by_tokens(&tokens: []&Token): str {
    let mut s = tokens[0].kind
    for _, token in tokens[1:] {
        s += "::"
        s += token.kind
    }
    ret s
}

fn build_prim_type(kind: str): &Prim {
    ret &Prim{
        kind: kind,
    }
}

fn get_struct_from_kind(mut k: &TypeKind): &Struct {
    match {
    | k == nil:
        ret nil
    | k.strct() != nil:
        ret k.strct().decl
    | k.sptr() != nil:
        ret get_struct_from_kind(k.sptr().elem)
    | k.slc() != nil:
        ret get_struct_from_kind(k.slc().elem)
    | k.arr() != nil:
        ret get_struct_from_kind(k.arr().elem)
    | k.ptr() != nil:
        // Pass pointers.
        // Cloning just copies pointer address.
        // There is no any illegal cycle risk.
        ret nil
    |:
        ret nil
    }
}

// Reports whether kind is primitive type.
fn is_prim(kind: str): bool {
    ret kind == TokenKind.I8 ||
        kind == TokenKind.I16 ||
        kind == TokenKind.I32 ||
        kind == TokenKind.I64 ||
        kind == TokenKind.U8 ||
        kind == TokenKind.U16 ||
        kind == TokenKind.U32 ||
        kind == TokenKind.U64 ||
        kind == TokenKind.F32 ||
        kind == TokenKind.F64 ||
        kind == TokenKind.Int ||
        kind == TokenKind.Uint ||
        kind == TokenKind.Uintptr ||
        kind == TokenKind.Bool ||
        kind == TokenKind.Str ||
        kind == TokenKind.Any
}

fn apply_implicit_cast(mut &dest: &TypeKind, mut &d: &Data) {
    if d.kind.is_nil() {
        ret
    }

    let dest_prim = dest.prim()
    let prim = d.kind.prim()
    if dest_prim != nil {
        if dest_prim.is_any() {
            apply_cast_kind(d, dest)
            ret
        }
        if !d.kind.cpp_linked() &&
            !d.kind.variadic &&
            !d.lvalue &&
            !d.is_const() &&
            prim != nil &&
            types::is_num(prim.kind) {
            apply_cast_kind(d, dest)
        }
        ret
    }

    if dest.trt() != nil && d.kind.trt() == nil {
        apply_cast_kind_model(d, dest)
        ret
    }

    if dest.tenm() != nil && d.kind.tenm() == nil {
        apply_cast_kind_model(d, dest)
        ret
    }
}