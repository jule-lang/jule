// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Table for standard base64 encoding, as defined in RFC 4648.
static t64e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

// Decoding table for t64e.
static t64d: [...]i32 = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 63, 62, 62, 63, 52, 53, 54, 55,
    56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6,
    7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0,
    0, 0, 0, 63, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
]

// Standard byte for padding.
const paddingByte = '='

// Returns length of encoded bytes of b.
fn EncodeLen(b: []byte, pad: bool): int {
    let mut n = (len(b) + 2) / 3 << 2
    if pad {
        if n%4 != 0 { // Padding 1
            n--
            if n%4 > 2 { // Padding 2
                n--
            }
        }
    }
    ret n
}

fn encode(&src: []byte, pad: bool): []byte {
    let n = EncodeLen(src, pad)
    if n <= len(src) {
        ret nil
    }
    let mut dest = make([]byte, n)
    let mut j = &dest[0]
    let mut i = &src[0]
    let end = i + len(src)
    let table = &t64e[0]
    for i+3 <= end; i += 3 {
        unsafe {
            *j = table[i[0]>>2]
            j++
            *j = table[((i[0]&0x03)<<4)|(i[1]>>4)]
            j++
            *j = table[((i[1]&0x0f)<<2)|(i[2]>>6)]
            j++
            *j = table[i[2]&0x3f]
            j++
        }
    }
    if i < end {
        unsafe {
            *j = table[i[0]>>2]
            j++
            if i+1 == end {
                *j = table[(i[0]&0x03)<<4]
                j++
                if pad {
                    *j = paddingByte
                    j++
                }
            } else {
                *j = table[((i[0]&0x03)<<4)|(i[1]>>4)]
                j++
                *j = table[(i[1]&0x0f)<<2]
                j++
            }
            if pad {
                *j = paddingByte
                j++
            }
        }
    }
    ret dest
}

// Encodes source bytes with standard base64 table.
// Returns encoded base64 bytes if success, nil slice if not.
// Adds padding if pad is true.
fn Encode(src: []byte, pad: bool): []byte {
    ret encode(src, pad)
}

// Encodes source bytes with url base64 table.
// It is typically used for URLs and file names.
// Returns encoded base64 bytes if success, nil slice if not.
fn EncodeUrl(src: []byte): []byte {
    const Padding = false
    let mut r = encode(src, Padding)
    for i, b in r {
        match b {
        | '+':
            r[i] = '-'
        | '/':
            r[i] = '_'
        }
    }
    ret r
}

fn decode(&src: []byte): []byte {
    if len(src) == 0 {
        ret nil
    }
    let p = &src[0]
    let mut j = 0
    let pad1 = len(src)%4 != 0 || unsafe { *(p+len(src)-1) } == paddingByte
    let pad2 = pad1 && (len(src)%4 > 2 || unsafe { *(p+len(src)-2) } != paddingByte)
    let mut l = len(src)
    if pad1 {
        l--
    }
    l = l / 4 << 2
    let mut sz = l / 4 * 3
    if pad1 {
        sz++
    }
    if pad2 {
        sz++
    }
    let mut dest = make([]byte, sz)
    let mut d = &dest[0]

    // Use pointer for table to skip boundary-checking cost.
    let ip = &t64d[0]

    let mut i = 0
    for i < l; i += 4 {
        unsafe {
            let n = ip[p[i]] << 18 | ip[p[i+1]] << 12 | ip[p[i+2]] << 6 | ip[p[i+3]]
            d[j] = byte(n >> 16)
            j++
            d[j] = byte(n >> 8 & 0xFF)
            j++
            d[j] = byte(n & 0xFF)
            j++
        }
    }
    if pad1 {
        unsafe {
            let mut n = ip[p[l]] << 18 | ip[p[l+1]] << 12
            d[j] = byte(n >> 16)
            j++
            if pad2 {
                n |= ip[p[l+2]] << 6
                d[j] = byte(n >> 8 & 0xFF)
                j++
            }
        }
    }
    ret dest
}

// Decodes source bytes with standard base64 table.
// Returns decoded bytes if success, nil slice if not.
// Detects padding by default, no required padding specification.
fn Decode(src: []byte): []byte {
    ret decode(src)
}

// Decodes source bytes with url base64 table.
// It is typically used for URLs and file names.
// Returns decoded bytes if success, nil slice if not.
fn DecodeUrl(src: []byte): []byte {
    ret decode(src)
}