// Copyright 2022-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::sync::atomic::{MemoryOrder, AtomicU32}

// Do not copy an instance of WaitGroup, use a ref or pointer instead.
//
// usage: in main thread:
// `wg: std::sync::WaitGroup
// `wg.add(delta)` before starting tasks with `co ...`
// `wg.wait()` to wait for all tasks to have finished
//
// in each parallel job:
// `wg.done()` when finished
pub struct WaitGroup {
    taskN: AtomicU32 // current task count - reading/writing should be atomic
    waitN: AtomicU32 // current wait count - reading/writing should be atomic
}

impl WaitGroup {
    // Returns new WaitGroup instance.
    pub static fn New(): &WaitGroup {
        ret new(WaitGroup)
    }

    // Increments (+delta) or decrements (-delta) task count by delta
    // and unblocks any wait() calls if task count becomes zero.
    // Panics if task count reaches below zero.
    pub fn Add(mut self, delta: int) {
        let oldTask = int(self.taskN.Add(u32(delta), MemoryOrder.Relaxed))
        let nTask = oldTask + delta
        if nTask < 0 {
            panic("std:sync: WaitGroup.Add: negative number of tasks")
        }

        // Number of tasks still greater than zero.
        // No need to clear waiters.
        if nTask != 0 {
            ret
        }

        // Number of tasks reaches to zero, therefore clear waiters.
        for {
            let nWaiters = self.waitN.Load(MemoryOrder.Relaxed)
            if nWaiters == 0 {
                ret
            }

            if self.waitN.CompareSwap(nWaiters, 0, MemoryOrder.Relaxed) {
                ret
            }
        }
    }

    // Decrements the WaitGroup counter by one.
    pub fn Done(mut self) { self.Add(-1) }

    // Blocks until all tasks are done (task count becomes zero)
    pub fn Wait(mut self) {
        let nTask = self.taskN.Load(MemoryOrder.Relaxed)
        if nTask == 0 {
            // No task, no need to wait.
            ret
        }

        // Register this wait call to waiters.
        self.waitN.Add(1, MemoryOrder.Relaxed)

        // Wait for clearing waiters.
        for self.waitN.Load(MemoryOrder.Relaxed) != 0 {}
    }
}