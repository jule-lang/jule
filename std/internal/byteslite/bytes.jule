// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Package byteslite implements algorithms for byte stacks with
// a minor dependencies, what a cheap algorithm package for byte stacks.

// Returns index of first matched item with specified byte,
// returns -1 if not exist any match. Starts searching at left
// of slice to right.
fn IndexByte(s: []byte, b: byte): int {
	// Trust optimizations of compiler.
	for i, se in s {
		if se == b {
			ret i
		}
	}
	ret -1
}

fn lastIndexByte(begin: *byte, mut end: *byte, b: byte): int {
	mut it := end
	for it >= begin; it-- {
		unsafe {
			if (*it == b) {
				ret int(it - begin)
			}
		}
	}
	ret -1
}

// Returns index of first matched item with specified byte,
// returns -1 if not exist any match. Starts searching at right
// of slice to left.
fn LastIndexByte(s: []byte, b: byte): int {
	if len(s) == 0 {
		ret -1
	}
	ret lastIndexByte(&s[0], &s[len(s)-1], b)
}

// Same as IndexByte, but takes string as byte stack.
fn IndexByteStr(s: str, b: byte): int {
	// Trust optimizations of compiler.
	for i, se in s {
		if se == b {
			ret i
		}
	}
	ret -1
}

// Same as LastIndexByte, but takes string as byte stack.
fn LastIndexByteStr(s: str, b: byte): int {
	if len(s) == 0 {
		ret -1
	}
	ret lastIndexByte(&s[0], &s[len(s)-1], b)
}