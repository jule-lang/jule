// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use math for std::math

// The Jule code is a modified version of the original Go code from
// https://github.com/golang/go/blob/go1.20/src/math/cmplx/pow.go and came with this notice.
//
// ====================================================


impl Cmplx {
    // Returns x**y, the base-x (self) exponential of y.
    // For generalized compatibility with [math::pow]:
    //
    //  pow(0, Â±0) returns 1+0i
    //  pow(0, c) for c.real()<0 returns inf+0i if c.imag() is zero, otherwise inf+inf i.
    pub fn pow(self, y: Cmplx): Cmplx {
        if self.is_zero() { // Guaranteed also true for x == -0.
            if y.is_nan() {
                ret Cmplx.nan()
            }
            match {
            | y.real() == 0:
                ret Cmplx.new(1, 0)
            | y.real() < 0:
                if y.imag() == 0 {
                    ret Cmplx.new(math::inf(1), 0)
                }
                ret Cmplx.inf(1)
            | y.real() > 0:
                ret Cmplx.zero()
            }
            panic("not reached")
        }
        let modulus = self.abs()
        if modulus == 0 {
            ret Cmplx.zero()
        }
        let mut r = math::pow(modulus, y.real())
        let arg = self.phase()
        let mut theta = y.real() * arg
        if y.imag() != 0 {
            r *= math::exp(-y.imag() * arg)
            theta += y.imag() * math::log(modulus)
        }
        let (s, c) = math::sincos(theta)
        ret Cmplx.new(r*c, r*s)
    }
}
