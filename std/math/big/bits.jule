// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Single bit.
type bit: byte

// In internal order, bits are stored in reversed order for performance purposes.
type bits: []bit

const INT_SIZE = 32 << (^uint(0) >> 63)

fn u64_from_bits(b: bits): u64 {
    let mut u = u64(0)
    for i, bit in b {
        u |= u64(bit) << i
    }
    ret u
}

// Add one to bits.
// Equals to x++ operator.
fn add_one(mut &b: bits): (carry: bit) {
    for i, x in b {
        if x == 0 {
            b[i] = 1
            ret 0b0
        }
        b[i] = 0
    }
    ret 0b1
}

// Subrract one from bits.
// Equals to x-- operator.
fn sub_one(mut &b: bits) {
    let mut j = 0
    for i, x in b {
        if x == 0b1 {
            b[i] = 0b0
            j = i
            break
        }
        b[i] = 0
    }
    for i in b[:j] {
        b[i] = 0b1
    }
}

fn reverse(mut &b: bits) {
    let mut i = 0
    for i < b.len / 2; i++ {
        b.swap(i, b.len - 1 - i)
    }
}

fn add(mut &x: bits, &y: bits) {
    let mut carry = bit(0)
    match {
    | y.len == 1:
        carry = add_one(x)
    | x.len == y.len:
        carry = add_bits_fast(x, y)
    | x.len > y.len:
        carry = add_bits_rfast(x, y)
    |:
        x, carry = add_bits(y, x)
    }
    if carry == 0b1 {
        x = append(x, 0b1)
    }
}

fn sub(mut &x: bits, &y: bits) {
    let mut carry = bit(0)
    match {
    | y.len == 1:
        twos_complement(x)
        carry = add_one(x)
    | x.len == y.len:
        twos_complement(x)
        carry = add_bits_fast(x, y)
    | x.len > y.len:
        twos_complement(x)
        carry = add_bits_rfast(x, y)
    |:
        let mut xn = make(bits, y.len)
        _ = copy(xn, x)
        x = xn
        twos_complement(x)
        carry = add_bits_fast(x, y)
    }
    if carry == 0b0 {
        twos_complement(x)
    }
}

// Update bits by 1's complement.
fn ones_complement(mut &b: bits) {
    for i, x in b {
        b[i] = ^x & 0b1
    }
}

// Update bits by 2's complement.
fn twos_complement(mut &b: bits) {
    ones_complement(b)
    _ = add_one(b)
}

// Addition operation on operand bits.
// Returns bits and carry.
// Carry is guaranteed to be 0b0 or 0b1.
// Does not allocates new bits for result, updates elements of x.
// x and y should be have same bitsize.
fn add_bits_fast(mut &x: bits, &y: bits): (carry: bit) {
    for i, xbit in x {
        let ybit = y[i]
        x[i] = xbit ^ ybit ^ carry
        carry = (xbit & ybit) | (xbit & carry) | (ybit & carry)
    }
    ret
}

// Addition operation on operand bits.
// Returns bits and carry.
// Carry is guaranteed to be 0b0 or 0b1.
// Does not allocates new bits for result, updates elements of x.
// y implies imaginary zero-bits for missing part if y.bit-size < x.bit-size.
fn add_bits_rfast(mut &x: bits, &y: bits): (carry: bit) {
    for i, xbit in x {
        let ybit = if i < y.len { y[i] } else { 0b0 }
        x[i] = xbit ^ ybit ^ carry
        carry = (xbit & ybit) | (xbit & carry) | (ybit & carry)
    }
    ret
}

// Addition operation on operand bits.
// Returns bits and carry.
// Carry is guaranteed to be 0b0 or 0b1.
// y implies imaginary zero-bits for missing part if y.bit-size < x.bit-size.
fn add_bits(&x: bits, &y: bits): (r: bits, carry: bit) {
    r = make(bits, 0, x.len)
    for i, xbit in x {
        let ybit = if i < y.len { y[i] } else { 0b0 }
        r = append(r, xbit ^ ybit ^ carry)
        carry = (xbit & ybit) | (xbit & carry) | (ybit & carry)
    }
    ret
}

// Eliminates initial-zeros, normalizes bits.
fn fit_bits(mut &b: bits) {
    let mut i = b.len - 1
    for i >= 0; i-- {
        if b[i] != 0b0 {
            break
        }
    }
    b = b[:i + 1]
}

// Compares bits.
// Returns +1 if x > y.
// Returns 0 if x == y.
// Returns -1 if x < y.
fn bits_cmp(&x: bits, &y: bits): int {
    match {
    | x.len < y.len:
        ret -1
    | x.len > y.len:
        ret +1
    }
    let mut i = x.len - 1
    for i >= 0; i-- {
        let xbit = x[i]
        let ybit = y[i]
        match {
        | xbit > ybit:
            ret +1
        | xbit < ybit:
            ret -1
        }
    }
    ret 0
}

// Reports whether number is odd that represented by bits.
fn is_odd(&b: bits): bool {
    ret b.len > 0 && b[0] == 0b1
}

// Basic multiplication algorithm for bits.
fn basic_mul(mut x: bits, mut y: bits): bits {
    if y.len == 1 {
        ret x
    }
    let mut r: bits = nil
    let mut m = make(bits, x.len, x.len << 1)
    _ = copy(m, x)
    for y.len > 0 {
        if is_odd(y) {
            add(r, m)
        }
        m = append(m[:1], m...)
        m[0] = 0b0
        y = y[1:]
    }
    ret r
}

fn karatsuba_add_bits(mut x: bits, mut y: bits): bits {
    reverse(x)
    reverse(y)
    defer {
        reverse(x)
        reverse(y)
    }

    let mut carry = bit(0)
    let mut r: bits = nil
    match {
    | x.len == y.len:
        r, carry = add_bits(x, y)
    | x.len > y.len:
        r, carry = add_bits(x, y)
    |:
        r, carry = add_bits(y, x)
    }
    if carry == 0b1 {
        r = append(r, 0b1)
    }
    reverse(r)
    ret r
}

fn karatsuba_sub_bits(mut x: bits, mut y: bits): bits {
    x = clone(x)
    reverse(x)
    reverse(y)

    sub(x, y)
    reverse(x)
    reverse(y)
    ret x
}

fn karatsuba_shl(mut s: bits, n: int): bits {
    ret append(s, make(bits, n)...)
}

fn karatsuba(mut x: bits, mut y: bits): bits {
    let n = max(x.len, y.len)
    if n == 1 {
        if x.len == 0 || y.len == 0 || x[0] == 0b0 || y[0] == 0b0 {
            ret nil
        }
        ret [1]
    }

    let m = n >> 1
    let mut xl = x[:m]
    let mut xr = x[m:]
    let mut yl = y[:m]
    let mut yr = y[m:]

    let mut p1 = karatsuba(xl, yl)
    let mut p2 = karatsuba(xr, yr)
    let mut p3 = karatsuba(karatsuba_add_bits(xl, xr), karatsuba_add_bits(yl, yr))

    let mut c2 = karatsuba_shl(karatsuba_sub_bits(p3, karatsuba_add_bits(p1, p2)), n - m)
    let mut c1 = karatsuba_shl(p1, (n - m) << 1)
    ret karatsuba_add_bits(karatsuba_add_bits(c1, c2), p2)
}
