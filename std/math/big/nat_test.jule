// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

#build test

use std::testing::{T}

static cases_nat_from_bits = [
    "1011010",
    "1111011000",
    "10001100011000",
    "10001101101110101011110110000110111111101101",
    "10001100011111",
    "11111111111111111111111110011",
]

static cases_nat_add = [
    ["1011010", "1011010", "10110100"],
    ["1011010", "0000001", "1011011"],
    ["10011000000111", "100000101011101000", "100011000011101111"],
    ["00000000000000", "00000000001", "1"],
    ["100000101011101000", "111101100111111001", "1011110010011100001"]
]

static cases_nat_sub = [
    ["1011010", "1011010", ""],
    ["1011010", "0000001", "1011001"],
    ["100000101011101000", "10011000000111", "11110010011100001"],
    ["100010", "110111001110", "110110101100"],
    ["10001100001110", "111101101", "10000100100001"],
    ["1010", "10100", "1010"],
    ["101011", "11000", "10011"],
    ["11101110111011111111111011110101010010101101111010101101010101010101011110011010010110010101110110010101101011001011", "11101110111011111111111011110101010010101101111010101101010101010101011110011010010110010101110110010101101011001010", "1"],
]

static cases_nat_mul = [
    ["1011010", "1011010", "1111110100100"],
    ["1011010", "1", "1011010"],
    ["1011010", "0", ""],
    ["1100010", "100", "110001000"],
    ["100", "1100010", "110001000"],
    ["10001101101110101011110110000110111111101101", "10001101101110101011110110000110111111101101", "100111001110111001111001111111010101001001011000000000110101110110111110110000101101001"],
    ["100111001110111001111001111111010101001001011000000000110101110110111110110000101101001", "100111001110111001111001111111010101001001011000000000110101110110111110110000101101001", "11000000011001110000010110100111100100110000001110100100100001110010010011011011110100000111000000011100100101001011101010001010001100010011110010101111111101011110100010001"],
    ["1010", "10", "10100"],
    ["10", "1010", "10100"],
    ["1010101010101010101010101010101010101010101010", "10", "10101010101010101010101010101010101010101010100"],
    ["10", "1010101010101010101010101010101010101010101010", "10101010101010101010101010101010101010101010100"],
    ["1011", "101", "110111"],
]

static cases_nat_div = [
    ["1010", "1", "1010"],
    ["1010", "10", "101"],
    ["1000000", "110", "1010"],
    ["1001100", "11", "11001"],
    ["1000000", "100", "10000"],
    ["11111011", "1101", "10011"],
    ["10", "11", ""],
    ["10011011001110001", "111", "10110001011001"],
    ["10011001101010", "10", "1001100110101"],
    ["1010101010101010101010101010101010101010101010", "10", "101010101010101010101010101010101010101010101"],
    ["100111001110111001111001111111010101001001011000000000110101110110111110110000101101001", "10", "10011100111011100111100111111101010100100101100000000011010111011011111011000010110100"],
    ["110101101011110101010100111", "110100", "1000010000100101101111"],
    ["110101101011110101010100111", "11011001", "1111110101010101010"],
]

static cases_nat_mod = [
    ["1010", "1010", ""],
    ["1010", "1", ""],
    ["111001010111011001", "1110110", "11111"],
    ["11101110111011111111111011110101010010101101111010101101010101010101011110011010010110010101110110010101101011001011", "1110101", "1011001"],
    ["11110110110101010101010101111111111011010101010101010101001111111001010101001010101010110000000011111101101001010111001111", "1110101", "1100001"],
    ["0", "11100111", ""],
    ["0", "0", ""],
    ["110101101011110101010100111", "110100", "11011"],
    ["1010", "11", "1"],
]

static cases_nat_shl: [][]u64 = [
    [1, 8, 256],
    [9834, 32, 42236708388864],
    [9383, 0, 9383],
    [9383, 1, 18766],
    [0, 20, 0],
    [0, 0, 0],
    [123456789, 8, 31604937984],
]

static cases_nat_shr: [][]u64 = [
    [64, 2, 16],
    [256, 8, 1],
    [89357, 9, 174],
    [3759375747438473473, 49, 6677],
    [0, 90, 0],
    [2, 90, 0],
]

static cases_nat_bit_or: [][]u64 = [
    [20, 4, 20],
    [4, 20, 20],
    [345, 2, 347],
    [908474739, 747688553334, 748259113847],
    [97799739579632223, 1234567890, 97799739731806943],
]

static cases_nat_bit_and: [][]u64 = [
    [902984, 24, 8],
    [24, 902984, 8],
    [902984, 2434, 256],
    [2434, 902984, 256],
    [77786486463864864, 97774749933, 19360907296],
    [123456789, 987654321, 39471121]
]

static cases_nat_bit_xor: [][]u64 = [
    [10, 11, 1],
    [87793, 5, 87796],
    [5, 87793, 87796],
    [10, 1, 11],
    [1, 10, 11],
    [12345, 54321, 58376],
    [123, 321, 314],
    [1234567890, 9876543210, 8676316216],
]

#test
fn test_nat_from_bits(mut t: &T) {
    for _, c in cases_nat_from_bits {
        let n = Nat.from_bits(c) else {
            t.errorf("exceptional occurs: {}", error)
            continue
        }
        if n.bits.len != c.len {
            t.errorf("{} != {}", c, c)
            continue
        }
        for i, b in n.bits {
            let cb = c[c.len - 1 - i]
            if b == 0b1 && cb != '1' ||
                b == 0b0 && cb != '0' {
                t.errorf("{} != {}", c, c)
                break
            }
        }
    }
}

fn test_common_nat_op(mut &t: &T, op: str, &cases: [][]str) {
    for _, c in cases {
        let mut n1 = Nat.from_bits(c[0]) else {
            t.errorf("exception occurs: {}", error)
            continue
        }
        let n2 = Nat.from_bits(c[1]) else {
            t.errorf("exception occurs: {}", error)
            continue
        }
        match op {
        | "+":
            n1 += n2
        | "-":
            n1 -= n2
        | "*":
            n1 *= n2
        | "/":
            n1 /= n2
        | "%":
            n1 %= n2
        }
        let cr = c[2]
        if n1.len() != cr.len {
            t.errorf("{} {} {} != {}", c[0], op, c[1], cr)
            continue
        }
        for i, b in n1.bits {
            let cb = cr[cr.len - 1 - i]
            if b == 0b1 && cb != '1' ||
                b == 0b0 && cb != '0' {
                t.errorf("{} {} {} != {}", c[0], op, c[1], cr)
                break
            }
        }
    }
}

#test
fn test_nat_add(mut t: &T) {
    test_common_nat_op(t, "+", cases_nat_add)
}

#test
fn test_nat_sub(mut t: &T) {
    test_common_nat_op(t, "-", cases_nat_sub)
}

#test
fn test_nat_mul(mut t: &T) {
    test_common_nat_op(t, "*", cases_nat_mul)
}

#test
fn test_nat_div(mut t: &T) {
    test_common_nat_op(t, "/", cases_nat_div)
}

#test
fn test_nat_mod(mut t: &T) {
    test_common_nat_op(t, "%", cases_nat_mod)
}

fn test_nat_bit_binary(mut &t: &T, op: str, &cases: [][]u64) {
    for _, c in cases {
        let mut n1 = Nat.new(c[0])
        let n2 = Nat.new(c[1])
        match op {
        | "|":
            n1 |= n2
        | "&":
            n1 &= n2
        | "^":
            n1 ^= n2
        }
        let u = n1.to_u64()!
        if u != c[2] {
            t.errorf("{} {} {} != {}", c[0], op, c[1], c[2])
        }
    }
}

#test
fn test_nat_bit_or(mut t: &T) {
    test_nat_bit_binary(t, "|", cases_nat_bit_or)
}

#test
fn test_nat_bit_and(mut t: &T) {
    test_nat_bit_binary(t, "&", cases_nat_bit_and)
}

#test
fn test_nat_bit_xor(mut t: &T) {
    test_nat_bit_binary(t, "^", cases_nat_bit_xor)
}

#test
fn test_nat_shl(mut t: &T) {
    for _, c in cases_nat_shl {
        let n = Nat.new(c[0])
        let mut r = n << uint(c[1])
        let u = r.to_u64()!
        if u != c[2] {
            t.errorf("{} << {} != {}", c[0], c[1], c[2])
        }
    }
}

#test
fn test_nat_shr(mut t: &T) {
    for _, c in cases_nat_shr {
        let n = Nat.new(c[0])
        let mut r = n >> uint(c[1])
        let u = r.to_u64()!
        if u != c[2] {
            t.errorf("{} >> {} != {}", c[0], c[1], c[2])
        }
    }
}

#test
fn test_nat_lt(mut t: &T) {
    t.assert(!Nat.from_bits("1011010")!.lt(Nat.from_bits("00001011010")!), "1) 1011010 < 00001011010")
    t.assert(!Nat.from_bits("1111011000")!.lt(Nat.from_bits("000000000001111011000")!), "2) 1111011000 < 000000000001111011000")
    t.assert(!Nat.from_bits("10001100011000")!.lt(Nat.from_bits("100011")!), "3) 10001100011000 < 100011")
    t.assert(!Nat.from_bits("10001101101110101011110110000110111111101111")!.lt(Nat.from_bits("10001101101110101011110110000110111111101101")!), "4) 10001101101110101011110110000110111111101111 < 10001101101110101011110110000110111111101101")
}

#test
fn test_nat_gt(mut t: &T) {
    t.assert(!Nat.from_bits("1011010")!.gt(Nat.from_bits("00001011010")!), "1) 1011010 > 00001011010")
    t.assert(!Nat.from_bits("1111011000")!.gt(Nat.from_bits("000000000001111011000")!), "2) 1111011000 > 000000000001111011000")
    t.assert(Nat.from_bits("10001100011000")!.gt(Nat.from_bits("100011")!), "3) 10001100011000 <= 100011")
    t.assert(Nat.from_bits("10001101101110101011110110000110111111101111")!.gt(Nat.from_bits("10001101101110101011110110000110111111101101")!), "4) 10001101101110101011110110000110111111101111 <= 10001101101110101011110110000110111111101101")
    t.assert(!Nat.from_bits("10000100100001")!.gt(Nat.from_bits("10011001101010")!), "5) 10000100100001 >= 10011001101010")
}

#test
fn test_nat_eq(mut t: &T) {
    t.assert(Nat.from_bits("1011010")!.eq(Nat.from_bits("00001011010")!), "1) 1011010 != 00001011010")
    t.assert(Nat.from_bits("1111011000")!.eq(Nat.from_bits("000000000001111011000")!), "2) 1111011000 != 000000000001111011000")
    t.assert(Nat.from_bits("10001100011000")!.eq(Nat.from_bits("10001100011000")!), "3) 10001100011000 != 10001100011000")
    t.assert(Nat.from_bits("10001101101110101011110110000110111111101101")!.eq(Nat.from_bits("10001101101110101011110110000110111111101101")!), "4) 10001101101110101011110110000110111111101101 != 10001101101110101011110110000110111111101101")
}
