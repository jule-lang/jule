// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

#build test

use std::testing::{T}

static casesNatFromBits = [
    "1011010",
    "1111011000",
    "10001100011000",
    "10001101101110101011110110000110111111101101",
    "10001100011111",
    "11111111111111111111111110011",
]

static casesNatAdd = [
    ["1011010", "1011010", "10110100"],
    ["1011010", "0000001", "1011011"],
    ["10011000000111", "100000101011101000", "100011000011101111"],
    ["00000000000000", "00000000001", "1"],
    ["100000101011101000", "111101100111111001", "1011110010011100001"],
]

static casesNatSub = [
    ["1011010", "1011010", ""],
    ["1011010", "0000001", "1011001"],
    ["100000101011101000", "10011000000111", "11110010011100001"],
    ["100010", "110111001110", "110110101100"],
    ["10001100001110", "111101101", "10000100100001"],
    ["1010", "10100", "1010"],
    ["101011", "11000", "10011"],
    ["11101110111011111111111011110101010010101101111010101101010101010101011110011010010110010101110110010101101011001011", "11101110111011111111111011110101010010101101111010101101010101010101011110011010010110010101110110010101101011001010", "1"],
]

static casesNatMul = [
    ["1011010", "1011010", "1111110100100"],
    ["1011010", "1", "1011010"],
    ["1011010", "0", ""],
    ["1100010", "100", "110001000"],
    ["100", "1100010", "110001000"],
    ["10001101101110101011110110000110111111101101", "10001101101110101011110110000110111111101101", "100111001110111001111001111111010101001001011000000000110101110110111110110000101101001"],
    ["100111001110111001111001111111010101001001011000000000110101110110111110110000101101001", "100111001110111001111001111111010101001001011000000000110101110110111110110000101101001", "11000000011001110000010110100111100100110000001110100100100001110010010011011011110100000111000000011100100101001011101010001010001100010011110010101111111101011110100010001"],
    ["1010", "10", "10100"],
    ["10", "1010", "10100"],
    ["1010101010101010101010101010101010101010101010", "10", "10101010101010101010101010101010101010101010100"],
    ["10", "1010101010101010101010101010101010101010101010", "10101010101010101010101010101010101010101010100"],
    ["1011", "101", "110111"],
]

static casesNatDiv = [
    ["1010", "1", "1010"],
    ["1010", "10", "101"],
    ["1000000", "110", "1010"],
    ["1001100", "11", "11001"],
    ["1000000", "100", "10000"],
    ["11111011", "1101", "10011"],
    ["10", "11", ""],
    ["10011011001110001", "111", "10110001011001"],
    ["10011001101010", "10", "1001100110101"],
    ["1010101010101010101010101010101010101010101010", "10", "101010101010101010101010101010101010101010101"],
    ["100111001110111001111001111111010101001001011000000000110101110110111110110000101101001", "10", "10011100111011100111100111111101010100100101100000000011010111011011111011000010110100"],
    ["110101101011110101010100111", "110100", "1000010000100101101111"],
    ["110101101011110101010100111", "11011001", "1111110101010101010"],
]

static casesNatMod = [
    ["1010", "1010", ""],
    ["1010", "1", ""],
    ["111001010111011001", "1110110", "11111"],
    ["11101110111011111111111011110101010010101101111010101101010101010101011110011010010110010101110110010101101011001011", "1110101", "1011001"],
    ["11110110110101010101010101111111111011010101010101010101001111111001010101001010101010110000000011111101101001010111001111", "1110101", "1100001"],
    ["0", "11100111", ""],
    ["0", "0", ""],
    ["110101101011110101010100111", "110100", "11011"],
    ["1010", "11", "1"],
]

static casesNatShl: [][]u64 = [
    [1, 8, 256],
    [9834, 32, 42236708388864],
    [9383, 0, 9383],
    [9383, 1, 18766],
    [0, 20, 0],
    [0, 0, 0],
    [123456789, 8, 31604937984],
]

static casesNatShr: [][]u64 = [
    [64, 2, 16],
    [256, 8, 1],
    [89357, 9, 174],
    [3759375747438473473, 49, 6677],
    [0, 90, 0],
    [2, 90, 0],
]

static casesNatBitOr: [][]u64 = [
    [20, 4, 20],
    [4, 20, 20],
    [345, 2, 347],
    [908474739, 747688553334, 748259113847],
    [97799739579632223, 1234567890, 97799739731806943],
]

static casesNatBitAnd: [][]u64 = [
    [902984, 24, 8],
    [24, 902984, 8],
    [902984, 2434, 256],
    [2434, 902984, 256],
    [77786486463864864, 97774749933, 19360907296],
    [123456789, 987654321, 39471121],
]

static casesNatBitXor: [][]u64 = [
    [10, 11, 1],
    [87793, 5, 87796],
    [5, 87793, 87796],
    [10, 1, 11],
    [1, 10, 11],
    [12345, 54321, 58376],
    [123, 321, 314],
    [1234567890, 9876543210, 8676316216],
]

static casesNatTrailingZeros = [
    [0b111010101010111101010110000000, 7],
    [0b111111111111111111111110000000, 7],
    [0, 0],
    [1, 0],
    [0b10, 1],
    [0b101101000, 3],
]

#test
fn testNatFromBits(mut t: &T) {
    for _, c in casesNatFromBits {
        let n = nat.parse(c, 2) else {
            t.Errorf("exceptional occurs: {}", error)
            continue
        }
        if len(n.bits) != len(c) {
            t.Errorf("{} != {}", c, c)
            continue
        }
        for i, b in n.bits {
            let cb = c[len(c)-1-i]
            if b == 0b1 && cb != '1' ||
                b == 0b0 && cb != '0' {
                t.Errorf("{} != {}", c, c)
                break
            }
        }
    }
}

fn testCommonNatOp(mut &t: &T, op: str, &cases: [][]str) {
    for _, c in cases {
        let mut n1 = nat.parse(c[0], 2) else {
            t.Errorf("exception occurs: {}", error)
            continue
        }
        let n2 = nat.parse(c[1], 2) else {
            t.Errorf("exception occurs: {}", error)
            continue
        }
        match op {
        | "+":
            n1 += n2
        | "-":
            n1 -= n2
        | "*":
            n1 *= n2
        | "/":
            n1 /= n2
        | "%":
            n1 %= n2
        }
        let cr = c[2]
        if n1.len() != len(cr) {
            t.Errorf("{} {} {} != {}", c[0], op, c[1], cr)
            continue
        }
        for i, b in n1.bits {
            let cb = cr[len(cr)-1-i]
            if b == 0b1 && cb != '1' ||
                b == 0b0 && cb != '0' {
                t.Errorf("{} {} {} != {}", c[0], op, c[1], cr)
                break
            }
        }
    }
}

#test
fn testNatAdd(mut t: &T) {
    testCommonNatOp(t, "+", casesNatAdd)
}

#test
fn testNatSub(mut t: &T) {
    testCommonNatOp(t, "-", casesNatSub)
}

#test
fn testNatMul(mut t: &T) {
    testCommonNatOp(t, "*", casesNatMul)
}

#test
fn testNatDiv(mut t: &T) {
    testCommonNatOp(t, "/", casesNatDiv)
}

#test
fn testNatMod(mut t: &T) {
    testCommonNatOp(t, "%", casesNatMod)
}

fn testNatBitBinary(mut &t: &T, op: str, &cases: [][]u64) {
    for _, c in cases {
        let mut n1 = nat.new(c[0])
        let n2 = nat.new(c[1])
        match op {
        | "|":
            n1 |= n2
        | "&":
            n1 &= n2
        | "^":
            n1 ^= n2
        }
        let u = n1.toU64()!
        if u != c[2] {
            t.Errorf("{} {} {} != {}", c[0], op, c[1], c[2])
        }
    }
}

#test
fn testNatBitOr(mut t: &T) {
    testNatBitBinary(t, "|", casesNatBitOr)
}

#test
fn testNatBitAnd(mut t: &T) {
    testNatBitBinary(t, "&", casesNatBitAnd)
}

#test
fn testNatBitXor(mut t: &T) {
    testNatBitBinary(t, "^", casesNatBitXor)
}

#test
fn testNatShl(mut t: &T) {
    for _, c in casesNatShl {
        let n = nat.new(c[0])
        let mut r = n << uint(c[1])
        let u = r.toU64()!
        if u != c[2] {
            t.Errorf("{} << {} != {}", c[0], c[1], c[2])
        }
    }
}

#test
fn testNatShr(mut t: &T) {
    for _, c in casesNatShr {
        let n = nat.new(c[0])
        let mut r = n >> uint(c[1])
        let u = r.toU64()!
        if u != c[2] {
            t.Errorf("{} >> {} != {}", c[0], c[1], c[2])
        }
    }
}

#test
fn testNatTrailingBits(mut t: &T) {
    for _, c in casesNatTrailingZeros {
        let n = nat.new(c[0])
        let zeros = n.trailingZeros()
        if zeros != c[1] {
            t.Errorf("expected {}, found {}, for input {}", c[1], zeros, c[0])
        }
    }
}

#test
fn testNatLt(mut t: &T) {
    t.Assert(!nat.parse("1011010", 2)!.Lt(nat.parse("00001011010", 2)!), "1) 1011010 < 00001011010")
    t.Assert(!nat.parse("1111011000", 2)!.Lt(nat.parse("000000000001111011000", 2)!), "2) 1111011000 < 000000000001111011000")
    t.Assert(!nat.parse("10001100011000", 2)!.Lt(nat.parse("100011", 2)!), "3) 10001100011000 < 100011")
    t.Assert(!nat.parse("10001101101110101011110110000110111111101111", 2)!.Lt(nat.parse("10001101101110101011110110000110111111101101", 2)!), "4) 10001101101110101011110110000110111111101111 < 10001101101110101011110110000110111111101101")
}

#test
fn testNatGt(mut t: &T) {
    t.Assert(!nat.parse("1011010", 2)!.Gt(nat.parse("00001011010", 2)!), "1) 1011010 > 00001011010")
    t.Assert(!nat.parse("1111011000", 2)!.Gt(nat.parse("000000000001111011000", 2)!), "2) 1111011000 > 000000000001111011000")
    t.Assert(nat.parse("10001100011000", 2)!.Gt(nat.parse("100011", 2)!), "3) 10001100011000 <= 100011")
    t.Assert(nat.parse("10001101101110101011110110000110111111101111", 2)!.Gt(nat.parse("10001101101110101011110110000110111111101101", 2)!), "4) 10001101101110101011110110000110111111101111 <= 10001101101110101011110110000110111111101101")
    t.Assert(!nat.parse("10000100100001", 2)!.Gt(nat.parse("10011001101010", 2)!), "5) 10000100100001 >= 10011001101010")
}

#test
fn testNatEq(mut t: &T) {
    t.Assert(nat.parse("1011010", 2)!.Eq(nat.parse("00001011010", 2)!), "1) 1011010 != 00001011010")
    t.Assert(nat.parse("1111011000", 2)!.Eq(nat.parse("000000000001111011000", 2)!), "2) 1111011000 != 000000000001111011000")
    t.Assert(nat.parse("10001100011000", 2)!.Eq(nat.parse("10001100011000", 2)!), "3) 10001100011000 != 10001100011000")
    t.Assert(nat.parse("10001101101110101011110110000110111111101101", 2)!.Eq(nat.parse("10001101101110101011110110000110111111101101", 2)!), "4) 10001101101110101011110110000110111111101101 != 10001101101110101011110110000110111111101101")
}