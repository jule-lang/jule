// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// An arbitrary-precision natural number.
#derive Clone
struct Nat {
    mut bits: bits
}

impl Nat {
    // Returns Nat that represents zero.
    static fn zero(): Nat {
        ret Nat{}
    }

    // Returns Nat that represents one.
    static fn one(): Nat {
        ret Nat{
            bits: [1],
        }
    }

    // Returns Nat that initialized by integer value.
    // T can only be signed or unsigned integer types.
    pub static fn new[T](mut i: T): Nat {
        match type T {
        | Nat:
            ret i
        }
        let mut nat = Nat.zero()
        match type T {
        | i8:
            nat.bits = make(bits, 1 << 3 - 1)
        | u8:
            nat.bits = make(bits, 1 << 3)
        | i16:
            nat.bits = make(bits, 1 << 4 - 1)
        | u16:
            nat.bits = make(bits, 1 << 4)
        | i32:
            nat.bits = make(bits, 1 << 5 - 1)
        | u32:
            nat.bits = make(bits, 1 << 5)
        | i64:
            nat.bits = make(bits, 1 << 6 - 1)
        | u64:
            nat.bits = make(bits, 1 << 6)
        | int:
            nat.bits = make(bits, INT_SIZE - 1)
        | uint:
            nat.bits = make(bits, INT_SIZE)
        |:
            panic("std::math::big: Nat.new[T]: T is should be signed or unsigned integer type")
        }
        if i < 0 {
            i = -i
        }
        for j in nat.bits {
            nat.bits[j] = bit((i >> j) & 0b1)
        }
        nat.fit()
        ret nat
    }

    // Parse Nat from bits that represented in string.
    // Results with exceptional if bits are not in the format or empty.
    // Exceptional is always BigError.Format.
    static fn from_bits(b: str)!: Nat {
        if b == "" {
            error(BigError.Format)
        }
        // Eliminate initial-zeros to normalize and fit minimum mandatory bit-size.
        let mut j = 0
        for j < b.len; j++ {
            if b[j] != '0' {
                break
            }
        }
        if b.len == j {
            // All bits are zero.
            ret Nat.zero()
        }
        let mut n = Nat{
            bits: make(bits, 0, b.len - j),
        }
        let mut k = b.len - 1
        for k >= j; k-- {
            match b[k] {
            | '1':
                n.bits = append(n.bits, 0b1)
            | '0':
                n.bits = append(n.bits, 0b0)
            |:
                error(BigError.Format)
            }
        }
        ret n
    }

    // Returns count of bits.
    // Return value also means the minimum number of bits that can represent the integer.
    fn len(self): int {
        ret self.bits.len
    }

    // Eliminates initial-zeros, normalizes bits.
    fn fit(mut self) {
        fit(self.bits)
    }

    // Adds two Nat and returns result.
    pub fn add(self, y: Nat): Nat {
        let mut r = self
        r += y
        ret r
    }

    // Adds Nat.
    pub fn add_assign(mut self, y: Nat) {
        match {
        | y.len() == 0:
            ret
        | y.len() == 1 | self.len() >= y.len():
            self.bits = clone(self.bits)
        }
        add_res(self.bits, y.bits)
    }

    // Subtracts two Nat and returns result.
    pub fn sub(self, y: Nat): Nat {
        let mut r = self
        r -= y
        ret r
    }

    // Subtracts Nat.
    pub fn sub_assign(mut self, y: Nat) {
        match {
        | y.len() == 0:
            ret
        | y.len() == 1 | self.len() >= y.len():
            self.bits = clone(self.bits)
        }
        sub_res(self.bits, y.bits)
        self.fit()
    }

    // Multiplies two Nat and returns result.
    pub fn mul(self, y: Nat): Nat {
        let mut r = self
        r *= y
        ret r
    }

    // Multiplies Nat.
    pub fn mul_assign(mut self, y: Nat) {
        match y.len() {
        | 1:
            ret
        | 0:
            self.bits = nil
            ret
        }

        // The opeand y is small number.
        // Use basic algorithm instead of karatsuba.
        if y.len() < KARATSUBA_THRESHOLD {
            self.bits = basic_mul(self.bits, y.bits)
            self.fit()
            ret
        }

        let mut xb = self.bits
        let mut yb = y.bits
        let n = max(xb.len, yb.len)
        if xb.len < n {
            let mut xbn = make(bits, n)
            _ = copy(xbn, xb)
            xb = xbn
        }
        if yb.len < n {
            let mut ybn = make(bits, n)
            _ = copy(ybn, yb)
            yb = ybn
        }

        // Reverse bits, karatsuba uses normal-order bits.
        reverse(xb)
        reverse(yb)

        let mut r = karatsuba(xb, yb)

        // Reverse bits to save internal order.
        if self.len() < n {
            reverse(self.bits)
        }
        if y.len() < n {
            reverse(y.bits)
        }
        reverse(r)

        self.bits = r
        self.fit()
    }

    // Divides two Nat and returns result.
    pub fn div(self, y: Nat): Nat {
        let mut r = self
        r /= y
        ret r
    }

    // Divides Nat.
    pub fn div_assign(mut self, y: Nat) {
        match {
        | y.len() == 1:
            ret
        | y.len() == 0:
            panic("std::math::big: division by zero")
        }
        match self.cmp(y) {
        | -1:
            self.bits = nil
            ret
        | 0:
            self = Nat.one()
            ret
        }
        // Use clone because of recursive division can change left operand.
        let mut xb = clone(self.bits)
        self.bits = recursive_div(xb, y.bits)
        self.fit()
    }

    // Bitwise left shift.
    pub fn shl(self, y: uint): Nat {
        let mut r = self
        r <<= y
        ret r
    }

    // Bitwise left shift for assignment.
    pub fn shl_assign(mut self, y: uint) {
        if y > 0 && self.len() > 0 {
            let mut xbits = make(bits, self.len() + int(y))
            _ = copy(xbits[y:], self.bits)
            self.bits = xbits
        }
    }

    // Bitwise right shift.
    pub fn shr(self, y: uint): Nat {
        let mut r = self
        r >>= y
        ret r
    }

    // Bitwise right shift for assignment.
    pub fn shr_assign(mut self, y: uint) {
        if y == 0 {
            ret
        }
        if y > uint(self.len()) {
            self.bits = nil
            ret
        }
        self.bits = self.bits[y:]
    }

    // Compares bits.
    // Returns +1 if self > y.
    // Returns 0 if self == y.
    // Returns -1 if self < y.
    fn cmp(self, y: Nat): int {
        ret cmp(self.bits, y.bits)
    }

    // Reports whether integer less than other.
    pub fn lt(self, y: Nat): bool {
        ret self.cmp(y) == -1
    }

    // Reports whether integer less than or equals to other.
    pub fn lt_eq(self, y: Nat): bool {
        ret self.cmp(y) < +1
    }

    // Reports whether integer greater than other.
    pub fn gt(self, y: Nat): bool {
        ret self.cmp(y) == +1
    }

    // Reports whether integer greater than or equals to other.
    pub fn gt_eq(self, y: Nat): bool {
        ret self.cmp(y) > -1
    }

    // Reports whether bits are equals.
    pub fn eq(self, y: Nat): bool {
        ret self.cmp(y) == 0
    }

    // Reports whether number is odd.
    pub fn odd(self): bool {
        ret is_odd(self.bits)
    }

    // Reports whether number is even.
    pub fn even(self): bool {
        ret is_even(self.bits)
    }

    // Returns bit by index.
    // The index zero means first bit at right.
    pub fn bit(self, i: int): int {
        if i < 0 {
            panic("std::math::big: negative bit index")
        }
        if i >= self.len() {
            ret 0
        }
        ret int(self.bits[i])
    }

    // Returns integer in u64.
    // Causes exception if nuber large than capacity of u64.
    // Exception is always equals to u64.MAX constant.
    fn to_u64(self)!: u64 {
        if self.len() > 64 {
            error(u64.MAX)
        }
        ret u64_from_bits(self.bits)
    }
}
