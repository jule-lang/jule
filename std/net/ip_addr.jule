// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Returns the address of the IPv4 address given by the 4-bytes representation.
fn ipAddrFrom4(addr: []byte): u128 {
    ret u128{
        hi: 0,
        lo: 0xFFFF00000000 | u64(addr[0]) << 24 | u64(addr[1]) << 16 | u64(addr[2]) << 8 | u64(addr[3]),
    }
}

// Returns the address of the IPv6 address given by the 16-bytes representation.
fn ipAddrFrom16(addr: []byte): u128 {
    ret u128{
        hi: beU64(addr[:8]),
        lo: beU64(addr[8:]),
    }
}

fn beU64(b: []byte): u64 {
    ret u64(b[7]) | u64(b[6]) << 8 | u64(b[5]) << 16 | u64(b[4]) << 24 |
        u64(b[3]) << 32 | u64(b[2]) << 40 | u64(b[1]) << 48 | u64(b[0]) << 56
}

// Returns the i'th byte of ip. If ip is not an IPv4, v4 returns
// unspecified garbage.
fn v4(ip: u128, i: int): byte {
    ret byte(ip.lo >> ((3 - i) << 3))
}

// Returns the i'th 16-bit word of ip. If ip is an IPv4 address,
// this accesses the IPv4-mapped IPv6 address form of the IP.
fn v6u16(ip: u128, i: byte): u16 {
    let mut p = u64((i / 4) % 2)
    if p == 0 {
        p = ip.hi
    } else {
        p = ip.lo
    }
    ret u16(p >> ((3 - i % 4) << 4))
}

// String of the hex digits from 0 to f. It's used in
// appendDecimal and appendHex to format IP addresses.
const digits = "0123456789abcdef"

fn appendDecimal(mut &s: str, x: u8) {
    if x >= 100 {
        s += str(digits[x/100])
    }
    if x >= 10 {
        s += str(digits[x/10%10])
    }
    s += str(digits[x%10])
}

fn appendHex(mut &s: str, x: u16) {
    if x >= 0x1000 {
        s += str(digits[x>>12])
    }
    if x >= 0x100 {
        s += str(digits[x>>8&0xF])
    }
    if x >= 0x10 {
        s += str(digits[x>>4&0xF])
    }
    s += str(digits[x&0xF])
}

fn str4(ip: u128): str {
    const Max = "255.255.255.255".len
    let mut s = make(str, Max)
    appendDecimal(s, v4(ip, 0))
    s += "."
    appendDecimal(s, v4(ip, 1))
    s += "."
    appendDecimal(s, v4(ip, 2))
    s += "."
    appendDecimal(s, v4(ip, 3))
    ret s
}

fn str16(ip: u128): str {
    const Max = "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff%enp5s0".len
    let mut s = make(str, Max)

    let (mut zeroStart, mut zeroEnd) = byte(255), byte(255)
    let mut i = byte(0)
    for i < 8; i++ {
        let mut j = i
        for j < 8 && v6u16(ip, j) == 0 {
            j++
        }
        let mut l = j - i
        if l >= 2 && l > zeroEnd-zeroStart {
            zeroStart, zeroEnd = i, j
        }
    }

    i = 0
    for i < 8; i++ {
        if i == zeroStart {
            s += "::"
            i = zeroEnd
            if i >= 8 {
                break
            }
        } else if i > 0 {
            s += ":"
        }
        appendHex(s, v6u16(ip, i))
    }

    ret s
}