// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use mem for std::mem
use sys for std::sys
use time for std::time
use std::jule::integrated::{Char, Int, Long, UnsignedLong}

type netHandle: uint
type addrLen: Int

fn lastErrorCode(): int {
    ret sys::WSAGetLastError()
}

fn closeSocket(handle: netHandle): bool {
    ret sys::CloseSocket(handle) >= 0
}

fn setSocketBlockingMode(handle: netHandle, mode: UnsignedLong)! {
    let FIONBIO = 0x80000000 | (Long(mem::SizeOf(UnsignedLong) & 0x7F) << 16) | ('f' << 8) | 126
    unsafe {
        if sys::Ioctlsocket(handle, FIONBIO, &mode) == sys::SOCKET_ERROR {
            error(lastErrorCode())
        }
    }
}

fn closeSocketBlockingMode(handle: netHandle)! {
    setSocketBlockingMode(handle, 1) else { error(error) }
}

fn openSocketBlockingMode(handle: netHandle)! {
    setSocketBlockingMode(handle, 0) else { error(error) }
}

unsafe fn connectSocket(handle: netHandle, sockAddr: *sys::Sockaddr, sockLen: uint, timeout: time::DurInt)! {
    if timeout == 0 {
        connectSocketNoTimeout(handle, sockAddr, sockLen) else { error(error) }
        ret
    }
    let tv = timevalFromDuration(timeout)
    if tv.tv_sec == 0 && tv.tv_usec == 0 {
        connectSocketNoTimeout(handle, sockAddr, sockLen) else { error(error) }
        ret
    }
    closeSocketBlockingMode(handle) else { error(error) }
    if sys::Connect(handle, sockAddr, sockLen) != sys::SOCKET_ERROR {
        ret
    }
    let err = lastErrorCode()
    if err != sys::WSAEWOULDBLOCK {
        error(err)
    }
    let fdW = sys::Fd{}
    let mut fdE = sys::Fd{}
    sys::FdZero(&fdW)
    sys::FdSet(handle, &fdW)
    sys::FdZero(&fdE)
    sys::FdSet(handle, &fdE)
    let res = sys::Select(0, nil, &fdW, &fdE, &tv)
    if res <= 0 {
        if res == 0 {
            // Timeout.
            error(-1)
        }
        error(lastErrorCode())
    }
    if sys::FdIsset(handle, &fdE) != 0 {
        let mut opt = Int(0)
        let mut optLen = Int(mem::SizeOf(opt))
        sys::Getsockopt(handle, sys::SOL_SOCKET, sys::SO_ERROR, (*Char)(&opt), &optLen)
        error(int(opt))
    }
    openSocketBlockingMode(handle) else { error(error) }
}

fn recvfrom(&conn: UdpConn, mut &buf: []byte)!: int {
    if conn.v6 {
        let addrLen = addrLen(mem::SizeOf(conn.sockaddr6))
        let n = unsafe { sys::Recvfrom(conn.handle, &buf[0], len(buf), 0, (*sys::Sockaddr)(&conn.sockaddr6), &addrLen) }
        if n >= 0 {
            ret int(n)
        }
    } else {
        let addrLen = addrLen(mem::SizeOf(conn.sockaddr4))
        let n = unsafe { sys::Recvfrom(conn.handle, &buf[0], len(buf), 0, (*sys::Sockaddr)(&conn.sockaddr4), &addrLen) }
        if n >= 0 {
            ret int(n)
        }
    }
    error(lastErrorCode())
}

fn sendto(&conn: UdpConn, &buf: []byte)!: int {
    if conn.v6 {
        let addrLen = addrLen(mem::SizeOf(conn.sockaddr6))
        let n = unsafe { sys::Sendto(conn.handle, &buf[0], len(buf), 0, (*sys::Sockaddr)(&conn.sockaddr6), addrLen) }
        if n >= 0 {
            ret int(n)
        }
    } else {
        let addrLen = addrLen(mem::SizeOf(conn.sockaddr4))
        let n = unsafe { sys::Sendto(conn.handle, &buf[0], len(buf), 0, (*sys::Sockaddr)(&conn.sockaddr4), addrLen) }
        if n >= 0 {
            ret int(n)
        }
    }
    error(lastErrorCode())
}

fn init() {
    let mut wsaData = sys::WsaData{}
    let verReq = sys::MakeWord(2, 2)
    let r = unsafe { sys::WSAStartup(verReq, &wsaData) }
    if r != 0 {
        panic("syd::net [windows specific]: WSAStartup failed")
    }
}