// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::fs::{File}
use nosafe for std::internal::nosafe

// Scanner for files or etc.
// Scans bytes line-by-line.
struct Scanner {
    mut r: Reader
    mut b: []byte
}

impl Scanner {
    const bufferSize = 1 << 10

    // New &Scanner from Reader.
    static fn New(mut r: Reader): &Scanner {
        ret &Scanner{
            r: r,
            b: make([]byte, 0, Scanner.bufferSize),
        }
    }

    // New &Scanner from &File.
    // Uses &FileStream for Reader trait compatibility.
    static fn Newf(mut f: &File): &Scanner {
        ret &Scanner{
            r: FileStream.New(f),
            b: make([]byte, 0, Scanner.bufferSize),
        }
    }
}

impl Scanner {
    fn reset(self) {
        self.b = self.b[:0]
    }

    // Returns bytes of recent scan.
    // Returned slice is mutable copy of buffer.
    fn Bytes(self): []byte { ret self.b }

    // Returns text from bytes of recent scan.
    fn Text(self): str { ret str(self.b) }

    // Scans line from handle via read method.
    // Scans bytes until end of the line, line delimiter is not included.
    // Reports whether readed byte into buffer.
    fn Scan(self)!: bool {
        const LINE_DELIMITER = '\n'

        self.reset()

        let mut partBuff: bufferArray
        let mut part = nosafe::Atobs[bufferArray, bufferArrayElem](partBuff)
        for {
            let n = self.r.Read(part) else {
                ret false
            }
            if n == 0 {
                break
            }
            if part[n-1] == LINE_DELIMITER {
                self.b = append(self.b, part[:n-1]...)
                break
            }
            self.b = append(self.b, part[:n]...)
        }
        clearCr(self.b)
        ret len(self.b) != 0
    }
}

// Clear last carriage return from buff if exist.
fn clearCr[T](mut &buf: T) {
    if len(buf) > 0 && buf[len(buf)-1] == '\r' {
        buf = buf[:len(buf)-1]
    }
}