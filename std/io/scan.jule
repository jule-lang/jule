// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::fs::{File}
use nosafe for std::internal::nosafe

// Scanner for files or etc.
// Scans bytes line-by-line.
pub struct Scanner {
    mut r: Reader
    mut b: []byte
}

impl Scanner {
    const BufferSize = 1 << 10

    // New &Scanner from Reader.
    pub static fn new(mut r: Reader): &Scanner {
        ret &Scanner{
            r: r,
            b: make([]byte, 0, Scanner.BufferSize),
        }
    }

    // New &Scanner from &File.
    // Uses &FileStream for Reader trait compatibility.
    pub static fn newf(mut f: &File): &Scanner {
        ret &Scanner{
            r: FileStream.new(f),
            b: make([]byte, 0, Scanner.BufferSize),
        }
    }
}

impl Scanner {
    fn reset(self) {
        self.b = self.b[:0]
    }

    // Returns bytes of recent scan.
    // Returned slice is mutable copy of buffer.
    pub fn bytes(self): []byte { ret self.b }

    // Returns text from bytes of recent scan.
    pub fn text(self): str { ret str(self.b) }

    // Scans line from handle via read method.
    // Scans bytes until end of the line, line delimiter is not included.
    // Reports whether readed byte into buffer.
    pub fn scan(self)!: bool {
        const LINE_DELIMITER = '\n'

        self.reset()

        let mut part_buff: BufferArray
        let mut part = nosafe::atobs[BufferArray, BufferArrayElem](part_buff)
        for {
            let n = self.r.read(part) else {
                ret false
            }
            if n == 0 {
                break
            }
            if part[n-1] == LINE_DELIMITER {
                self.b = append(self.b, part[:n-1]...)
                break
            }
            self.b = append(self.b, part[:n]...)
        }
        clear_cr(self.b)
        ret self.b.len != 0
    }
}

// Clear last carriage return from buff if exist.
fn clear_cr[T](mut &buf: T) {
    if buf.len > 0 && buf[buf.len-1] == '\r' {
        buf = buf[:buf.len-1]
    }
}
