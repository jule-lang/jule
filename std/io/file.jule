// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use std::fs::{FsError, File}
use nosafe for std::internal::nosafe

// Stream implementation for file handles.
// Uses internally mutable buffer.
pub struct FileStream {
    buff: &File
}

impl FileStream {
    // Returns new FileStream instance for file.
    pub static fn new(mut f: &File): &FileStream {
        ret &FileStream{buff: f}
    }
}

impl Reader for FileStream {}
impl Writer for FileStream {}
impl Stream for FileStream {}

impl FileStream {
    // Returns internal file buffer.
    pub fn file(mut self): &File {
        ret self.buff
    }

    // Read bytes to buffer from stream and returns readed byte count.
    // The number of bytes readed can never exceed the length of the buff.
    // If the buff is larger than the number of bytes that can be read,
    // the buffer will not cause an overflow.
    pub fn read(mut self, mut buff: []byte)!: (n: int) {
        ret self.buff.read(buff) else { error(error) }
    }

    // Writes bytes to stream and returns writed byte count.
    // The number of bytes written can never exceed the length of the buff.
    pub fn write(mut self, buff: []byte)!: (n: int) {
        ret self.buff.write(buff) else { error(error) }
    }

    // Same as write, but writes string.
    // This method is more efficient than write method for strings.
    pub fn write_str(mut self, s: str)!: (n: int) {
        ret self.write(nosafe::stobs(s)) else { error(error) }
    }

    // Same as read_line method, but returns in bytes.
    pub fn read_line_bytes(mut self)!: []byte {
        const LINE_DELIMITER = '\n'

        let mut buff = make([]byte, 0, 1024)
        let mut part = buff[:1]
        buff = buff[1:]
        for {
            let n = self.buff.read(part) else { error(error) }
            if n == 0 {
                break
            }

            let b = part[0]
            buff = append(buff, b)

            if b == LINE_DELIMITER {
                break
            }
        }
        ret buff
    }

    // Reads line from file handle via &File.read method.
    // Returns bytes until line delimiter (\n) byte.
    // Returns zero-length string when reached EOF.
    pub fn read_line(mut self)!: str {
        const LINE_DELIMITER = '\n'

        let mut buff = make(str, 1024)
        let mut part = make([]byte, 1)
        for {
            let n = self.buff.read(part) else { error(error) }
            if n == 0 {
                break
            }

            let b = part[0]
            buff += str(b)

            if b == LINE_DELIMITER {
                break
            }
        }
        ret buff
    }
}