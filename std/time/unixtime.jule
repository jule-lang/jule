// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

const hour = 3600
const day = hour * 24

const unixYearOffset = 1900 // unix-year offset by today
const unixMonthOffset = 1   // unix-month offset by today

const nsecPerMsec = 1000000
const nsecPerSec = nsecPerMsec * msecPerSec
const msecPerSec = 1000
const daysPerY = 365
const daysPer400Y = daysPerY*400 + 97
const daysPer100Y = daysPerY*100 + 24
const daysPer4Y = daysPerY*4 + 1

// 2000-03-01 (mod 400 year, immediately after feb29
const _2000_03_01 = 946684800
const modApoch = _2000_03_01 + day*(31+29)

// Days in month.
static mdays: [...]i64 = [31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29]

// Returns new absolute time by Unix time without nanoseconds.
fn UnixAbs(sec: i64): AbsTime {
	secs := sec - modApoch
	mut days := secs / day
	mut remSecs := secs % day
	if remSecs < 0 {
		remSecs += day
		days--
	}

	mut qcCycles := days / daysPer400Y
	mut remDays := days % daysPer400Y
	if remDays < 0 {
		remDays += daysPer400Y
		qcCycles--
	}

	mut cCycles := remDays / daysPer100Y
	if cCycles == 4 {
		cCycles--
	}
	remDays -= cCycles * daysPer100Y

	mut qCycles := remDays / daysPer4Y
	if qCycles == 25 {
		qCycles--
	}
	remDays -= qCycles * daysPer4Y

	mut remYears := remDays / daysPerY
	if remYears == 4 {
		remYears--
	}
	remDays -= remYears * daysPerY

	mut leap := i64(0)
	if remYears == 0 && (qCycles > 0 || cCycles == 0) {
		leap = 1
	}
	mut yDay := remDays + 31 + 28 + leap
	if yDay >= daysPerY+leap {
		yDay -= daysPerY + leap
	}

	mut months := u64(0)
	for mdays[months] <= remDays; months++ {
		remDays -= mdays[months]
	}

	mut at := AbsTime{}
	at.Year = int(remYears + 4*qCycles + 100*cCycles + 400*qcCycles + 100)
	at.Month = int(months + 2)
	if at.Month >= 12 {
		at.Month -= 12
		at.Year++
	}
	at.Month += unixMonthOffset
	at.Year += unixYearOffset
	at.Day = int(remDays + 1)
	at.WeekDay = int((3 + days) % 7)
	if at.WeekDay <= 0 {
		at.WeekDay += 7
	}
	at.YearDay = int(yDay)
	at.Hour = int(remSecs / hour)
	at.Minute = int(remSecs / 60 % 60)
	at.Second = int(remSecs % 60)
	ret at
}

fn unixYearToSeconds(y: int, mut &leap: bool): i64 {
	if y-2 <= 136 {
		mut leaps := (y - 68) >> 2
		leap = (y-68)&3 == 0
		if leap {
			leaps--
		}
		ret i64(31536000*(y-70) + day*leaps)
	}

	mut leaps := int(0)
	mut centuries := int(0)
	mut cycles := (y - 100) / 400
	mut rem := (y - 100) % 400
	if rem < 0 {
		cycles--
		rem += 400
	}
	if rem == 0 {
		leap = true
		centuries = 0
		leaps = 0
	} else {
		if rem >= 200 {
			if rem >= 300 {
				centuries = 3
				rem -= 300
			} else {
				centuries = 2
				rem -= 200
			}
		} else {
			if rem >= 100 {
				centuries = 1
				rem -= 100
			} else {
				centuries = 0
			}
		}
		if rem == 0 {
			leap = false
			leaps = 0
		} else {
			leaps = rem / 4
			rem %= 4
			leap = rem == 0
		}
	}

	leaps += 97*cycles + 24*centuries
	if leap {
		leaps++
	}

	ret i64((y-100)*31536000 + leaps*day + 946684800 + day)
}

fn unixMonthToSeconds(m: int, leap: bool): i64 {
	// Set seconds through month.
	mut t := i64(0)
	match m {
	| 1:
		t = 31 * day
	| 2:
		t = 59 * day
	| 3:
		t = 90 * day
	| 4:
		t = 120 * day
	| 5:
		t = 151 * day
	| 6:
		t = 181 * day
	| 7:
		t = 212 * day
	| 8:
		t = 243 * day
	| 9:
		t = 273 * day
	| 10:
		t = 304 * day
	| 11:
		t = 334 * day
	}
	if leap && m >= 2 {
		t += day
	}
	ret t
}