// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/runtime"

// The unsigned zero year for internal Unix time calculations.
// Must be 1 mod 400, and times before it will not compute correctly,
// but otherwise can be changed at will.
const absoluteZeroYear = -292277022399

// Offsets to convert between internal and absolute or Unix times.
const absoluteToUnix = -9223372028715321600

// Offsets to convert between Unix time and absolute times.
const unixToAbsolute = 9223372028715321600

// Specifies a month of the year (January = 1, ...).
type Month: int

const January = Month(1)
const February = Month(2)
const March = Month(3)
const April = Month(4)
const May = Month(5)
const June = Month(6)
const July = Month(7)
const August = Month(8)
const September = Month(9)
const October = Month(10)
const November = Month(11)
const December = Month(12)

// Specifies a day of the week (Sunday = 0, ...).
type Weekday: int

const Sunday = Weekday(0)
const Monday = Weekday(1)
const Tuesday = Weekday(2)
const Wednesday = Weekday(3)
const Thursday = Weekday(4)
const Friday = Weekday(5)
const Saturday = Weekday(6)

// A Time represents an instant in time with nanosecond precision.
//
// Zero-value indicates the beginning of Unix time, i.e. zero seconds.
// This means the date January 1, 1970. Implementation can also handle
// the Unix time in the negative plane. For example, -10 seconds should be
// equivalent to Wed Dec 31 1969 23:59:50 UTC+0000.
struct Time {
	sec:  i64
	nsec: i32 // In the range [0, 999999999].
}

impl Time {
	// Returns time in Unix time.
	fn Unix(self): i64 {
		ret self.sec
	}

	// Returns the time as an absolute time.
	// It is called when computing a presentation property like Month or Hour.
	fn abs(self): u64 {
		sec := self.Unix()
		ret u64(sec + unixToAbsolute)
	}

	// Returns the year of the time.
	fn Year(self): int {
		year, _, _, _ := absDate(self.abs(), false)
		ret year
	}

	// Returns the month of the year specified by the time.
	fn Month(self): Month {
		_, month, _, _ := absDate(self.abs(), true)
		ret month
	}

	// Returns the day of the month specified by the time.
	fn Day(self): int {
		_, _, day, _ := absDate(self.abs(), true)
		ret day
	}

	// Returns the day of the week specified by the time.
	fn Weekday(self): Weekday {
		ret absWeekday(self.abs())
	}

	// Returns the hour within the day specified by the time, in the range [0, 23].
	fn Hour(self): int {
		ret int(self.abs()%secPerDay) / secPerHour
	}

	// Returns the second offset within the minute specified by the time, in the range [0, 59].
	fn Second(self): int {
		ret int(self.abs() % secPerMinute)
	}

	// Returns the minute offset within the hour specified by the time, in the range [0, 59].
	fn Minute(self): int {
		ret int(self.abs()%secPerHour) / secPerMinute
	}

	// Returns the nanosecond offset within the second specified by the time,
	// in the range [0, 999999999].
	fn Nanosecond(self): int {
		ret int(self.nsec)
	}

	// Returns the year, month, and day of the time.
	fn Date(self): (year: int, month: Month, day: int) {
		year, month, day, _ = absDate(self.abs(), true)
		ret
	}

	// Returns the hour, minute, and second of the time.
	fn Clock(self): (hour: int, minute: int, second: int) {
		ret absClock(self.abs())
	}
}

fn absClock(abs: u64): (hour: int, minute: int, second: int) {
	second = int(abs % secPerDay)
	hour = second / secPerHour
	second -= hour * secPerHour
	minute = second / secPerMinute
	second -= minute * secPerMinute
	ret
}

fn absWeekday(abs: u64): Weekday {
	// January 1 of the absolute year, like January 1 of 2001, was a Monday.
	sec := (abs + u64(Monday)*secPerDay) % secPerWeek
	ret Weekday(int(sec) / secPerDay)
}

fn absDate(abs: u64, full: bool): (year: int, month: Month, day: int, yday: int) {
	// Split into time and day.
	mut d := abs / secPerDay

	// Account for 400 year cycles.
	mut n := d / daysPer400Y
	mut y := 400 * n
	d -= daysPer400Y * n

	// Cut off 100-year cycles.
	// The last cycle has one extra leap year, so on the last day
	// of that year, day / daysPer100Y will be 4 instead of 3.
	// Cut it back down to 3 by subtracting n>>2.
	n = d / daysPer100Y
	n -= n >> 2
	y += 100 * n
	d -= daysPer100Y * n

	// Cut off 4-year cycles.
	// The last cycle has a missing leap year, which does not
	// affect the computation.
	n = d / daysPer4Y
	y += 4 * n
	d -= daysPer4Y * n

	// Cut off years within a 4-year cycle.
	// The last year is a leap year, so on the last day of that year,
	// day / 365 will be 4 instead of 3. Cut it back down to 3
	// by subtracting n>>2.
	n = d / 365
	n -= n >> 2
	y += n
	d -= 365 * n

	year = int(i64(y) + absoluteZeroYear)
	yday = int(d)

	if !full {
		ret
	}

	day = yday
	if isLeap(year) {
		// Leap year
		match {
		| day > 31+29-1:
			// After leap day; pretend it wasn't there.
			day--
		| day == 31+29-1:
			// Leap day.
			month = February
			day = 29
			ret
		}
	}

	// Estimate month on assumption that every month has 31 days.
	// The estimate may be too low by at most one month, so adjust.
	month = Month(day / 31)
	end := int(daysBefore[month+1])
	mut begin := 0
	if day >= end {
		month++
		begin = end
	} else {
		begin = int(daysBefore[month])
	}

	month++ // because January is 1
	day = day - begin + 1
	ret
}

// Returns the current system time with UTC local.
fn Now(): Time {
	sec, nsec := runtime::timeNow()
	ret Time{sec: sec, nsec: i32(nsec)}
}

// Returns new time by Unix time with nanoseconds.
// It is valid to pass nsec outside the range [0, 999999999].
// Not all sec values have a corresponding time value. One such
// value is 1<<63-1 (the largest i64 value).
fn Unix(mut sec: i64, mut nsec: i64): Time {
	if nsec < 0 || nsec >= 1e9 {
		n := nsec / 1e9
		sec += n
		nsec -= n * 1e9
		if nsec < 0 {
			nsec += 1e9
			sec--
		}
	}
	ret Time{sec: sec, nsec: i32(nsec)}
}

// Absolute time.
struct AbsTime {
	Day:     int
	Weekday: Weekday
	YearDay: int
	Month:   Month
	Year:    int
	Second:  int
	Minute:  int
	Hour:    int
}

const secPerMinute = 60
const secPerHour = 60 * secPerMinute
const secPerDay = 24 * secPerHour
const secPerWeek = 7 * secPerDay

const daysPerY = 365
const daysPer400Y = daysPerY*400 + 97
const daysPer100Y = daysPerY*100 + 24
const daysPer4Y = daysPerY*4 + 1

// Returns new absolute time by Unix time without nanoseconds.
fn UnixAbs(sec: i64): AbsTime {
	abs := u64(sec) + unixToAbsolute
	mut t := AbsTime{}
	t.Year, t.Month, t.Day, t.YearDay = absDate(abs, true)
	t.Weekday = absWeekday(abs)
	t.Hour, t.Minute, t.Second = absClock(abs)
	ret t
}

fn isLeap(year: int): bool {
	ret year%4 == 0 && (year%100 != 0 || year%400 == 0)
}

// Takes a year and returns the number of days from
// the absolute epoch to the start of that year.
// This is basically (year - zeroYear) * 365, but accounting for leap days.
fn daysSinceEpoch(year: int): u64 {
	mut y := u64(i64(year) - absoluteZeroYear)

	// Add in days from 400-year cycles.
	mut n := y / 400
	y -= 400 * n
	mut d := daysPer400Y * n

	// Add in 100-year cycles.
	n = y / 100
	y -= 100 * n
	d += daysPer100Y * n

	// Add in 4-year cycles.
	n = y / 4
	y -= 4 * n
	d += daysPer4Y * n

	// Add in non-leap years.
	n = y
	d += 365 * n

	ret d
}

fn norm(mut hi: int, mut lo: int, base: int): (nhi: int, nlo: int) {
	if lo < 0 {
		n := (-lo-1)/base + 1
		hi -= n
		lo += n * base
	}
	if lo >= base {
		n := lo / base
		hi += n
		lo -= n * base
	}
	ret hi, lo
}

// daysBefore[m] counts the number of days in a non-leap year
// before month m begins. There is an entry for m=12, counting
// the number of days before January of next year (365).
static daysBefore: [...]i32 = [
	0,
	31,
	31 + 28,
	31 + 28 + 31,
	31 + 28 + 31 + 30,
	31 + 28 + 31 + 30 + 31,
	31 + 28 + 31 + 30 + 31 + 30,
	31 + 28 + 31 + 30 + 31 + 30 + 31,
	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,
	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,
	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31,
]

// Internal implementation of the Date function, but returns Unix time instead of Time.
// It normalizes nsecond and updates its value. So remaining nanoseconds is
// stored in nsecond after normalization.
// See the Date function for public documentation.
fn absUnix(mut year: int, mut month: Month, mut day: int,
	mut hour: int, mut minute: int, mut second: int, mut &nsecond: int): i64 {
	// Normalize month, overflowing into year.
	mut m := int(month - 1)
	year, m = norm(year, m, 12)
	month = Month(m + 1) // Switch to [0, 12) range from (0, 12] range.

	// Normalize nsecond, second, minute, hour, overflowing into day.
	second, nsecond = norm(second, nsecond, 1e9)
	minute, second := norm(minute, second, 60)
	hour, minute = norm(hour, minute, 60)
	day, hour = norm(day, hour, 24)

	// Compute days since the absolute epoch.
	mut d := daysSinceEpoch(year)

	// Add in days before this month.
	d += u64(daysBefore[month-1])
	if isLeap(year) && month >= March {
		d++ // February 29
	}

	// Add in days before today.
	d += u64(day - 1)

	// Add in time elapsed today.
	mut abs := d * secPerDay
	abs += u64(hour*secPerHour + minute*60 + second)

	// Convert absolute time to Unix time.
	unix := i64(abs) + absoluteToUnix
	ret unix
}

// Returns the Time corresponding to
//
//  yyyy-mm-dd hh:mm:ss + nsec nanoseconds
//
// in the appropriate zone for that time in the given location.
//
// The month, day, hour, minute, second, and nsecond values may be outside
// their usual ranges and will be normalized during the conversion.
// For example, October 32 converts to November 1.
fn Date(year: int, month: Month, day: int,
	hour: int, minute: int, second: int, nsecond: int): (t: Time) {
	t.sec = absUnix(year, month, day, hour, minute, second, unsafe { *(&nsecond) })
	t.nsec = i32(nsecond)
	ret t
}