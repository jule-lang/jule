// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use "std/math/bits"
use "std/runtime"

// The unsigned zero year for internal Unix time calculations.
// Must be 1 mod 400, and times before it will not compute correctly,
// but otherwise can be changed at will.
const absoluteZeroYear = -292277022399

// Offsets to convert between internal and absolute or Unix times.
const absoluteToUnix = -9223372028715321600

// Offsets to convert between Unix time and absolute times.
const unixToAbsolute = 9223372028715321600

// Specifies a month of the year (January = 1, ...).
type Month: int

const January = Month(1)
const February = Month(2)
const March = Month(3)
const April = Month(4)
const May = Month(5)
const June = Month(6)
const July = Month(7)
const August = Month(8)
const September = Month(9)
const October = Month(10)
const November = Month(11)
const December = Month(12)

fn daysIn(m: Month, year: int): int {
	if m == February {
		if isLeap(year) {
			ret 29
		}
		ret 28
	}
	// With the special case of February eliminated, the pattern is
	//	31 30 31 30 31 30 31 31 30 31 30 31
	// Adding m&1 produces the basic alternation;
	// adding (m>>3)&1 inverts the alternation starting in August.
	ret 30 + int((m+m>>3)&1)
}

// daysBefore returns the number of days in a non-leap year before month m.
// daysBefore(December+1) returns 365.
fn daysBefore(m: Month): int {
	mut adj := 0
	if m >= March {
		adj = -2
	}

	// With the -2 adjustment after February,
	// we need to compute the running sum of:
	//	0  31  30  31  30  31  30  31  31  30  31  30  31
	// which is:
	//	0  31  61  92 122 153 183 214 245 275 306 336 367
	// This is almost exactly 367/12×(m-1) except for the
	// occasonal off-by-one suggesting there may be an
	// integer approximation of the form (a×m + b)/c.
	// A brute force search over small a, b, c finds that
	// (214×m - 211) / 7 computes the function perfectly.
	ret (214*int(m)-211)/7 + adj
}

// Specifies a day of the week (Sunday = 0, ...).
type Weekday: int

const Sunday = Weekday(0)
const Monday = Weekday(1)
const Tuesday = Weekday(2)
const Wednesday = Weekday(3)
const Thursday = Weekday(4)
const Friday = Weekday(5)
const Saturday = Weekday(6)

// A Time represents an instant in time with nanosecond precision.
//
// Zero-value indicates the beginning of Unix time, i.e. zero seconds.
// This means the date January 1, 1970. Implementation can also handle
// the Unix time in the negative plane. For example, -10 seconds should be
// equivalent to Wed Dec 31 1969 23:59:50 UTC+0000.
struct Time {
	sec:  i64
	nsec: i32 // In the range [0, 999999999].

	mut loc: &Location
}

impl Time {
	// Returns time in Unix time.
	fn Unix(self): i64 {
		ret self.sec
	}

	fn setLoc(mut self, mut &loc: Location) {
		if &loc == &utcLoc {
			self.loc = nil
			ret
		}
		self.loc = unsafe { (&Location)(&loc) }
	}

	// Returns time with the location set to UTC.
	fn UTC(self): Time {
		mut t := self
		t.setLoc(utcLoc)
		ret t
	}

	// Returns time with the location set to local time.
	fn Local(self): Time {
		mut t := self
		t.setLoc(localLoc)
		ret t
	}

	// Returns the time as an absolute time, adjusted by the zone offset.
	// It is called when computing a presentation property like Month or Hour.
	fn abs(self): u64 {
		mut l := self.loc
		if l == nil || l == Local {
			l = l.get()
		}
		mut sec := self.Unix()
		if l != UTC {
			if l.cacheZone != nil && l.cacheStart <= sec && sec < l.cacheEnd {
				sec += i64(l.cacheZone.offset)
			} else {
				_, offset, _, _, _ := l.lookup(sec)
				sec += i64(offset)
			}
		}
		ret u64(sec + unixToAbsolute)
	}

	// Returns the year of the time.
	fn Year(self): int {
		year, _, _, _ := absDate(self.abs(), false)
		ret year
	}

	// Returns the month of the year specified by the time.
	fn Month(self): Month {
		_, month, _, _ := absDate(self.abs(), true)
		ret month
	}

	// Returns the day of the month specified by the time.
	fn Day(self): int {
		_, _, day, _ := absDate(self.abs(), true)
		ret day
	}

	// Returns the day of the week specified by the time.
	fn Weekday(self): Weekday {
		ret absWeekday(self.abs())
	}

	// Returns the hour within the day specified by the time, in the range [0, 23].
	fn Hour(self): int {
		ret int(self.abs()%secPerDay) / secPerHour
	}

	// Returns the second offset within the minute specified by the time, in the range [0, 59].
	fn Second(self): int {
		ret int(self.abs() % secPerMinute)
	}

	// Returns the minute offset within the hour specified by the time, in the range [0, 59].
	fn Minute(self): int {
		ret int(self.abs()%secPerHour) / secPerMinute
	}

	// Returns the nanosecond offset within the second specified by the time,
	// in the range [0, 999999999].
	fn Nanosecond(self): int {
		ret int(self.nsec)
	}

	// Returns the year, month, and day of the time.
	fn Date(self): (year: int, month: Month, day: int) {
		year, month, day, _ = absDate(self.abs(), true)
		ret
	}

	// Returns the hour, minute, and second of the time.
	fn Clock(self): (hour: int, minute: int, second: int) {
		ret absClock(self.abs())
	}

	// Returns the ISO 8601 year and week number of the time.
	// Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to
	// week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1
	// of year n+1.
	fn ISO(self): (year: int, week: int) {
		// According to the rule that the first calendar week of a calendar year is
		// the week including the first Thursday of that year, and that the last one is
		// the week immediately preceding the first calendar week of the next calendar year.
		// See https://www.iso.org/obp/ui#iso:std:iso:8601:-1:ed-1:v1:en:term:3.1.1.23 for details.

		// weeks start with Monday
		// Monday Tuesday Wednesday Thursday Friday Saturday Sunday
		// 1      2       3         4        5      6        7
		// +3     +2      +1        0        -1     -2       -3
		// the offset to Thursday
		mut abs := self.abs()
		mut d := Thursday - absWeekday(abs)
		// handle Sunday
		if d == 4 {
			d = -3
		}
		// find the Thursday of the calendar week
		abs += u64(d) * secPerDay
		year, _, _, yday := absDate(abs, false)
		ret year, yday/7 + 1
	}
}

fn absClock(abs: u64): (hour: int, minute: int, second: int) {
	second = int(abs % secPerDay)
	hour = second / secPerHour
	second -= hour * secPerHour
	minute = second / secPerMinute
	second -= minute * secPerMinute
	ret
}

fn absWeekday(abs: u64): Weekday {
	// January 1 of the absolute year, like January 1 of 2001, was a Monday.
	sec := (abs + u64(Monday)*secPerDay) % secPerWeek
	ret Weekday(int(sec) / secPerDay)
}

fn absDate(abs: u64, full: bool): (year: int, month: Month, day: int, yday: int) {
	// Split into time and day.
	mut d := abs / secPerDay

	// Account for 400 year cycles.
	mut n := d / daysPer400Y
	mut y := 400 * n
	d -= daysPer400Y * n

	// Cut off 100-year cycles.
	// The last cycle has one extra leap year, so on the last day
	// of that year, day / daysPer100Y will be 4 instead of 3.
	// Cut it back down to 3 by subtracting n>>2.
	n = d / daysPer100Y
	n -= n >> 2
	y += 100 * n
	d -= daysPer100Y * n

	// Cut off 4-year cycles.
	// The last cycle has a missing leap year, which does not
	// affect the computation.
	n = d / daysPer4Y
	y += 4 * n
	d -= daysPer4Y * n

	// Cut off years within a 4-year cycle.
	// The last year is a leap year, so on the last day of that year,
	// day / 365 will be 4 instead of 3. Cut it back down to 3
	// by subtracting n>>2.
	n = d / 365
	n -= n >> 2
	y += n
	d -= 365 * n

	year = int(i64(y) + absoluteZeroYear)
	yday = int(d)

	if !full {
		ret
	}

	day = yday
	if isLeap(year) {
		// Leap year
		match {
		| day > 31+29-1:
			// After leap day; pretend it wasn't there.
			day--
		| day == 31+29-1:
			// Leap day.
			month = February
			day = 29
			ret
		}
	}

	// Estimate month on assumption that every month has 31 days.
	// The estimate may be too low by at most one month, so adjust.
	month = Month(day / 31)
	end := int(_daysBefore[month+1])
	mut begin := 0
	if day >= end {
		month++
		begin = end
	} else {
		begin = int(_daysBefore[month])
	}

	month++ // because January is 1
	day = day - begin + 1
	ret
}

// Returns the current system-time UTC.
fn Now(): Time {
	sec, nsec := runtime::timeNow()
	ret Time{sec: sec, nsec: i32(nsec)}
}

// Returns new time by Unix time with nanoseconds.
// Seconds since January 1, 1970 UTC.
// It is valid to pass nsec outside the range [0, 999999999].
// Not all sec values have a corresponding time value. One such
// value is 1<<63-1 (the largest i64 value).
fn Unix(mut sec: i64, mut nsec: i64): Time {
	if nsec < 0 || nsec >= 1e9 {
		n := nsec / 1e9
		sec += n
		nsec -= n * 1e9
		if nsec < 0 {
			nsec += 1e9
			sec--
		}
	}
	ret Time{sec: sec, nsec: i32(nsec)}
}

// Absolute time.
struct AbsTime {
	Day:     int
	Weekday: Weekday
	YearDay: int
	Month:   Month
	Year:    int
	Second:  int
	Minute:  int
	Hour:    int
}

const secPerMinute = 60
const secPerHour = 60 * secPerMinute
const secPerDay = 24 * secPerHour
const secPerWeek = 7 * secPerDay

const daysPerY = 365
const daysPer400Y = daysPerY*400 + 97
const daysPer100Y = daysPerY*100 + 24
const daysPer4Y = daysPerY*4 + 1

// Returns new absolute time by Unix time without nanoseconds.
// Seconds since January 1, 1970 UTC.
fn UnixAbs(sec: i64): AbsTime {
	abs := u64(sec) + unixToAbsolute
	mut t := AbsTime{}
	t.Year, t.Month, t.Day, t.YearDay = absDate(abs, true)
	t.Weekday = absWeekday(abs)
	t.Hour, t.Minute, t.Second = absClock(abs)
	ret t
}

fn isLeap(year: int): bool {
	ret year%4 == 0 && (year%100 != 0 || year%400 == 0)
}

// Takes a year and returns the number of days from
// the absolute epoch to the start of that year.
// This is basically (year - zeroYear) * 365, but accounting for leap days.
fn daysSinceEpoch(year: int): u64 {
	mut y := u64(i64(year) - absoluteZeroYear)

	// Add in days from 400-year cycles.
	mut n := y / 400
	y -= 400 * n
	mut d := daysPer400Y * n

	// Add in 100-year cycles.
	n = y / 100
	y -= 100 * n
	d += daysPer100Y * n

	// Add in 4-year cycles.
	n = y / 4
	y -= 4 * n
	d += daysPer4Y * n

	// Add in non-leap years.
	n = y
	d += 365 * n

	ret d
}

fn norm(mut hi: int, mut lo: int, base: int): (nhi: int, nlo: int) {
	if lo < 0 {
		n := (-lo-1)/base + 1
		hi -= n
		lo += n * base
	}
	if lo >= base {
		n := lo / base
		hi += n
		lo -= n * base
	}
	ret hi, lo
}

// _daysBefore[m] counts the number of days in a non-leap year
// before month m begins. There is an entry for m=12, counting
// the number of days before January of next year (365).
static _daysBefore: [...]i32 = [
	0,
	31,
	31 + 28,
	31 + 28 + 31,
	31 + 28 + 31 + 30,
	31 + 28 + 31 + 30 + 31,
	31 + 28 + 31 + 30 + 31 + 30,
	31 + 28 + 31 + 30 + 31 + 30 + 31,
	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,
	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,
	31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31,
]

// Internal implementation of the Date function, but returns Unix time instead of Time.
// It normalizes nsecond and updates its value. So remaining nanoseconds is
// stored in nsecond after normalization.
// See the Date function for public documentation.
fn absUnix(mut year: int, mut month: Month, mut day: int,
	mut hour: int, mut minute: int, mut second: int, mut &nsecond: int, mut &loc: &Location): i64 {
	// Normalize month, overflowing into year.
	mut m := int(month - 1)
	year, m = norm(year, m, 12)
	month = Month(m + 1) // Switch to [0, 12) range from (0, 12] range.

	// Normalize nsecond, second, minute, hour, overflowing into day.
	second, nsecond = norm(second, nsecond, 1e9)
	minute, second := norm(minute, second, 60)
	hour, minute = norm(hour, minute, 60)
	day, hour = norm(day, hour, 24)

	// Compute days since the absolute epoch.
	mut d := daysSinceEpoch(year)

	// Add in days before this month.
	d += u64(_daysBefore[month-1])
	if isLeap(year) && month >= March {
		d++ // February 29
	}

	// Add in days before today.
	d += u64(day - 1)

	// Add in time elapsed today.
	mut abs := d * secPerDay
	abs += u64(hour*secPerHour + minute*60 + second)

	// Convert absolute time to Unix time.
	mut unix := i64(abs) + absoluteToUnix

	// Look for zone offset for expected time, so we can adjust to UTC.
	// The lookup function expects UTC, so first we pass unix in the
	// hope that it will not be too close to a zone transition,
	// and then adjust if it is.
	_, mut offset, start, end, _ := loc.lookup(unix)
	if offset != 0 {
		utc := unix - i64(offset)
		// If utc is valid for the time zone we found, then we have the right offset.
		// If not, we get the correct offset by looking up utc in the location.
		if utc < start || utc >= end {
			_, offset, _, _, _ = loc.lookup(utc)
		}
		unix -= i64(offset)
	}

	ret unix
}

// Returns the Time corresponding to
//
//  yyyy-mm-dd hh:mm:ss + nsec nanoseconds
//
// in the appropriate zone for that time in the given location.
//
// The month, day, hour, minute, second, and nsecond values may be outside
// their usual ranges and will be normalized during the conversion.
// For example, October 32 converts to November 1.
//
// A daylight savings time transition skips or repeats times.
// For example, in the United States, March 13, 2011 2:15am never occurred,
// while November 6, 2011 1:15am occurred twice. In such cases, the
// choice of time zone, and therefore the time, is not well-defined.
// Date returns a time that is correct in one of the two zones involved
// in the transition, but it does not guarantee which.
fn Date(year: int, month: Month, day: int,
	hour: int, minute: int, second: int, nsecond: int, loc: &Location): (t: Time) {
	t.sec = absUnix(year, month, day, hour, minute, second, unsafe { *(&nsecond) }, unsafe { *(&loc) })
	t.nsec = i32(nsecond)
	ret t
}

// Days from March 1 through end of year.
const marchThruDecember = 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30 + 31

// The number of years we subtract from internal time to get absolute time.
// This value must be 0 mod 400, and it defines the “absolute zero instant”
// mentioned in the “Computations on Times” comment above: March 1, -absoluteYears.
// Dates before the absolute epoch will not compute correctly,
// but otherwise the value can be changed as needed.
const absoluteYears = 292277022400

// Counts the number of seconds since the absolute zero instant.
type absSeconds: u64

// Counts the number of days since the absolute zero instant.
type absDays: u64

// Counts the number of centuries since the absolute zero instant.
type absCentury: u64

// Counts the number of years since the start of a century.
type absCyear: int

// Counts the number of days since the start of a year.
// Note that absolute years start on March 1.
type absYday: int

// Counts the number of months since the start of a year.
// absMonth=0 denotes March.
type absMonth: int

// Single bit (0 or 1) denoting whether a given year is a leap year.
type absLeap: int

// Single bit (0 or 1) denoting whether a given day falls in January or February.
// That is a special case because the absolute years start in March (unlike normal calendar years).
type absJanFeb: int

impl absSeconds {
	// Converts absolute seconds to absolute days.
	fn days(self): absDays {
		ret absDays(self / secPerDay)
	}
}

impl absDays {
	// Splits days into century, cyear, ayday.
	fn split(self): (century: absCentury, cyear: absCyear, ayday: absYday) {
		// See “Computations on Times” comment above.
		d := 4*u64(self) + 3
		century = absCentury(d / 146097)

		// This should be
		//	cday := uint32(d % 146097) / 4
		//	cd := 4*cday + 3
		// which is to say
		//	cday := uint32(d % 146097) >> 2
		//	cd := cday<<2 + 3
		// but of course (x>>2<<2)+3 == x|3,
		// so do that instead.
		cd := u32(d%146097) | 3

		// For cdays in the range [0,146097] (100 years), we want:
		//
		//	cyear := (4 cdays + 3) / 1461
		//	yday := (4 cdays + 3) % 1461 / 4
		//
		// (See the “Computations on Times” comment above
		// as well as Neri and Schneider, section 7.)
		//
		// That is equivalent to:
		//
		//	cyear := (2939745 cdays) >> 32
		//	yday := (2939745 cdays) & 0xFFFFFFFF / 2939745 / 4
		//
		// so do that instead, saving a few cycles.
		// See Neri and Schneider, section 8.3
		// for more about this optimization.
		hi, lo := bits::Mul32(2939745, u32(cd))
		cyear = absCyear(hi)
		ayday = absYday(lo / 2939745 / 4)
		ret
	}

	// Converts days into the standard year and 1-based yday.
	fn yearYday(self): (year: int, yday: int) {
		century, cyear, ayday := self.split()
		janFeb := ayday.janFeb()
		year = century.year(cyear, janFeb)
		yday = ayday.yday(janFeb, century.leap(cyear))
		ret
	}
}

impl absCentury {
	// Returns 1 if (century, cyear) is a leap year, 0 otherwise.
	fn leap(self, cyear: absCyear): absLeap {
		// See “Computations on Times” comment above.
		mut y4ok := 0
		if cyear%4 == 0 {
			y4ok = 1
		}
		mut y100ok := 0
		if cyear != 0 {
			y100ok = 1
		}
		mut y400ok := 0
		if self%4 == 0 {
			y400ok = 1
		}
		ret absLeap(y4ok & (y100ok | y400ok))
	}

	// Returns the standard year for (century, cyear, janFeb).
	fn year(self, cyear: absCyear, janFeb: absJanFeb): int {
		// See “Computations on Times” comment above.
		ret int(u64(self)*100-absoluteYears) + int(cyear) + int(janFeb)
	}
}

impl absYday {
	// Returns 1 if the March 1-based ayday is in January or February, 0 otherwise.
	fn janFeb(self): absJanFeb {
		// See “Computations on Times” comment above.
		mut jf := absJanFeb(0)
		if self >= marchThruDecember {
			jf = 1
		}
		ret jf
	}

	// Returns the standard 1-based yday for (ayday, janFeb, leap).
	fn yday(self, janFeb: absJanFeb, leap: absLeap): int {
		// See “Computations on Times” comment above.
		ret int(self) + (1 + 31 + 28) + int(leap)&^int(janFeb) - 365*int(janFeb)
	}
}