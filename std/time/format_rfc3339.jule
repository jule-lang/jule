// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

fn appendFormatRFC3339(&t: Time, mut b: []byte, nanos: bool): []byte {
	_, offset, abs := t.locabs()

	// Format date.
	year, month, day := abs.days().date()
	b = appendInt(b, year, 4)
	b = append(b, '-')
	b = appendInt(b, int(month), 2)
	b = append(b, '-')
	b = appendInt(b, day, 2)
	b = append(b, 'T')

	// Format time.
	hour, min, sec := abs.clock()
	b = appendInt(b, hour, 2)
	b = append(b, ':')
	b = appendInt(b, min, 2)
	b = append(b, ':')
	b = appendInt(b, sec, 2)

	if nanos {
		std := stdFracSecond(stdFracSecond9, 9, '.')
		b = appendNano(b, t.Nanosecond(), std)
	}

	if offset == 0 {
		ret append(b, 'Z')
	}

	// Format zone.
	mut zone := offset / 60 // convert to minutes
	if zone < 0 {
		b = append(b, '-')
		zone = -zone
	} else {
		b = append(b, '+')
	}
	b = appendInt(b, zone/60, 2)
	b = append(b, ':')
	b = appendInt(b, zone%60, 2)
	ret b
}

fn parseRFC3339[bytes: []byte | str](mut s: bytes, mut local: &Location): (Time, bool) {
	// parseUint parses s as an unsigned decimal integer and
	// verifies that it is within some range.
	// If it is invalid or out-of-range,
	// it sets ok to false and returns the min value.
	mut ok := true
	parseUint := fn(s: bytes, min: int, max: int): (x: int) {
		for _, c in s {
			if c < '0' || '9' < c {
				ok = false
				ret min
			}
			x = x*10 + int(c) - '0'
		}
		if x < min || max < x {
			ok = false
			ret min
		}
		ret x
	}

	// Parse the date and time.
	if len(s) < len("2006-01-02T15:04:05") {
		ret Time{}, false
	}
	year := parseUint(s[0:4], 0, 9999)                       // e.g., 2006
	month := parseUint(s[5:7], 1, 12)                        // e.g., 01
	day := parseUint(s[8:10], 1, daysIn(Month(month), year)) // e.g., 02
	hour := parseUint(s[11:13], 0, 23)                       // e.g., 15
	min := parseUint(s[14:16], 0, 59)                        // e.g., 04
	sec := parseUint(s[17:19], 0, 59)                        // e.g., 05
	if !ok || !(s[4] == '-' && s[7] == '-' && s[10] == 'T' && s[13] == ':' && s[16] == ':') {
		ret Time{}, false
	}
	s = s[19:]

	// Parse the fractional second.
	mut nsec := 0
	if len(s) >= 2 && s[0] == '.' && isDigit(s, 1) {
		mut n := 2
		for n < len(s) && isDigit(s, n); n++ {
		}
		nsec = parseNanoseconds(s, n) else { use 0 }
		s = s[n:]
	}

	// Parse the time zone.
	mut t := Date(year, Month(month), day, hour, min, sec, nsec, UTC)
	if len(s) != 1 || s[0] != 'Z' {
		if len(s) != len("-07:00") {
			ret Time{}, false
		}
		hr := parseUint(s[1:3], 0, 23) // e.g., 07
		mm := parseUint(s[4:6], 0, 59) // e.g., 00
		if !ok || !((s[0] == '-' || s[0] == '+') && s[3] == ':') {
			ret Time{}, false
		}
		mut zoneOffset := (hr*60 + mm) * 60
		if s[0] == '-' {
			zoneOffset *= -1
		}
		t.addSec(-i64(zoneOffset))

		// Use local zone with the given offset if possible.
		_, offset, _, _, _ := local.lookup(t.sec)
		if offset == zoneOffset {
			t.setLoc(local)
		} else {
			mut l := FixedZone("", zoneOffset)
			t.setLoc(l)
		}
	}
	ret t, true
}