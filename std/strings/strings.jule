// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use utf8 for std::unicode::utf8

// Negative situation index such as not found, not exist, or etc.
const N_INDEX = -1

// Returns string that equals to concatenation of n-count s.
// Returns empty string is n <= 0.
pub fn repeat(s: str, mut n: int): str {
    if n <= 0 {
        ret ""
    }

    let mut ss = s
    for n > 1; n-- {
        ss += s
    }
    ret ss
}

fn _has_prefix(&s: str, &sub: str, mut start: int): bool {
    if sub.len == 0 || s.len-start < sub.len {
        ret false
    }

    let mut i = 0
    for i < sub.len; i, start = i + 1, start + 1 {
        if s[start] != sub[i] {
            ret false
        }
    }
    ret true
}

// Reports string has prefix as specified substring or not.
pub fn has_prefix(s: str, sub: str): bool {
    ret _has_prefix(s, sub, 0)
}

fn _has_suffix(&s: str, &sub: str, mut start: int): bool {
    if sub.len == 0 || s.len-start < sub.len {
        ret false
    }

    start = s.len - start
    let mut i = 0
    for i < sub.len; i++ {
        if s[start-i-1] != sub[sub.len-i-1] {
            ret false
        }
    }
    ret true
}

// Reports string has suffix as specified substring or not.
pub fn has_suffix(s: str, sub: str): bool {
    ret _has_suffix(s, sub, 0)
}

// Returns index of first matched item with specified substring,
// returns -1 if not exist any match. Starts searching at left
// of string to right. Starts searching s at given index.
// Returns -1, if i < 0 || i >= s.len.
pub fn find_at(s: str, sub: str, mut i: int): int {
    if i < 0 || s.len < sub.len || sub.len == 0 {
        ret N_INDEX
    }
    for i < s.len; i++ {
        if _has_prefix(s, sub, i) {
            ret i
        }
    }
    ret N_INDEX
}

// Returns index of first matched item with specified substring,
// returns -1 if not exist any match. Starts searching at left
// of string to right.
pub fn find(s: str, sub: str): int {
    ret find_at(s, sub, 0)
}

// Returns index of first matched item with specified substring,
// returns -1 if not exist any match. Starts searching at right
// of string to left. Starts searching s at given index.
// Returns -1, if i < 0 || i >= s.len.
pub fn find_last_at(s: str, sub: str, i: int): int {
    let mut j = i - sub.len + 1
    if sub.len == 0 || i < 0 || i >= s.len || j < 0 {
        ret N_INDEX
    }
loop:
    for j >= 0; j-- {
        let mut k = j
        let mut z = 0
        for z < sub.len; k, z = k+1, z+1 {
            if s[k] != sub[z] {
                continue loop
            }
        }
        ret j
    }
    ret N_INDEX
}

// Returns index of first matched item with specified substring,
// returns -1 if not exist any match. Starts searching at right
// of string to left.
pub fn find_last(s: str, sub: str): int {
    ret find_last_at(s, sub, s.len-1)
}
