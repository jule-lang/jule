// Copyright 2023-2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

use path for std::fs::path
use integrated for std::jule::integrated
use sys for std::sys

impl Directory {
    // Reads the named directory and returs all its directory entries can read.
    //
    // Possible errors:
    //  Denied InvalidDescriptor PerProcessLimit SystemWideLimit
    //  NotExist InsufficientMemory NotDir
    static fn Read(path: str)!: (dirents: []&DirEntry) {
        let utf16Path = integrated::Utf16FromStr(path)
        let mut dir = unsafe { sys::Wopendir(&utf16Path[0]) }
        if dir == nil {
            error(getLastFsError())
        }
        for {
            let dirent = unsafe { sys::Wreaddir(dir) }
            if dirent == nil {
                break
            }
            let name = unsafe { integrated::U16PtrToStr((*u16)(dirent.d_name)) }
            let mut stat = Status.Of(path::Join(path, name)) else { error(error) }
            dirents = append(dirents, &DirEntry{
                Name: name,
                Stat: stat,
            })
        }
        _ = unsafe { sys::Wclosedir(dir) }
        ret
    }

    // Creates directory.
    //
    // Possible errors: Denied Exist ReadOnly NoSpace
    static fn Create(path: str)! {
        // NOTICE
        // Also can has EMLINK error-code.
        // Make sure this situation should documented or not.

        let utf16Path = integrated::Utf16FromStr(path)
        if unsafe { !std::sys::CreateDirectory(&utf16Path[0]) } {
            error(getLastFsError())
        }
    }

    // Removes empty directory.
    //
    // Possible errors: Denined NotExist NotEmpty SyncIO IO Loop NotDir
    static fn Remove(path: str)! {
        let utf16Path = integrated::Utf16FromStr(path)
        if unsafe { !std::sys::RemoveDirectory(&utf16Path[0]) } {
            error(getLastFsError())
        }
    }
}