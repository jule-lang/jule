// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

#build test

use std::testing::{T}
use fastbytes for std::internal::fastbytes

struct convStrCase {
    s: str
    b: []byte
}

static strCases: [...]convStrCase = [
    {s: "hello world", b: []byte("hello world")},
    {s: "foo\vbar\tbaz", b: []byte("foo\vbar\tbaz")},
    {s: "foo", b: []byte("foo")},
    {s: "sLSMFW=(PrUW)=?+Irwjum9PWFsP=)^=+UW", b: []byte("sLSMFW=(PrUW)=?+Irwjum9PWFsP=)^=+UW")},
]

#test
fn testBytes(t: &T) {
    for _, c in strCases {
        sb := Bytes(&c.s[0], len(c.s))
        if !fastbytes::Equal(sb, c.b) {
            t.Errorf("Bytes({}, {}) != {}", c.s, len(c.s), c.b)
        }
    }
}

#test
fn testStrBytes(t: &T) {
    for _, c in strCases {
        sb := StrBytes(c.s)
        if !fastbytes::Equal(sb, c.b) {
            t.Errorf("StrBytes({}) != {}", c.s, c.b)
        }
    }
}

#test
fn testStr(t: &T) {
    for _, c in strCases {
        s := Str(&c.b[0], len(c.b))
        if s != c.s {
            t.Errorf("Str({}, {}) != {}", c.b, len(c.b), c.s)
        }
    }
}

#test
fn testBytesStr(t: &T) {
    for _, c in strCases {
        s := BytesStr(c.b)
        if s != c.s {
            t.Errorf("BytesStr({}) != {}", c.b, c.s)
        }
    }
}

#test
fn testSlice(t: &T) {
    for _, c in strCases {
        sb := Slice(&c.s[0], len(c.s))
        if !fastbytes::Equal(sb, c.b) {
            t.Errorf("Slice(&{}, {}) != {}", c.s, len(c.s), c.b)
        }
    }

    let arr: [...]byte = [90, 23, 83, 84, 1, 3, 4, 5, 0, 0, 2, 48, 84]
    arrs := arr[:]
    s := Slice(&arr[0], len(arr))
    if !fastbytes::Equal(s, arrs) {
        t.Errorf("Slice(&{}, {}) != {}", arr, len(arr), arrs)
    }
}