// Copyright 2023 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.

// Package std::bytes implements functions for the manipulation of byte slices.
// It is analogous to the facilities of the std::strings package.
// But optimized for byte slices, may provide more efficient functions.
// If you have byte slice form of strings, this package is the best option for most cases.

use utf8 for std::unicode::utf8

// Negative situation index such as not found, not exist, or etc.
const N_INDEX = -1

// Returns bytes that equals to concatenation of n-count b.
// Returns nil slice is n <= 0.
pub fn repeat(b: []byte, mut n: int): []byte {
    if n <= 0 {
        ret nil
    }
    if b.len > int.MAX/n {
        panic("std::bytes: repeat: integer buffer size overflow")
    }

    let mut buff = make([]byte, b.len * n)
    let mut i = 0
    for n > 0; n-- {
        i += copy(buff[i:], b)
    }
    ret buff
}

fn _has_prefix(&b: []byte, &sub: []byte, mut start: int): bool {
    if sub.len == 0 || b.len-start < sub.len {
        ret false
    }
    for _, sb in sub {
        if b[start] != sb {
            ret false
        }
        start++
    }
    ret true
}

// Reports byte slice has prefix as specified sub byte slice or not.
pub fn has_prefix(b: []byte, sub: []byte): bool {
    ret _has_prefix(b, sub, 0)
}

fn _has_suffix(&b: []byte, &sub: []byte, mut start: int): bool {
    if sub.len == 0 || b.len-start < sub.len {
        ret false
    }

    start = b.len - start
    for i in sub {
        if b[start-i-1] != sub[sub.len-i-1] {
            ret false
        }
    }
    ret true
}

// Reports byte slice has suffix as specified sub byte slice or not.
pub fn has_suffix(b: []byte, sub: []byte): bool {
    ret _has_suffix(b, sub, 0)
}

// Returns index of first matched item with specified sub byte slice,
// returns -1 if not exist any match. Starts searching at left
// of slice to right. Starts searching b at given index.
// Returns -1, if i < 0 || i >= b.len.
pub fn find_at(b: []byte, sub: []byte, mut i: int): int {
    if i < 0 || b.len < sub.len || sub.len == 0 {
        ret N_INDEX
    }
    for i < b.len; i++ {
        if _has_prefix(b, sub, i) {
            ret i
        }
    }
    ret N_INDEX
}

// Returns index of first matched item with specified sub byte slice,
// returns -1 if not exist any match. Starts searching at left
// of slice to right.
pub fn find(b: []byte, sub: []byte): int {
    ret find_at(b, sub, 0)
}

// Returns index of first matched item with specified sub byte slice,
// returns -1 if not exist any match. Starts searching at right
// of slice to left. Starts searching b at given index.
// Returns -1, if i < 0 || i >= b.len.
pub fn find_last_at(b: []byte, sub: []byte, i: int): int {
    let mut j = i - sub.len + 1
    if sub.len == 0 || i < 0 || i >= b.len || j < 0 {
        ret N_INDEX
    }
loop:
    for j >= 0; j-- {
        let mut k = j
        let mut z = 0
        for z < sub.len; k, z = k+1, z+1 {
            if b[k] != sub[z] {
                continue loop
            }
        }
        ret j
    }
    ret N_INDEX
}

// Returns index of first matched item with specified sub byte slice,
// returns -1 if not exist any match. Starts searching at right
// of slice to left.
pub fn find_last(b: []byte, sub: []byte): int {
    ret find_last_at(b, sub, b.len-1)
}

// Returns index of first matched item with specified byte,
// returns -1 if not exist any match. Starts searching at left
// of slice to right.
pub fn find_byte(b: []byte, e: byte): int {
    for i, be in b {
        if be == e {
            ret i
        }
    }
    ret N_INDEX
}

// Returns index of first matched item with specified rune,
// returns -1 if not exist any match. Starts searching at left
// of slice to right.
pub fn find_rune(b: []byte, r: rune): int {
    let mut i = 0
    for i < b.len {
        let (br, n) = utf8::decode_rune(b[i:])
        if r == br {
            ret i
        }
        i += n
    }
    ret N_INDEX
}
