// Copyright 2024 The Jule Programming Language.
// Use of this source code is governed by a BSD 3-Clause
// license that can be found in the LICENSE file.
struct Int {
    x: int
}

impl Int {
    pub fn Add(self, y: Int): Int {
        ret Int{self.x + y.x}
    }

    pub fn AddAssign(mut self, y: Int) {
        self.x += y.x
    }

    pub fn Sub(self, y: Int): Int {
        ret Int{self.x - y.x}
    }

    pub fn SubAssign(mut self, y: Int) {
        self.x -= y.x
    }

    pub fn Mul(self, y: Int): Int {
        ret Int{self.x * y.x}
    }

    pub fn MulAssign(mut self, y: Int) {
        self.x *= y.x
    }

    pub fn Div(self, y: Int): Int {
        ret Int{self.x / y.x}
    }

    pub fn DivAssign(mut self, y: Int) {
        self.x /= y.x
    }

    pub fn Mod(self, y: Int): Int {
        ret Int{self.x % y.x}
    }

    pub fn ModAssign(mut self, y: Int) {
        self.x %= y.x
    }

    pub fn Shl(self, y: Int): Int {
        ret Int{self.x << y.x}
    }

    pub fn ShlAssign(mut self, y: Int) {
        self.x <<= y.x
    }

    pub fn Shr(self, y: Int): Int {
        ret Int{self.x >> y.x}
    }

    pub fn ShrAssign(mut self, y: Int) {
        self.x >>= y.x
    }

    pub fn BitOr(self, y: Int): Int {
        ret Int{self.x | y.x}
    }

    pub fn BitOrAssign(mut self, y: Int) {
        self.x |= y.x
    }

    pub fn BitAnd(self, y: Int): Int {
        ret Int{self.x & y.x}
    }

    pub fn BitAndAssign(mut self, y: Int) {
        self.x &= y.x
    }

    pub fn BitXor(self, y: Int): Int {
        ret Int{self.x ^ y.x}
    }

    pub fn BitXorAssign(mut self, y: Int) {
        self.x ^= y.x
    }

    pub fn BitNot(self): Int {
        ret Int{^self.x}
    }

    pub fn Neg(self): Int {
        ret Int{-self.x}
    }

    pub fn Pos(self): Int {
        ret Int{+self.x}
    }
}

struct Number[T] {
    x: T
}

impl Number {
    pub fn Add(self, y: Number[T]): Number[T] {
        ret Number[T]{self.x + y.x}
    }

    pub fn AddAssign(mut self, y: Number[T]) {
        self.x += y.x
    }

    pub fn Sub(self, y: Number[T]): Number[T] {
        ret Number[T]{self.x - y.x}
    }

    pub fn SubAssign(mut self, y: Number[T]) {
        self.x -= y.x
    }

    pub fn Mul(self, y: Number[T]): Number[T] {
        ret Number[T]{self.x * y.x}
    }

    pub fn MulAssign(mut self, y: Number[T]) {
        self.x *= y.x
    }

    pub fn Div(self, y: Number[T]): Number[T] {
        ret Number[T]{self.x / y.x}
    }

    pub fn DivAssign(mut self, y: Number[T]) {
        self.x /= y.x
    }

    pub fn Neg(self): Number[T] {
        ret Number[T]{-self.x}
    }

    pub fn Pos(self): Number[T] {
        ret Number[T]{+self.x}
    }
}

fn testInt() {
    let mut x = Int{10}
    let y = Int{20}
    _ = x + y
    x += y
    _ = x - y
    x -= y
    _ = x * y
    x *= y
    _ = x / y
    x /= y
    _ = x % y
    x %= y
    _ = x << y
    x <<= y
    _ = x >> y
    x >>= y
    _ = x | y
    x |= y
    _ = x & y
    x &= y
    _ = x ^ y
    x ^= y
    _ = ^x
    _ = -x
    _ = +x
}

fn testNumber() {
    let mut x = Number[f64]{10}
    let y = Number[f64]{20}
    _ = x + y
    x += y
    _ = x - y
    x -= y
    _ = x * y
    x *= y
    _ = x / y
    x /= y
    _ = -x
    _ = +x
}

fn main() {
    testInt()
    testNumber()
}